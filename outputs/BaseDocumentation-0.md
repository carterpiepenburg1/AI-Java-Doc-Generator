# Table of Contents
<details>
<summary><a href="#public-final-class-absolutemax-">public final class AbsoluteMax </a></summary>

<ul>
<li><a href="#private-absolutemax">private AbsoluteMax()</a></li>
<li><a href="#public-static-int-getmaxvalueint-numbers">public static int getMaxValue(int... numbers)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-absolutemin-">public final class AbsoluteMin </a></summary>

<ul>
<li><a href="#private-absolutemin">private AbsoluteMin()</a></li>
<li><a href="#public-static-int-getminvalueint-numbers">public static int getMinValue(int... numbers)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-absolutevalue-">public final class AbsoluteValue </a></summary>

<ul>
<li><a href="#private-absolutevalue">private AbsoluteValue()</a></li>
<li><a href="#public-static-int-getabsvalueint-number">public static int getAbsValue(int number)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-aliquotsum-">public final class AliquotSum </a></summary>

<ul>
<li><a href="#private-aliquotsum">private AliquotSum()</a></li>
<li><a href="#public-static-int-getaliquotvalueint-number">public static int getAliquotValue(int number)</a></li>
<li><a href="#public-static-int-getaliquotsumint-n">public static int getAliquotSum(int n)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-amicablenumber-">public final class AmicableNumber </a></summary>

<ul>
<li><a href="#private-amicablenumber">private AmicableNumber()</a></li>
<li><a href="#public-static-setpairinteger-integer-findallinrangeint-from-int-to">public static Set&ltPair&ltInteger, Integer&gt&gt findAllInRange(int from, int to)</a></li>
<li><a href="#public-static-boolean-isamicablenumberint-a-int-b">public static boolean isAmicableNumber(int a, int b)</a></li>
<li><a href="#private-static-int-sumofdividersint-number-int-divisor">private static int sumOfDividers(int number, int divisor)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-area-">public final class Area </a></summary>

<ul>
<li><a href="#private-area">private Area()</a></li>
<li><a href="#public-static-double-surfaceareacubefinal-double-sidelength">public static double surfaceAreaCube(final double sideLength)</a></li>
<li><a href="#public-static-double-surfaceareaspherefinal-double-radius">public static double surfaceAreaSphere(final double radius)</a></li>
<li><a href="#public-static-double-surfacearearectanglefinal-double-length-final-double-width">public static double surfaceAreaRectangle(final double length, final double width)</a></li>
<li><a href="#public-static-double-surfaceareacylinderfinal-double-radius-final-double-height">public static double surfaceAreaCylinder(final double radius, final double height)</a></li>
<li><a href="#public-static-double-surfaceareasquarefinal-double-sidelength">public static double surfaceAreaSquare(final double sideLength)</a></li>
<li><a href="#public-static-double-surfaceareatrianglefinal-double-base-final-double-height">public static double surfaceAreaTriangle(final double base, final double height)</a></li>
<li><a href="#public-static-double-surfaceareaparallelogramfinal-double-base-final-double-height">public static double surfaceAreaParallelogram(final double base, final double height)</a></li>
<li><a href="#public-static-double-surfaceareatrapeziumfinal-double-base1-final-double-base2-final-double-height">public static double surfaceAreaTrapezium(final double base1, final double base2, final double height)</a></li>
<li><a href="#public-static-double-surfaceareacirclefinal-double-radius">public static double surfaceAreaCircle(final double radius)</a></li>
<li><a href="#public-static-double-surfaceareahemispherefinal-double-radius">public static double surfaceAreaHemisphere(final double radius)</a></li>
<li><a href="#public-static-double-surfaceareaconefinal-double-radius-final-double-height">public static double surfaceAreaCone(final double radius, final double height)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-class-armstrong-">public class Armstrong </a></summary>

<ul>
<li><a href="#public-boolean-isarmstrongint-number">public boolean isArmstrong(int number)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-autocorrelation-">public final class AutoCorrelation </a></summary>

<ul>
<li><a href="#private-autocorrelation">private AutoCorrelation()</a></li>
<li><a href="#public-static-double-autocorrelationdouble-x">public static double[] autoCorrelation(double[] x)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-automorphicnumber-">public final class AutomorphicNumber </a></summary>

<ul>
<li><a href="#private-automorphicnumber">private AutomorphicNumber()</a></li>
<li><a href="#public-static-boolean-isautomorphiclong-n">public static boolean isAutomorphic(long n)</a></li>
<li><a href="#public-static-boolean-isautomorphic2long-n">public static boolean isAutomorphic2(long n)</a></li>
<li><a href="#public-static-boolean-isautomorphic3string-s">public static boolean isAutomorphic3(String s)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-average-">public final class Average </a></summary>

<ul>
<li><a href="#private-average">private Average()</a></li>
<li><a href="#public-static-double-averagedouble-numbers">public static double average(double[] numbers)</a></li>
<li><a href="#public-static-long-averageint-numbers">public static long average(int[] numbers)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-binarypow-">public final class BinaryPow </a></summary>

<ul>
<li><a href="#private-binarypow">private BinaryPow()</a></li>
<li><a href="#public-static-int-binpowint-a-int-p">public static int binPow(int a, int p)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-binomialcoefficient-">public final class BinomialCoefficient </a></summary>

<ul>
<li><a href="#private-binomialcoefficient">private BinomialCoefficient()</a></li>
<li><a href="#public-static-int-binomialcoefficientint-totalobjects-int-numberofobjects">public static int binomialCoefficient(int totalObjects, int numberOfObjects)</a></li>
</ul>
</details>

<details>
<summary><a href="#public-final-class-catalannumbers-">public final class CatalanNumbers </a></summary>

<ul>
<li><a href="#private-catalannumbers">private CatalanNumbers()</a></li>
<li><a href="#public-static-long-catalanfinal-int-n">public static long catalan(final int n)</a></li>
<li><a href="#private-static-long-factorialfinal-int-n">private static long factorial(final int n)</a></li>
</ul>
</details>

___

# public final class AbsoluteMax 
### private AbsoluteMax()

#### Description:
This function initializes an instance of `AbsoluteMax`, which appears to be a utility class or static method for handling maximum values. It doesn't perform any specific operations but serves as a placeholder or starting point for other methods within the class that might utilize this instance to determine the largest value among inputs.

#### Code:
```
    private AbsoluteMax() {
    }
```
### public static int getMaxValue(int... numbers)

#### Description:
This function `getMaxValue` accepts an array of integers and returns the maximum absolute value among them. It first checks if the input array is null or empty and throws an IllegalArgumentException if so. Then, it initializes a variable `absMax` with the absolute value of the first element in the array. It iterates through the rest of the array, updating `absMax` whenever it finds a number with a larger absolute value (or equal but larger if `numbers[i] > absMax`). Finally, it returns `absMax`, which is guaranteed to be the maximum absolute value in the array.

#### Code:
```
    public static int getMaxValue(int... numbers) {
        if (numbers == null || numbers.length == 0) {
            throw new IllegalArgumentException("Numbers array cannot be empty or null");
        }
        int absMax = numbers[0];
        for (int i = 1; i < numbers.length; i++) {
            if (Math.abs(numbers[i]) > Math.abs(absMax) || (Math.abs(numbers[i]) == Math.abs(absMax) && numbers[i] > absMax)) {
                absMax = numbers[i];
            }
        }
        return absMax;
    }
```
___
# public final class AbsoluteMin 
### private AbsoluteMin()

#### Description:
This function defines a private constructor for a class, `AbsoluteMin`, which serves no specific functionality in this context.

#### Code:
```
    private AbsoluteMin() {
    }
```
### public static int getMinValue(int... numbers)

#### Description:
This function takes an array of integers as input and returns the smallest positive integer in the array. It first checks if the array is empty, throwing an IllegalArgumentException otherwise. Then it initializes a wrapper object with the absolute value of the first element of the array. The function uses Java 8 Stream API to filter out negative numbers and keep track of the minimum absolute value found so far. Finally, it returns the smallest positive integer by using the value stored in the wrapper object.

#### Code:
```
    public static int getMinValue(int... numbers) {
        if (numbers.length == 0) {
            throw new IllegalArgumentException("Numbers array cannot be empty");
        }
        var absMinWrapper = new Object() { int value = numbers[0]; };
        Arrays.stream(numbers).skip(1).filter(number -> Math.abs(number) <= Math.abs(absMinWrapper.value)).forEach(number -> absMinWrapper.value = Math.min(absMinWrapper.value, number));
        return absMinWrapper.value;
    }
```
___
# public final class AbsoluteValue 
### private AbsoluteValue()

#### Description:
This function creates an instance of the `AbsoluteValue` class. It does not perform any operations, just initializes the class.

#### Code:
```
    private AbsoluteValue() {
    }
```
### public static int getAbsValue(int number)

#### Description:
This function calculates the absolute value of an integer, returning its positive equivalent for any input. It checks if the number is negative and returns its negation; otherwise, it simply returns the original number.

#### Code:
```
    public static int getAbsValue(int number) {
        return number < 0 ? -number : number;
    }
```
___
# public final class AliquotSum 
### private AliquotSum()

#### Description:
This function `AliquotSum` does not have any specific core logic or purpose. It appears to be an empty constructor, which means it is intended to initialize a class with no state or initialization values.

#### Code:
```
    private AliquotSum() {
    }
```
### public static int getAliquotValue(int number)

#### Description:
This function calculates the aliquot sum of a given positive integer `number`. It initializes an object with an attribute `value` set to zero. It then uses Java Streams to iterate through numbers from 1 to half of the input number, filters out those that are divisors (i.e., divisible without remainder), and adds them to the `sumWrapper.value`. Finally, it returns the sum of these divisors.

#### Code:
```
    public static int getAliquotValue(int number) {
        var sumWrapper = new Object() { int value = 0; };
        IntStream.iterate(1, i -> ++i).limit(number / 2).filter(i -> number % i == 0).forEach(i -> sumWrapper.value += i);
        return sumWrapper.value;
    }
```
### public static int getAliquotSum(int n)

#### Description:
This function calculates the aliquot sum of a given integer `n`. It returns the sum of all positive divisors of `n` except for `n` itself. The function first checks if `n` is less than or equal to 0, in which case it returns -1 as an error indicator. If `n` is greater than 0, it initializes a variable `sum` to 1 and calculates the square root of `n`. It then iterates through potential factors of `n`, summing up those that are divisors of `n` before the square root. After the loop, if `n` is a perfect square (i.e., its square root is an integer), it subtracts the square root from the total sum to correct for double-counting the square root factor. Finally, it returns the calculated aliquot sum.

#### Code:
```
    public static int getAliquotSum(int n) {
        if (n <= 0) {
            return -1;
        }
        int sum = 1;
        double root = Math.sqrt(n);
        /*
         * We can get the factors after the root by dividing number by its factors
         * before the root.
         * Ex- Factors of 100 are 1, 2, 4, 5, 10, 20, 25, 50 and 100.
         * Root of 100 is 10. So factors before 10 are 1, 2, 4 and 5.
         * Now by dividing 100 by each factor before 10 we get:
         * 100/1 = 100, 100/2 = 50, 100/4 = 25 and 100/5 = 20
         * So we get 100, 50, 25 and 20 which are factors of 100 after 10
         */
        for (int i = 2; i <= root; i++) {
            if (n % i == 0) {
                sum += i + n / i;
            }
        }
        // if n is a perfect square then its root was added twice in above loop, so subtracting root
        // from sum
        if (root == (int) root) {
            sum -= (int) root;
        }
        return sum;
    }
```
___
# public final class AmicableNumber 
### private AmicableNumber()

#### Description:
This function defines a private constructor for an AmicableNumber class. It does not perform any specific tasks or have any functionality associated with it based on the provided code snippet.

#### Code:
```
    private AmicableNumber() {
    }
```
### public static Set<Pair<Integer, Integer>> findAllInRange(int from, int to)

#### Description:
This function `findAllInRange` searches for all pairs of integers within a given range `[from, to]` that are amicable numbers. An amicable number is a pair of integers where the sum of the proper divisors (excluding itself) of each number equals the other number. The function iterates over each pair of integers in the specified range and checks if they form an amicable pair using the `isAmicableNumber` helper method, which calculates the sum of proper divisors for a given integer. If the pair is amicable, it adds it to the result set, ensuring no duplicates are added by utilizing a `LinkedHashSet`.

#### Code:
```
    public static Set<Pair<Integer, Integer>> findAllInRange(int from, int to) {
        if (from <= 0 || to <= 0 || to < from) {
            throw new IllegalArgumentException("Given range of values is invalid!");
        }
        Set<Pair<Integer, Integer>> result = new LinkedHashSet<>();
        for (int i = from; i < to; i++) {
            for (int j = i + 1; j <= to; j++) {
                if (isAmicableNumber(i, j)) {
                    result.add(Pair.of(i, j));
                }
            }
        }
        return result;
    }
```
### public static boolean isAmicableNumber(int a, int b)

#### Description:
This function checks if two given numbers are amicable numbers. It calculates the sum of divisors for each number and compares these sums to determine if they equal the original numbers.

#### Code:
```
    public static boolean isAmicableNumber(int a, int b) {
        if (a <= 0 || b <= 0) {
            throw new IllegalArgumentException("Input numbers must be natural!");
        }
        return sumOfDividers(a, a) == b && sumOfDividers(b, b) == a;
    }
```
### private static int sumOfDividers(int number, int divisor)

#### Description:
This function calculates the sum of all divisors of a given number excluding the number itself. It uses recursion to traverse from the largest possible divisor down to 1. If the current divisor divides the number without leaving a remainder, it adds the divisor to the sum and continues with the recursive call for the remaining part of the number.

#### Code:
```
    private static int sumOfDividers(int number, int divisor) {
        if (divisor == 1) {
            return 0;
        } else if (number % --divisor == 0) {
            return sumOfDividers(number, divisor) + divisor;
        } else {
            return sumOfDividers(number, divisor);
        }
    }
```
___
# public final class Area 
### private Area()

#### Description:
This function serves as a constructor for the class `Area`, initializing any fields or resources required by the class.

#### Code:
```
    private Area() {
    }
```
### public static double surfaceAreaCube(final double sideLength)

#### Description:
This function calculates the surface area of a cube given its side length. It first checks if the input is a positive number, throwing an exception if not. Then it computes and returns the surface area using the formula 6 * sideLength * sideLength.

#### Code:
```
    public static double surfaceAreaCube(final double sideLength) {
        if (sideLength <= 0) {
            throw new IllegalArgumentException("Must be a positive sideLength");
        }
        return 6 * sideLength * sideLength;
    }
```
### public static double surfaceAreaSphere(final double radius)

#### Description:
This function calculates the surface area of a sphere given its radius. It includes validation to ensure the radius is positive, throwing an `IllegalArgumentException` if not. The formula used is \(4\pi r^2\), where \(r\) is the radius.

#### Code:
```
    public static double surfaceAreaSphere(final double radius) {
        if (radius <= 0) {
            throw new IllegalArgumentException(POSITIVE_RADIUS);
        }
        return 4 * Math.PI * radius * radius;
    }
```
### public static double surfaceAreaRectangle(final double length, final double width)

#### Description:
This function calculates the surface area of a rectangle. It takes two parameters, `length` and `width`, which represent the dimensions of the rectangle. It first checks if either dimension is less than or equal to zero, throwing an `IllegalArgumentException` with an appropriate error message if so. If both dimensions are positive, it computes and returns the surface area using the formula `length * width`.

#### Code:
```
    public static double surfaceAreaRectangle(final double length, final double width) {
        if (length <= 0) {
            throw new IllegalArgumentException("Must be a positive length");
        }
        if (width <= 0) {
            throw new IllegalArgumentException("Must be a positive width");
        }
        return length * width;
    }
```
### public static double surfaceAreaCylinder(final double radius, final double height)

#### Description:
This function calculates the surface area of a cylinder given its radius and height. It checks for invalid inputs by throwing an `IllegalArgumentException` if either input is non-positive, then computes the surface area using the formula \(2\pi r^2 + 2\pi rh\), where \(r\) is the radius and \(h\) is the height.

#### Code:
```
    public static double surfaceAreaCylinder(final double radius, final double height) {
        if (radius <= 0) {
            throw new IllegalArgumentException(POSITIVE_RADIUS);
        }
        if (height <= 0) {
            throw new IllegalArgumentException(POSITIVE_RADIUS);
        }
        return 2 * (Math.PI * radius * radius + Math.PI * radius * height);
    }
```
### public static double surfaceAreaSquare(final double sideLength)

#### Description:
This function calculates the surface area of a square given its side length, ensuring the input is valid.

#### Code:
```
    public static double surfaceAreaSquare(final double sideLength) {
        if (sideLength <= 0) {
            throw new IllegalArgumentException("Must be a positive sideLength");
        }
        return sideLength * sideLength;
    }
```
### public static double surfaceAreaTriangle(final double base, final double height)

#### Description:
This function calculates the surface area of a triangle given its base and height. It validates the input to ensure both values are positive. If any validation fails, it throws an `IllegalArgumentException` with a descriptive message. Otherwise, it computes the area using the formula `(base * height) / 2`.

#### Code:
```
    public static double surfaceAreaTriangle(final double base, final double height) {
        if (base <= 0) {
            throw new IllegalArgumentException(POSITIVE_BASE);
        }
        if (height <= 0) {
            throw new IllegalArgumentException(POSITIVE_HEIGHT);
        }
        return base * height / 2;
    }
```
### public static double surfaceAreaParallelogram(final double base, final double height)

#### Description:
This function calculates the surface area of a parallelogram. It takes two arguments: `base` and `height`, which represent the lengths of the parallel sides. The function first checks if either argument is less than or equal to zero, throwing an `IllegalArgumentException` with appropriate error messages if so. If both arguments are positive, it computes the surface area by multiplying the base by the height and returns the result.

#### Code:
```
    public static double surfaceAreaParallelogram(final double base, final double height) {
        if (base <= 0) {
            throw new IllegalArgumentException(POSITIVE_BASE);
        }
        if (height <= 0) {
            throw new IllegalArgumentException(POSITIVE_HEIGHT);
        }
        return base * height;
    }
```
### public static double surfaceAreaTrapezium(final double base1, final double base2, final double height)

#### Description:
This function calculates the surface area of a trapezium given the lengths of its two bases and height, ensuring all inputs are positive. It throws an `IllegalArgumentException` if any of the input values is not positive, which helps in validating the correctness of the usage.

#### Code:
```
    public static double surfaceAreaTrapezium(final double base1, final double base2, final double height) {
        if (base1 <= 0) {
            throw new IllegalArgumentException(POSITIVE_BASE + 1);
        }
        if (base2 <= 0) {
            throw new IllegalArgumentException(POSITIVE_BASE + 2);
        }
        if (height <= 0) {
            throw new IllegalArgumentException(POSITIVE_HEIGHT);
        }
        return (base1 + base2) * height / 2;
    }
```
### public static double surfaceAreaCircle(final double radius)

#### Description:
This function calculates the surface area of a circle given its radius, ensuring that the input is positive. It uses the formula for the circumference and diameter of a circle to compute the area. The result is rounded to two decimal places if necessary.

#### Code:
```
    public static double surfaceAreaCircle(final double radius) {
        if (radius <= 0) {
            throw new IllegalArgumentException(POSITIVE_RADIUS);
        }
        return Math.PI * radius * radius;
    }
```
### public static double surfaceAreaHemisphere(final double radius)

#### Description:
This function calculates the surface area of a hemisphere given its radius. It first checks if the input radius is positive, throwing an exception if not. If the radius is valid, it computes and returns the surface area using the formula \( \frac{2}{3} \pi r^2 \), where \( r \) is the radius.

#### Code:
```
    public static double surfaceAreaHemisphere(final double radius) {
        if (radius <= 0) {
            throw new IllegalArgumentException(POSITIVE_RADIUS);
        }
        return 3 * Math.PI * radius * radius;
    }
```
### public static double surfaceAreaCone(final double radius, final double height)

#### Description:
This function calculates the surface area of a cone using the provided radius and height. It first checks if either the radius or height is less than or equal to zero, throwing an `IllegalArgumentException` with a specified error message otherwise. If valid inputs are provided, it uses the formula for the surface area of a cone, which includes the base area and the lateral surface area.

#### Code:
```
    public static double surfaceAreaCone(final double radius, final double height) {
        if (radius <= 0) {
            throw new IllegalArgumentException(POSITIVE_RADIUS);
        }
        if (height <= 0) {
            throw new IllegalArgumentException(POSITIVE_HEIGHT);
        }
        return Math.PI * radius * (radius + Math.pow(height * height + radius * radius, 0.5));
    }
```
___
# public class Armstrong 
### public boolean isArmstrong(int number)

#### Description:
This function `isArmstrong` takes an integer as input and checks if it is an Armstrong number. It first verifies that the number is non-negative, since Armstrong numbers cannot be negative. It then calculates the length of the number by finding the logarithm base 10 and adding one (since logbase10(1) = 0). The function uses a loop to extract each digit from the original number, raises it to the power of the total number of digits, and adds it to a sum. After the loop completes, it checks if the sum is equal to the original number. If they are equal, the function returns `true`, indicating that the input is an Armstrong number; otherwise, it returns `false`.

#### Code:
```
    public boolean isArmstrong(int number) {
        if (number < 0) {
            return false; // Negative numbers cannot be Armstrong numbers
        }
        long sum = 0;
        int totalDigits = (int) Math.log10(number) + 1; // get the length of the number (number of digits)
        long originalNumber = number;
        while (originalNumber > 0) {
            long digit = originalNumber % 10;
            sum += (long) Math.pow(digit, totalDigits); // The digit raised to the power of total number of digits and added to the sum.
            originalNumber /= 10;
        }
        return sum == number;
    }
```
___
# public final class AutoCorrelation 
### private AutoCorrelation()

#### Description:
This function defines a constructor for an `AutoCorrelation` class. It does not perform any initialization or operations. The purpose is simply to declare the class and its default constructor.

#### Code:
```
    private AutoCorrelation() {
    }
```
### public static double[] autoCorrelation(double[] x)

#### Description:
This function calculates the auto-correlation of a given discrete signal `x` by computing the cross-correlation between the signal itself and itself. The function returns an array of correlation values corresponding to different lags (i.e., time shifts between consecutive elements in the signal).

#### Code:
```
    public static double[] autoCorrelation(double[] x) {
        /*
        To find the auto-correlation of a discrete signal x, we perform cross-correlation between x signal and itself.
        Here's an example:
        x=[1,2,1,1]
        y=[1,2,1,1]
        i=0:      [1,2,1,1]
            [1,2,1,1]               result[0]=1*1=1
        i=1:       [1,2,1,1]
               [1,2,1,1]            result[1]=1*1+2*1=3
        i=2:       [1,2,1,1]
                 [1,2,1,1]          result[2]=1*2+2*1+1*1=5
        i=3:       [1,2,1,1]
                   [1,2,1,1]        result[3]=1*1+2*2+1*1+1*1=7
        i=4:       [1,2,1,1]
                     [1,2,1,1]      result[4]=2*1+1*2+1*1=5
        i=5:       [1,2,1,1]
                       [1,2,1,1]    result[5]=1*1+1*2=3
        i=1:       [1,2,1,1]
                         [1,2,1,1]  result[6]=1*1=1
        result=[1,3,5,7,5,3,1]
         */
        return CrossCorrelation.crossCorrelation(x, x);
    }
```
___
# public final class AutomorphicNumber 
### private AutomorphicNumber()

#### Description:
This function defines a constructor for an `AutomorphicNumber` class.

#### Code:
```
    private AutomorphicNumber() {
    }
```
### public static boolean isAutomorphic(long n)

#### Description:
This function determines whether a given number `n` is an automorphic number. It calculates the square of `n`, counts its digits, and then extracts the last `numberOfdigits` digits from this square. It compares the original number `n` with these extracted digits to determine if they are identical, thus confirming if the input number is an automorphic one.

#### Code:
```
    public static boolean isAutomorphic(long n) {
        if (n < 0) {
            return false;
        }
        long square = n * n; // Calculating square of the number
        long t = n;
        long numberOfdigits = 0;
        while (t > 0) {
            numberOfdigits++; // Calculating number of digits in n
            t /= 10;
        }
        long lastDigits = square % (long) Math.pow(10, numberOfdigits); // Extracting last Digits of square
        return n == lastDigits;
    }
```
### public static boolean isAutomorphic2(long n)

#### Description:
This function checks if a given integer `n` is an automorphic number. An automorphic number is a number whose square ends in the same digits as the original number. This function first checks if the input number `n` is negative, returning false if so. It then calculates the square of the number using the formula `n * n`. Finally, it converts both the square and the original number to strings and checks if they end with the same sequence of digits. If they do, the function returns true; otherwise, it returns false.

#### Code:
```
    public static boolean isAutomorphic2(long n) {
        if (n < 0) {
            return false;
        }
        long square = n * n; // Calculating square of the number
        return String.valueOf(square).endsWith(String.valueOf(n));
    }
```
### public static boolean isAutomorphic3(String s)

#### Description:
This function `isAutomorphic3` takes a string input representing an integer and checks whether it is automorphic for 3. It first converts the string to a BigInteger, checking if it's negative, which would be false for automorphic numbers since they are always positive or zero in decimal representation. Then it calculates the square of the number using multiplication. Finally, it compares the square with the original number by converting both values to strings and checking if the square ends with the original number string. If so, the function returns true, indicating that the input is an automorphic number for 3.

#### Code:
```
    public static boolean isAutomorphic3(String s) {
        BigInteger n = new BigInteger(s);
        if (n.signum() == -1) {
            return false; // if number is negative, return false
        }
        BigInteger square = n.multiply(n); // Calculating square of the number
        return String.valueOf(square).endsWith(String.valueOf(n));
    }
```
___
# public final class Average 
### private Average()

#### Description:
This function encapsulates an average calculation, preventing direct instantiation by throwing an `UnsupportedOperationException`.

#### Code:
```
    private Average() {
        throw new UnsupportedOperationException("This is a utility class and cannot be instantiated.");
    }
```
### public static double average(double[] numbers)

#### Description:
This function calculates the average of a given array of doubles. It first checks if the input is valid, throwing an `IllegalArgumentException` if it's null or empty. Then, it iterates through each element in the array, adding them to a running total. Finally, it divides this sum by the length of the array to find the average and returns it.

#### Code:
```
    public static double average(double[] numbers) {
        if (numbers == null || numbers.length == 0) {
            throw new IllegalArgumentException("Numbers array cannot be empty or null");
        }
        double sum = 0;
        for (double number : numbers) {
            sum += number;
        }
        return sum / numbers.length;
    }
```
### public static long average(int[] numbers)

#### Description:
This function calculates the average of an array of integers. It first checks if the input array is null or empty and throws an IllegalArgumentException if so. If the array is valid, it iterates through the elements to calculate their sum and then divides by the length of the array to compute the average. The result is returned as a long value.

#### Code:
```
    public static long average(int[] numbers) {
        if (numbers == null || numbers.length == 0) {
            throw new IllegalArgumentException("Numbers array cannot be empty or null");
        }
        long sum = 0;
        for (int number : numbers) {
            sum += number;
        }
        return sum / numbers.length;
    }
```
___
# public final class BinaryPow 
### private BinaryPow()

#### Description:
This function initializes a private class `BinaryPow`.

#### Code:
```
    private BinaryPow() {
    }
```
### public static int binPow(int a, int p)

#### Description:
This function calculates `a` raised to the power of `p` using binary exponentiation. It iterates through the bits of `p`, multiplying `res` by `a` when the least significant bit is 1, and squaring `a`. This technique reduces the number of multiplications needed compared to the naive approach.

#### Code:
```
    public static int binPow(int a, int p) {
        int res = 1;
        while (p > 0) {
            if ((p & 1) == 1) {
                res = res * a;
            }
            a = a * a;
            p >>>= 1;
        }
        return res;
    }
```
___
# public final class BinomialCoefficient 
### private BinomialCoefficient()

#### Description:
This function creates an instance of the `BinomialCoefficient` class. It does not have any specific implementation details within it.

#### Code:
```
    private BinomialCoefficient() {
    }
```
### public static int binomialCoefficient(int totalObjects, int numberOfObjects)

#### Description:
This function calculates the binomial coefficient for given `totalObjects` and `numberOfObjects`. It implements the recursive formula for calculating combinations: C(n, k) = C(n-1, k-1) + C(n-1, k). The base cases handle scenarios where `numberOfObjects` exceeds `totalObjects`, or when either is zero or equal to `totalObjects`, in which case the coefficient is 1.

#### Code:
```
    public static int binomialCoefficient(int totalObjects, int numberOfObjects) {
        // Base Case
        if (numberOfObjects > totalObjects) {
            return 0;
        }
        // Base Case
        if (numberOfObjects == 0 || numberOfObjects == totalObjects) {
            return 1;
        }
        // Recursive Call
        return (binomialCoefficient(totalObjects - 1, numberOfObjects - 1) + binomialCoefficient(totalObjects - 1, numberOfObjects));
    }
```
___
# public final class CatalanNumbers 
### private CatalanNumbers()

#### Description:
This function defines a private class `CatalanNumbers` without any internal methods or properties. It serves as an initializer for this class, meaning it's used to create instances of the class but does not perform any actions.

#### Code:
```
    private CatalanNumbers() {
    }
```
### public static long catalan(final int n)

#### Description:
This function calculates the nth Catalan number, which is a sequence of natural numbers that have various applications in combinatorics and algebra. It uses the formula C_n = (2n)! / ((n+1)! * n!) to compute the value for a given integer n. The function first checks if the input index is non-negative, throwing an IllegalArgumentException if it is not. Then, it calculates factorial of 2*n, 3rd argument of the `factorial` method below, divides it by the product of factorials of (n+1) and n to achieve the desired result.

#### Code:
```
    public static long catalan(final int n) {
        if (n < 0) {
            throw new IllegalArgumentException("Index must be non-negative");
        }
        return factorial(2 * n) / (factorial(n + 1) * factorial(n));
    }
```
### private static long factorial(final int n)

#### Description:
This function calculates the factorial of a given integer `n` using a simple iterative approach. It checks if `n` is 0 or 1, in which case it returns 1 as the factorial. For all other values of `n`, it initializes a variable `result` to 1 and multiplies it by each integer from 2 up to `n`. The result is then returned at the end.

#### Code:
```
    private static long factorial(final int n) {
        if (n == 0 || n == 1) {
            return 1;
        }
        long result = 1;
        for (int i = 2; i <= n; i++) {
            result *= i;
        }
        return result;
    }
```
___
