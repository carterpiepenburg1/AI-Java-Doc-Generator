[
  {
    "index": 701,
    "code": "public int[] getTopSentence(int size)\n    {\n        Collection<Integer> values = top.values();\n        size = Math.min(size, values.size());\n        int[] indexArray = new int[size];\n        Iterator<Integer> it = values.iterator();\n        for (int i = 0; i < size; ++i)\n        {\n            indexArray[i] = it.next();\n        }\n        return indexArray;\n    }",
    "reference_explanation": "\u83b7\u53d6\u524d\u51e0\u4e2a\u5173\u952e\u53e5\u5b50\n\n@param size \u8981\u51e0\u4e2a\n@return \u5173\u952e\u53e5\u5b50\u7684\u4e0b\u6807",
    "generated_explanation": ""
  },
  {
    "index": 702,
    "code": "static List<String> splitSentence(String document, String sentence_separator)\n    {\n        List<String> sentences = new ArrayList<String>();\n        for (String line : document.split(\"[\\r\\n]\"))\n        {\n            line = line.trim();\n            if (line.length() == 0) continue;\n            for (String sent : line.split(sentence_separator))\t\t// [\uff0c,\u3002:\uff1a\u201c\u201d\uff1f?\uff01!\uff1b;]\n            {\n                sent = sent.trim();\n                if (sent.length() == 0) continue;\n                sentences.add(sent);\n            }\n        }\n\n        return sentences;\n    }",
    "reference_explanation": "\u5c06\u6587\u7ae0\u5206\u5272\u4e3a\u53e5\u5b50\n\n@param document \u5f85\u5206\u5272\u7684\u6587\u6863\n@param sentence_separator \u53e5\u5b50\u5206\u9694\u7b26\uff0c\u6b63\u5219\u8868\u8fbe\u5f0f\uff0c\u5982\uff1a   [\u3002:\uff1f?\uff01!\uff1b;]\n@return",
    "generated_explanation": ""
  },
  {
    "index": 703,
    "code": "private static List<List<String>> convertSentenceListToDocument(List<String> sentenceList)\n    {\n        List<List<String>> docs = new ArrayList<List<String>>(sentenceList.size());\n        for (String sentence : sentenceList)\n        {\n            List<Term> termList = StandardTokenizer.segment(sentence.toCharArray());\n            List<String> wordList = new LinkedList<String>();\n            for (Term term : termList)\n            {\n                if (CoreStopWordDictionary.shouldInclude(term))\n                {\n                    wordList.add(term.word);\n                }\n            }\n            docs.add(wordList);\n        }\n        return docs;\n    }",
    "reference_explanation": "\u5c06\u53e5\u5b50\u5217\u8868\u8f6c\u5316\u4e3a\u6587\u6863\n\n@param sentenceList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 704,
    "code": "public static List<String> getTopSentenceList(String document, int size)\n    {\n    \treturn getTopSentenceList(document, size, default_sentence_separator);\n    }",
    "reference_explanation": "\u4e00\u53e5\u8bdd\u8c03\u7528\u63a5\u53e3\n\n@param document \u76ee\u6807\u6587\u6863\n@param size     \u9700\u8981\u7684\u5173\u952e\u53e5\u7684\u4e2a\u6570\n@return \u5173\u952e\u53e5\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 705,
    "code": "public static List<String> getTopSentenceList(String document, int size, String sentence_separator)\n    {\n        List<String> sentenceList = splitSentence(document, sentence_separator);\n        List<List<String>> docs = convertSentenceListToDocument(sentenceList);\n        TextRankSentence textRank = new TextRankSentence(docs);\n        int[] topSentence = textRank.getTopSentence(size);\n        List<String> resultList = new LinkedList<String>();\n        for (int i : topSentence)\n        {\n            resultList.add(sentenceList.get(i));\n        }\n        return resultList;\n    }",
    "reference_explanation": "\u4e00\u53e5\u8bdd\u8c03\u7528\u63a5\u53e3\n\n@param document \u76ee\u6807\u6587\u6863\n@param size     \u9700\u8981\u7684\u5173\u952e\u53e5\u7684\u4e2a\u6570\n@param sentence_separator \u53e5\u5b50\u5206\u9694\u7b26\uff0c\u6b63\u5219\u683c\u5f0f\uff0c \u5982\uff1a[\u3002\uff1f?\uff01!\uff1b;]\n@return \u5173\u952e\u53e5\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 706,
    "code": "public static String getSummary(String document, int max_length, String sentence_separator)\n    {\n        List<String> sentenceList = splitSentence(document, sentence_separator);\n\n        int sentence_count = sentenceList.size();\n        int document_length = document.length();\n        int sentence_length_avg = document_length / sentence_count;\n        int size = max_length / sentence_length_avg + 1;\n        List<List<String>> docs = convertSentenceListToDocument(sentenceList);\n        TextRankSentence textRank = new TextRankSentence(docs);\n        int[] topSentence = textRank.getTopSentence(size);\n        List<String> resultList = new LinkedList<String>();\n        for (int i : topSentence)\n        {\n            resultList.add(sentenceList.get(i));\n        }\n\n        resultList = permutation(resultList, sentenceList);\n        resultList = pick_sentences(resultList, max_length);\n        return TextUtility.join(\"\u3002\", resultList);\n    }",
    "reference_explanation": "\u4e00\u53e5\u8bdd\u8c03\u7528\u63a5\u53e3\n\n@param document   \u76ee\u6807\u6587\u6863\n@param max_length \u9700\u8981\u6458\u8981\u7684\u957f\u5ea6\n@param sentence_separator \u53e5\u5b50\u5206\u9694\u7b26\uff0c\u6b63\u5219\u683c\u5f0f\uff0c \u5982\uff1a[\u3002\uff1f?\uff01!\uff1b;]\n@return \u6458\u8981\u6587\u672c",
    "generated_explanation": ""
  },
  {
    "index": 707,
    "code": "public static ByteArray createByteArray(String path)\n    {\n        byte[] bytes = IOUtil.readBytes(path);\n        if (bytes == null) return null;\n        return new ByteArray(bytes);\n    }",
    "reference_explanation": "\u4ece\u6587\u4ef6\u8bfb\u53d6\u4e00\u4e2a\u5b57\u8282\u6570\u7ec4\n\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 708,
    "code": "public String nextString()\n    {\n        char[] buffer = new char[nextInt()];\n        for (int i = 0; i < buffer.length; ++i)\n        {\n            buffer[i] = nextChar();\n        }\n        return new String(buffer);\n    }",
    "reference_explanation": "\u8bfb\u53d6\u4e00\u4e2aString\uff0c\u6ce8\u610f\u8fd9\u4e2aString\u662f\u53cc\u5b57\u8282\u7248\u7684\uff0c\u5728\u5b57\u7b26\u4e4b\u524d\u6709\u4e00\u4e2a\u6574\u578b\u8868\u793a\u957f\u5ea6\n\n@return",
    "generated_explanation": ""
  },
  {
    "index": 709,
    "code": "public String nextUTF()\n    {\n        int utflen = nextUnsignedShort();\n        byte[] bytearr = null;\n        char[] chararr = null;\n        bytearr = new byte[utflen];\n        chararr = new char[utflen];\n\n        int c, char2, char3;\n        int count = 0;\n        int chararr_count = 0;\n\n        for (int i = 0; i < utflen; ++i)\n        {\n            bytearr[i] = nextByte();\n        }\n\n        while (count < utflen)\n        {\n            c = (int) bytearr[count] & 0xff;\n            if (c > 127) break;\n            count++;\n            chararr[chararr_count++] = (char) c;\n        }\n\n        while (count < utflen)\n        {\n            c = (int) bytearr[count] & 0xff;\n            switch (c >> 4)\n            {\n                case 0:\n                case 1:\n                case 2:\n                case 3:\n                case 4:\n                case 5:\n                case 6:\n                case 7:\n                    /* 0xxxxxxx*/\n                    count++;\n                    chararr[chararr_count++] = (char) c;\n                    break;\n                case 12:\n                case 13:\n                    /* 110x xxxx   10xx xxxx*/\n                    count += 2;\n                    if (count > utflen)\n                        logger.severe(\n                                \"malformed input: partial character at end\");\n                    char2 = (int) bytearr[count - 1];\n                    if ((char2 & 0xC0) != 0x80)\n                        logger.severe(\n                                \"malformed input around byte \" + count);\n                    chararr[chararr_count++] = (char) (((c & 0x1F) << 6) |\n                            (char2 & 0x3F));\n                    break;\n                case 14:\n                    /* 1110 xxxx  10xx xxxx  10xx xxxx */\n                    count += 3;\n                    if (count > utflen)\n                        logger.severe(\n                                \"malformed input: partial character at end\");\n                    char2 = (int) bytearr[count - 2];\n                    char3 = (int) bytearr[count - 1];\n                    if (((char2 & 0xC0) != 0x80) || ((char3 & 0xC0) != 0x80))\n                        logger.severe(\n                                \"malformed input around byte \" + (count - 1));\n                    chararr[chararr_count++] = (char) (((c & 0x0F) << 12) |\n                            ((char2 & 0x3F) << 6) |\n                            ((char3 & 0x3F) << 0));\n                    break;\n                default:\n                    /* 10xx xxxx,  1111 xxxx */\n                    logger.severe(\n                            \"malformed input around byte \" + count);\n            }\n        }\n        // The number of chars produced may be less than utflen\n        return new String(chararr, 0, chararr_count);\n    }",
    "reference_explanation": "\u8bfb\u53d6\u4e00\u4e2aUTF\u5b57\u7b26\u4e32\n@return",
    "generated_explanation": ""
  },
  {
    "index": 710,
    "code": "public static IndexMaps createIndices(String conllPath, boolean labeled, boolean lowercased, String clusterFile) throws IOException\n    {\n        HashMap<String, Integer> wordMap = new HashMap<String, Integer>();\n        HashMap<Integer, Integer> labels = new HashMap<Integer, Integer>();\n        HashMap<String, Integer> clusterMap = new HashMap<String, Integer>();\n        HashMap<Integer, Integer> cluster4Map = new HashMap<Integer, Integer>();\n        HashMap<Integer, Integer> cluster6Map = new HashMap<Integer, Integer>();\n\n        String rootString = \"ROOT\";\n\n        wordMap.put(\"ROOT\", 0);\n        labels.put(0, 0);\n\n        // \u6240\u6709label\u7684id\u5fc5\u987b\u4ece\u96f6\u5f00\u59cb\u5e76\u4e14\u8fde\u7eed\n        BufferedReader reader = new BufferedReader(new FileReader(conllPath));\n        String line;\n        while ((line = reader.readLine()) != null)\n        {\n            String[] args = line.trim().split(\"\\t\");\n            if (args.length > 7)\n            {\n                String label = args[7];\n                int head = Integer.parseInt(args[6]);\n                if (head == 0)\n                    rootString = label;\n\n                if (!labeled)\n                    label = \"~\";\n                else if (label.equals(\"_\"))\n                    label = \"-\";\n\n                if (!wordMap.containsKey(label))\n                {\n                    labels.put(wordMap.size(), labels.size());\n                    wordMap.put(label, wordMap.size());\n                }\n            }\n        }\n\n        reader = new BufferedReader(new FileReader(conllPath));\n        while ((line = reader.readLine()) != null)\n        {\n            String[] cells = line.trim().split(\"\\t\");\n            if (cells.length > 7)\n            {\n                String pos = cells[3];\n                if (!wordMap.containsKey(pos))\n                {\n                    wordMap.put(pos, wordMap.size());\n                }\n            }\n        }\n\n        if (clusterFile.length() > 0)\n        {\n            reader = new BufferedReader(new FileReader(clusterFile));\n            while ((line = reader.readLine()) != null)\n            {\n                String[] cells = line.trim().split(\"\\t\");\n                if (cells.length > 2)\n                {\n                    String cluster = cells[0];\n                    String word = cells[1];\n                    String prefix4 = cluster.substring(0, Math.min(4, cluster.length()));\n                    String prefix6 = cluster.substring(0, Math.min(6, cluster.length()));\n                    int clusterId = wordMap.size();\n\n                    if (!wordMap.containsKey(cluster))\n                    {\n                        clusterMap.put(word, wordMap.size());\n                        wordMap.put(cluster, wordMap.size());\n                    }\n                    else\n                    {\n                        clusterId = wordMap.get(cluster);\n                        clusterMap.put(word, clusterId);\n                    }\n\n                    int pref4Id = wordMap.size();\n                    if (!wordMap.containsKey(prefix4))\n                    {\n                        wordMap.put(prefix4, wordMap.size());\n                    }\n                    else\n                    {\n                        pref4Id = wordMap.get(prefix4);\n                    }\n\n                    int pref6Id = wordMap.size();\n                    if (!wordMap.containsKey(prefix6))\n                    {\n                        wordMap.put(prefix6, wordMap.size());\n                    }\n                    else\n                    {\n                        pref6Id = wordMap.get(prefix6);\n                    }\n\n                    cluster4Map.put(clusterId, pref4Id);\n                    cluster6Map.put(clusterId, pref6Id);\n                }\n            }\n        }\n\n        reader = new BufferedReader(new FileReader(conllPath));\n        while ((line = reader.readLine()) != null)\n        {\n            String[] cells = line.trim().split(\"\\t\");\n            if (cells.length > 7)\n            {\n                String word = cells[1];\n                if (lowercased)\n                    word = word.toLowerCase();\n                if (!wordMap.containsKey(word))\n                {\n                    wordMap.put(word, wordMap.size());\n                }\n            }\n        }\n\n        return new IndexMaps(wordMap, labels, rootString, cluster4Map, cluster6Map, clusterMap);\n    }",
    "reference_explanation": "\u8bfb\u53d6CoNLL\u6587\u4ef6\uff0c\u521b\u5efa\u7d22\u5f15\n\n@param conllPath\n@param labeled\n@param lowercased\n@param clusterFile\n@return\n@throws Exception",
    "generated_explanation": ""
  },
  {
    "index": 711,
    "code": "public ArrayList<Instance> readData(int limit, boolean keepNonProjective, boolean labeled, boolean rootFirst, boolean lowerCased, IndexMaps maps) throws IOException\n    {\n        HashMap<String, Integer> wordMap = maps.getWordId();\n        ArrayList<Instance> instanceList = new ArrayList<Instance>();\n\n        String line;\n        ArrayList<Integer> tokens = new ArrayList<Integer>();\n        ArrayList<Integer> tags = new ArrayList<Integer>();\n        ArrayList<Integer> cluster4Ids = new ArrayList<Integer>();\n        ArrayList<Integer> cluster6Ids = new ArrayList<Integer>();\n        ArrayList<Integer> clusterIds = new ArrayList<Integer>();\n\n        HashMap<Integer, Edge> goldDependencies = new HashMap<Integer, Edge>();\n        int sentenceCounter = 0;\n        while ((line = fileReader.readLine()) != null)\n        {\n            line = line.trim();\n            if (line.length() == 0) // \u53e5\u5b50\u5206\u9694\u7a7a\u767d\u884c\n            {\n                if (tokens.size() > 0)\n                {\n                    sentenceCounter++;\n                    if (!rootFirst)\n                    {\n                        for (Edge edge : goldDependencies.values())\n                        {\n                            if (edge.headIndex == 0)\n                                edge.headIndex = tokens.size() + 1;\n                        }\n                        tokens.add(0);\n                        tags.add(0);\n                        cluster4Ids.add(0);\n                        cluster6Ids.add(0);\n                        clusterIds.add(0);\n                    }\n                    Sentence currentSentence = new Sentence(tokens, tags, cluster4Ids, cluster6Ids, clusterIds);\n                    Instance instance = new Instance(currentSentence, goldDependencies);\n                    if (keepNonProjective || !instance.isNonprojective())\n                        instanceList.add(instance);\n                    goldDependencies = new HashMap<Integer, Edge>();\n                    tokens = new ArrayList<Integer>();\n                    tags = new ArrayList<Integer>();\n                    cluster4Ids = new ArrayList<Integer>();\n                    cluster6Ids = new ArrayList<Integer>();\n                    clusterIds = new ArrayList<Integer>();\n                }\n                else\n                {\n                    goldDependencies = new HashMap<Integer, Edge>();\n                    tokens = new ArrayList<Integer>();\n                    tags = new ArrayList<Integer>();\n                    cluster4Ids = new ArrayList<Integer>();\n                    cluster6Ids = new ArrayList<Integer>();\n                    clusterIds = new ArrayList<Integer>();\n                }\n                if (sentenceCounter >= limit)\n                {\n                    System.out.println(\"buffer full...\" + instanceList.size());\n                    break;\n                }\n            }\n            else\n            {\n                String[] cells = line.split(\"\\t\");\n                if (cells.length < 8)\n                    throw new IllegalArgumentException(\"invalid conll format\");\n                int wordIndex = Integer.parseInt(cells[0]);\n                String word = cells[1].trim();\n                if (lowerCased)\n                    word = word.toLowerCase();\n                String pos = cells[3].trim();\n\n                int wi = getId(word, wordMap);\n                int pi = getId(pos, wordMap);\n\n                tags.add(pi);\n                tokens.add(wi);\n\n                int headIndex = Integer.parseInt(cells[6]);\n                String relation = cells[7];\n                if (!labeled)\n                    relation = \"~\";\n                else if (relation.equals(\"_\"))\n                    relation = \"-\";\n\n                if (headIndex == 0)\n                    relation = \"ROOT\";\n\n                int ri = getId(relation, wordMap);\n                if (headIndex == -1)\n                    ri = -1;\n\n                int[] ids = maps.clusterId(word);\n                clusterIds.add(ids[0]);\n                cluster4Ids.add(ids[1]);\n                cluster6Ids.add(ids[2]);\n\n                if (headIndex >= 0)\n                    goldDependencies.put(wordIndex, new Edge(headIndex, ri));\n            }\n        }\n        if (tokens.size() > 0)\n        {\n            if (!rootFirst)\n            {\n                for (int gold : goldDependencies.keySet())\n                {\n                    if (goldDependencies.get(gold).headIndex == 0)\n                        goldDependencies.get(gold).headIndex = goldDependencies.size() + 1;\n                }\n                tokens.add(0);\n                tags.add(0);\n                cluster4Ids.add(0);\n                cluster6Ids.add(0);\n                clusterIds.add(0);\n            }\n            sentenceCounter++;\n            Sentence currentSentence = new Sentence(tokens, tags, cluster4Ids, cluster6Ids, clusterIds);\n            instanceList.add(new Instance(currentSentence, goldDependencies));\n        }\n\n        return instanceList;\n    }",
    "reference_explanation": "\u8bfb\u53d6\u53e5\u5b50\n\n@param limit             \u6700\u5927\u591a\u5c11\u53e5\n@param keepNonProjective \u4fdd\u7559\u975e\u6295\u5f71\n@param labeled\n@param rootFirst         \u662f\u5426\u628aroot\u653e\u5230\u6700\u524d\u9762\n@param lowerCased\n@param maps              feature id map\n@return\n@throws Exception",
    "generated_explanation": ""
  },
  {
    "index": 712,
    "code": "public void connect(int from, int to, double weight)\n    {\n        edgesTo[to].add(new EdgeFrom(from, weight, vertexes[from].word + '@' + vertexes[to].word));\n    }",
    "reference_explanation": "\u8fde\u63a5\u4e24\u4e2a\u8282\u70b9\n@param from \u8d77\u70b9\n@param to \u7ec8\u70b9\n@param weight \u82b1\u8d39",
    "generated_explanation": ""
  },
  {
    "index": 713,
    "code": "public List<Vertex> parsePath(int[] path)\n    {\n        List<Vertex> vertexList = new LinkedList<Vertex>();\n        for (int i : path)\n        {\n            vertexList.add(vertexes[i]);\n        }\n\n        return vertexList;\n    }",
    "reference_explanation": "\u6839\u636e\u8282\u70b9\u4e0b\u6807\u6570\u7ec4\u89e3\u91ca\u51fa\u5bf9\u5e94\u7684\u8def\u5f84\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 714,
    "code": "public static String parseResult(List<Vertex> path)\n    {\n        if (path.size() < 2)\n        {\n            throw new RuntimeException(\"\u8def\u5f84\u8282\u70b9\u6570\u5c0f\u4e8e2:\" + path);\n        }\n        StringBuffer sb = new StringBuffer();\n\n        for (int i = 1; i < path.size() - 1; ++i)\n        {\n            Vertex v = path.get(i);\n            sb.append(v.getRealWord() + \" \");\n        }\n\n        return sb.toString();\n    }",
    "reference_explanation": "\u4ece\u4e00\u4e2a\u8def\u5f84\u4e2d\u8f6c\u6362\u51fa\u7a7a\u683c\u9694\u5f00\u7684\u7ed3\u679c\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 715,
    "code": "public void learn(List<Sentence> sentenceList)\n    {\n        List<List<IWord>> s = new ArrayList<List<IWord>>(sentenceList.size());\n        for (Sentence sentence : sentenceList)\n        {\n            s.add(sentence.wordList);\n        }\n        compute(s);\n    }",
    "reference_explanation": "\u540ccompute\n@param sentenceList",
    "generated_explanation": ""
  },
  {
    "index": 716,
    "code": "public void train(String corpus)\n    {\n        CorpusLoader.walk(corpus, new CorpusLoader.Handler()\n        {\n            @Override\n            public void handle(Document document)\n            {\n                List<List<Word>> simpleSentenceList = document.getSimpleSentenceList();\n                List<List<IWord>> compatibleList = new LinkedList<List<IWord>>();\n                for (List<Word> wordList : simpleSentenceList)\n                {\n                    compatibleList.add(new LinkedList<IWord>(wordList));\n                }\n                CommonDictionaryMaker.this.compute(compatibleList);\n            }\n        });\n    }",
    "reference_explanation": "\u8bad\u7ec3\n@param corpus \u8bed\u6599\u5e93\u8def\u5f84",
    "generated_explanation": ""
  },
  {
    "index": 717,
    "code": "void set(int id, boolean bit)\n    {\n        if (bit)\n        {\n            _units.set(id / UNIT_SIZE, _units.get(id / UNIT_SIZE)\n                    | 1 << (id % UNIT_SIZE));\n        }\n    }",
    "reference_explanation": "\u8bbe\u7f6e\u67d0\u4e00\u4f4d\u7684\u6bd4\u7279\n@param id \u4f4d\n@param bit \u6bd4\u7279",
    "generated_explanation": ""
  },
  {
    "index": 718,
    "code": "void build()\n    {\n        _ranks = new int[_units.size()];\n\n        _numOnes = 0;\n        for (int i = 0; i < _units.size(); ++i)\n        {\n            _ranks[i] = _numOnes;\n            _numOnes += popCount(_units.get(i));\n        }\n    }",
    "reference_explanation": "\u6784\u5efa",
    "generated_explanation": ""
  },
  {
    "index": 719,
    "code": "private static int popCount(int unit)\n    {\n        unit = ((unit & 0xAAAAAAAA) >>> 1) + (unit & 0x55555555);\n        unit = ((unit & 0xCCCCCCCC) >>> 2) + (unit & 0x33333333);\n        unit = ((unit >>> 4) + unit) & 0x0F0F0F0F;\n        unit += unit >>> 8;\n        unit += unit >>> 16;\n        return unit & 0xFF;\n    }",
    "reference_explanation": "1\u7684\u6570\u91cf\n@param unit\n@return",
    "generated_explanation": ""
  },
  {
    "index": 720,
    "code": "public Sentence makeSentence(String[] words, String[] posTags, boolean rootFirst, boolean lowerCased)\n    {\n        ArrayList<Integer> tokens = new ArrayList<Integer>();\n        ArrayList<Integer> tags = new ArrayList<Integer>();\n        ArrayList<Integer> bc4 = new ArrayList<Integer>();\n        ArrayList<Integer> bc6 = new ArrayList<Integer>();\n        ArrayList<Integer> bcf = new ArrayList<Integer>();\n\n        int i = 0;\n        for (String word : words)\n        {\n            if (word.length() == 0)\n                continue;\n            String lowerCaseWord = word.toLowerCase();\n            if (lowerCased)\n                word = lowerCaseWord;\n\n            int[] clusterIDs = clusterId(word);\n            bcf.add(clusterIDs[0]);\n            bc4.add(clusterIDs[1]);\n            bc6.add(clusterIDs[2]);\n\n            String pos = posTags[i];\n\n            int wi = -1;\n            if (wordId.containsKey(word))\n                wi = wordId.get(word);\n\n            int pi = -1;\n            if (wordId.containsKey(pos))\n                pi = wordId.get(pos);\n\n            tokens.add(wi);\n            tags.add(pi);\n\n            i++;\n        }\n\n        if (!rootFirst)\n        {\n            tokens.add(0);\n            tags.add(0);\n            bcf.add(0);\n            bc6.add(0);\n            bc4.add(0);\n        }\n\n        return new Sentence(tokens, tags, bc4, bc6, bcf);\n    }",
    "reference_explanation": "\u5c06\u53e5\u5b50\u4e2d\u7684\u5b57\u7b26\u4e32\u8f6c\u6362\u4e3aid\n\n@param words\n@param posTags\n@param rootFirst\n@param lowerCased\n@return",
    "generated_explanation": ""
  },
  {
    "index": 721,
    "code": "public int[] clusterId(String word)\n    {\n        int[] ids = new int[3];\n        ids[0] = -100;\n        ids[1] = -100;\n        ids[2] = -100;\n        if (brownFullClusters.containsKey(word))\n            ids[0] = brownFullClusters.get(word);\n\n        if (ids[0] > 0)\n        {\n            ids[1] = brown4Clusters.get(ids[0]);\n            ids[2] = brown6Clusters.get(ids[0]);\n        }\n        return ids;\n    }",
    "reference_explanation": "\u83b7\u53d6\u805a\u7c7bid\n\n@param word\n@return",
    "generated_explanation": ""
  },
  {
    "index": 722,
    "code": "protected void segment(final String sentence, final String normalized, final List<String> wordList, final List<CoreDictionary.Attribute> attributeList)\n    {\n        if (attributeList != null)\n        {\n            final int[] offset = new int[]{0};\n            CustomDictionary.parseLongestText(sentence, new AhoCorasickDoubleArrayTrie.IHit<CoreDictionary.Attribute>()\n            {\n                @Override\n                public void hit(int begin, int end, CoreDictionary.Attribute value)\n                {\n                    if (begin != offset[0])\n                    {\n                        segmentAfterRule(sentence.substring(offset[0], begin), normalized.substring(offset[0], begin), wordList);\n                    }\n                    while (attributeList.size() < wordList.size())\n                        attributeList.add(null);\n                    wordList.add(sentence.substring(begin, end));\n                    attributeList.add(value);\n                    assert wordList.size() == attributeList.size() : \"\u8bcd\u8bed\u5217\u8868\u4e0e\u5c5e\u6027\u5217\u8868\u4e0d\u7b49\u957f\";\n                    offset[0] = end;\n                }\n            });\n            if (offset[0] != sentence.length())\n            {\n                segmentAfterRule(sentence.substring(offset[0]), normalized.substring(offset[0]), wordList);\n            }\n        }\n        else\n        {\n            segmentAfterRule(sentence, normalized, wordList);\n        }\n    }",
    "reference_explanation": "\u5206\u8bcd\n\n@param sentence      \u6587\u672c\n@param normalized    \u6b63\u89c4\u5316\u540e\u7684\u6587\u672c\n@param wordList      \u50a8\u5b58\u5355\u8bcd\u5217\u8868\n@param attributeList \u50a8\u5b58\u7528\u6237\u8bcd\u5178\u4e2d\u7684\u8bcd\u6027\uff0c\u8bbe\u4e3anull\u8868\u793a\u4e0d\u67e5\u8be2\u7528\u6237\u8bcd\u5178",
    "generated_explanation": ""
  },
  {
    "index": 723,
    "code": "public List<String> segment(String sentence)\n    {\n        return segment(sentence, CharTable.convert(sentence));\n    }",
    "reference_explanation": "\u4e2d\u6587\u5206\u8bcd\n\n@param sentence\n@return",
    "generated_explanation": ""
  },
  {
    "index": 724,
    "code": "public List<String> segment(final String sentence, final String normalized)\n    {\n        final List<String> wordList = new LinkedList<String>();\n        segment(sentence, normalized, wordList);\n        return wordList;\n    }",
    "reference_explanation": "\u8fd9\u4e2a\u65b9\u6cd5\u4f1a\u67e5\u8be2\u7528\u6237\u8bcd\u5178\n\n@param sentence\n@param normalized\n@return",
    "generated_explanation": ""
  },
  {
    "index": 725,
    "code": "protected boolean acceptCustomWord(int begin, int end, CoreDictionary.Attribute value)\n    {\n        return config.forceCustomDictionary || (end - begin >= 4 && !value.hasNatureStartsWith(\"nr\") && !value.hasNatureStartsWith(\"ns\") && !value.hasNatureStartsWith(\"nt\"));\n    }",
    "reference_explanation": "\u5206\u8bcd\u65f6\u67e5\u8be2\u5230\u4e00\u4e2a\u7528\u6237\u8bcd\u5178\u4e2d\u7684\u8bcd\u8bed\uff0c\u6b64\u5904\u63a7\u5236\u662f\u5426\u63a5\u53d7\u5b83\n\n@param begin \u8d77\u59cb\u4f4d\u7f6e\n@param end   \u7ec8\u6b62\u4f4d\u7f6e\n@param value \u8bcd\u6027\n@return true \u8868\u793a\u63a5\u53d7\n@deprecated \u81ea1.6.7\u8d77\u5e9f\u5f03\uff0c\u5f3a\u5236\u6a21\u5f0f\u4e0b\u4e3a\u6700\u957f\u5339\u914d\uff0c\u5426\u5219\u6309\u5206\u8bcd\u7ed3\u679c\u5408\u5e76",
    "generated_explanation": ""
  },
  {
    "index": 726,
    "code": "private void pushPiece(String sentence, String normalized, int start, int end, byte preType, List<String> wordList)\n    {\n        if (preType == CharType.CT_CHINESE)\n        {\n            segmenter.segment(sentence.substring(start, end), normalized.substring(start, end), wordList);\n        }\n        else\n        {\n            wordList.add(sentence.substring(start, end));\n        }\n    }",
    "reference_explanation": "CT_CHINESE\u533a\u95f4\u4ea4\u7ed9\u7edf\u8ba1\u5206\u8bcd\uff0c\u5426\u5219\u89c6\u4f5c\u6574\u4e2a\u5355\u4f4d\n\n@param sentence\n@param normalized\n@param start\n@param end\n@param preType\n@param wordList",
    "generated_explanation": ""
  },
  {
    "index": 727,
    "code": "protected void segmentAfterRule(String sentence, String normalized, List<String> wordList)\n    {\n        if (!enableRuleBasedSegment)\n        {\n            segmenter.segment(sentence, normalized, wordList);\n            return;\n        }\n        int start = 0;\n        int end = start;\n        byte preType = typeTable[normalized.charAt(end)];\n        byte curType;\n        while (++end < normalized.length())\n        {\n            curType = typeTable[normalized.charAt(end)];\n            if (curType != preType)\n            {\n                if (preType == CharType.CT_NUM)\n                {\n                    // \u6d6e\u70b9\u6570\u8bc6\u522b\n                    if (\"\uff0c,\uff0e.\".indexOf(normalized.charAt(end)) != -1)\n                    {\n                        if (end + 1 < normalized.length())\n                        {\n                            if (typeTable[normalized.charAt(end + 1)] == CharType.CT_NUM)\n                            {\n                                continue;\n                            }\n                        }\n                    }\n                    else if (\"\u5e74\u6708\u65e5\u65f6\u5206\u79d2\".indexOf(normalized.charAt(end)) != -1)\n                    {\n                        preType = curType; // \u4ea4\u7ed9\u7edf\u8ba1\u5206\u8bcd\n                        continue;\n                    }\n                }\n                pushPiece(sentence, normalized, start, end, preType, wordList);\n                start = end;\n            }\n            preType = curType;\n        }\n        if (end == normalized.length())\n            pushPiece(sentence, normalized, start, end, preType, wordList);\n    }",
    "reference_explanation": "\u4e11\u964b\u7684\u89c4\u5219\u7cfb\u7edf\n\n@param sentence\n@param normalized\n@param wordList",
    "generated_explanation": ""
  },
  {
    "index": 728,
    "code": "private List<CoreDictionary.Attribute> segmentWithAttribute(String original, String normalized, List<String> wordList)\n    {\n        List<CoreDictionary.Attribute> attributeList;\n        if (config.useCustomDictionary)\n        {\n            if (config.forceCustomDictionary)\n            {\n                attributeList = new LinkedList<CoreDictionary.Attribute>();\n                segment(original, normalized, wordList, attributeList);\n            }\n            else\n            {\n                segmentAfterRule(original, normalized, wordList);\n                attributeList = combineWithCustomDictionary(wordList);\n            }\n        }\n        else\n        {\n            segmentAfterRule(original, normalized, wordList);\n            attributeList = null;\n        }\n        return attributeList;\n    }",
    "reference_explanation": "\u8fd4\u56de\u7528\u6237\u8bcd\u5178\u4e2d\u7684attribute\u7684\u5206\u8bcd\n\n@param original\n@param normalized\n@param wordList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 729,
    "code": "protected static List<CoreDictionary.Attribute> combineWithCustomDictionary(List<String> vertexList)\n    {\n        String[] wordNet = new String[vertexList.size()];\n        vertexList.toArray(wordNet);\n        CoreDictionary.Attribute[] attributeArray = new CoreDictionary.Attribute[wordNet.length];\n        // DAT\u5408\u5e76\n        DoubleArrayTrie<CoreDictionary.Attribute> dat = CustomDictionary.dat;\n        int length = wordNet.length;\n        for (int i = 0; i < length; ++i)\n        {\n            int state = 1;\n            state = dat.transition(wordNet[i], state);\n            if (state > 0)\n            {\n                int to = i + 1;\n                int end = to;\n                CoreDictionary.Attribute value = dat.output(state);\n                for (; to < length; ++to)\n                {\n                    state = dat.transition(wordNet[to], state);\n                    if (state < 0) break;\n                    CoreDictionary.Attribute output = dat.output(state);\n                    if (output != null)\n                    {\n                        value = output;\n                        end = to + 1;\n                    }\n                }\n                if (value != null)\n                {\n                    combineWords(wordNet, i, end, attributeArray, value);\n                    i = end - 1;\n                }\n            }\n        }\n        // BinTrie\u5408\u5e76\n        if (CustomDictionary.trie != null)\n        {\n            for (int i = 0; i < length; ++i)\n            {\n                if (wordNet[i] == null) continue;\n                BaseNode<CoreDictionary.Attribute> state = CustomDictionary.trie.transition(wordNet[i], 0);\n                if (state != null)\n                {\n                    int to = i + 1;\n                    int end = to;\n                    CoreDictionary.Attribute value = state.getValue();\n                    for (; to < length; ++to)\n                    {\n                        if (wordNet[to] == null) continue;\n                        state = state.transition(wordNet[to], 0);\n                        if (state == null) break;\n                        if (state.getValue() != null)\n                        {\n                            value = state.getValue();\n                            end = to + 1;\n                        }\n                    }\n                    if (value != null)\n                    {\n                        combineWords(wordNet, i, end, attributeArray, value);\n                        i = end - 1;\n                    }\n                }\n            }\n        }\n        vertexList.clear();\n        List<CoreDictionary.Attribute> attributeList = new LinkedList<CoreDictionary.Attribute>();\n        for (int i = 0; i < wordNet.length; i++)\n        {\n            if (wordNet[i] != null)\n            {\n                vertexList.add(wordNet[i]);\n                attributeList.add(attributeArray[i]);\n            }\n        }\n        return attributeList;\n    }",
    "reference_explanation": "\u4f7f\u7528\u7528\u6237\u8bcd\u5178\u5408\u5e76\u7c97\u5206\u7ed3\u679c\n\n@param vertexList \u7c97\u5206\u7ed3\u679c\n@return \u5408\u5e76\u540e\u7684\u7ed3\u679c",
    "generated_explanation": ""
  },
  {
    "index": 730,
    "code": "private static void combineWords(String[] wordNet, int start, int end, CoreDictionary.Attribute[] attributeArray, CoreDictionary.Attribute value)\n    {\n        if (start + 1 != end)   // \u5c0f\u4f18\u5316\uff0c\u5982\u679c\u53ea\u6709\u4e00\u4e2a\u8bcd\uff0c\u90a3\u5c31\u4e0d\u9700\u8981\u5408\u5e76\uff0c\u76f4\u63a5\u5e94\u7528\u65b0\u5c5e\u6027\n        {\n            StringBuilder sbTerm = new StringBuilder();\n            for (int j = start; j < end; ++j)\n            {\n                if (wordNet[j] == null) continue;\n                sbTerm.append(wordNet[j]);\n                wordNet[j] = null;\n            }\n            wordNet[start] = sbTerm.toString();\n        }\n        attributeArray[start] = value;\n    }",
    "reference_explanation": "\u5c06\u8fde\u7eed\u7684\u8bcd\u8bed\u5408\u5e76\u4e3a\u4e00\u4e2a\n\n@param wordNet \u8bcd\u56fe\n@param start   \u8d77\u59cb\u4e0b\u6807\uff08\u5305\u542b\uff09\n@param end     \u7ed3\u675f\u4e0b\u6807\uff08\u4e0d\u5305\u542b\uff09\n@param value   \u65b0\u7684\u5c5e\u6027",
    "generated_explanation": ""
  },
  {
    "index": 731,
    "code": "public List<Hit<V>> parseText(String text)\n    {\n        int position = 1;\n        int currentState = 0;\n        List<Hit<V>> collectedEmits = new LinkedList<Hit<V>>();\n        for (int i = 0; i < text.length(); ++i)\n        {\n            currentState = getState(currentState, text.charAt(i));\n            storeEmits(position, currentState, collectedEmits);\n            ++position;\n        }\n\n        return collectedEmits;\n    }",
    "reference_explanation": "\u5339\u914d\u6bcd\u6587\u672c\n\n@param text \u4e00\u4e9b\u6587\u672c\n@return \u4e00\u4e2apair\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 732,
    "code": "public void parseText(String text, IHit<V> processor)\n    {\n        int position = 1;\n        int currentState = 0;\n        for (int i = 0; i < text.length(); ++i)\n        {\n            currentState = getState(currentState, text.charAt(i));\n            int[] hitArray = output[currentState];\n            if (hitArray != null)\n            {\n                for (int hit : hitArray)\n                {\n                    processor.hit(position - l[hit], position, v[hit]);\n                }\n            }\n            ++position;\n        }\n    }",
    "reference_explanation": "\u5904\u7406\u6587\u672c\n\n@param text      \u6587\u672c\n@param processor \u5904\u7406\u5668",
    "generated_explanation": ""
  },
  {
    "index": 733,
    "code": "public void parseText(char[] text, IHit<V> processor)\n    {\n        int position = 1;\n        int currentState = 0;\n        for (char c : text)\n        {\n            currentState = getState(currentState, c);\n            int[] hitArray = output[currentState];\n            if (hitArray != null)\n            {\n                for (int hit : hitArray)\n                {\n                    processor.hit(position - l[hit], position, v[hit]);\n                }\n            }\n            ++position;\n        }\n    }",
    "reference_explanation": "\u5904\u7406\u6587\u672c\n\n@param text\n@param processor",
    "generated_explanation": ""
  },
  {
    "index": 734,
    "code": "public void save(DataOutputStream out) throws Exception\n    {\n        out.writeInt(size);\n        for (int i = 0; i < size; i++)\n        {\n            out.writeInt(base[i]);\n            out.writeInt(check[i]);\n            out.writeInt(fail[i]);\n            int output[] = this.output[i];\n            if (output == null)\n            {\n                out.writeInt(0);\n            }\n            else\n            {\n                out.writeInt(output.length);\n                for (int o : output)\n                {\n                    out.writeInt(o);\n                }\n            }\n        }\n        out.writeInt(l.length);\n        for (int length : l)\n        {\n            out.writeInt(length);\n        }\n    }",
    "reference_explanation": "\u6301\u4e45\u5316\n\n@param out \u4e00\u4e2aDataOutputStream\n@throws Exception \u53ef\u80fd\u7684IO\u5f02\u5e38\u7b49",
    "generated_explanation": ""
  },
  {
    "index": 735,
    "code": "public void save(ObjectOutputStream out) throws IOException\n    {\n        out.writeObject(base);\n        out.writeObject(check);\n        out.writeObject(fail);\n        out.writeObject(output);\n        out.writeObject(l);\n    }",
    "reference_explanation": "\u6301\u4e45\u5316\n\n@param out \u4e00\u4e2aObjectOutputStream\n@throws IOException \u53ef\u80fd\u7684IO\u5f02\u5e38",
    "generated_explanation": ""
  },
  {
    "index": 736,
    "code": "public void load(ObjectInputStream in, V[] value) throws IOException, ClassNotFoundException\n    {\n        base = (int[]) in.readObject();\n        check = (int[]) in.readObject();\n        fail = (int[]) in.readObject();\n        output = (int[][]) in.readObject();\n        l = (int[]) in.readObject();\n        v = value;\n    }",
    "reference_explanation": "\u8f7d\u5165\n\n@param in    \u4e00\u4e2aObjectInputStream\n@param value \u503c\uff08\u6301\u4e45\u5316\u7684\u65f6\u5019\u5e76\u6ca1\u6709\u6301\u4e45\u5316\u503c\uff0c\u73b0\u5728\u9700\u8981\u989d\u5916\u63d0\u4f9b\uff09\n@throws IOException\n@throws ClassNotFoundException",
    "generated_explanation": ""
  },
  {
    "index": 737,
    "code": "public boolean load(ByteArray byteArray, V[] value)\n    {\n        if (byteArray == null) return false;\n        size = byteArray.nextInt();\n        base = new int[size + 65535];   // \u591a\u7559\u4e00\u4e9b\uff0c\u9632\u6b62\u8d8a\u754c\n        check = new int[size + 65535];\n        fail = new int[size + 65535];\n        output = new int[size + 65535][];\n        int length;\n        for (int i = 0; i < size; ++i)\n        {\n            base[i] = byteArray.nextInt();\n            check[i] = byteArray.nextInt();\n            fail[i] = byteArray.nextInt();\n            length = byteArray.nextInt();\n            if (length == 0) continue;\n            output[i] = new int[length];\n            for (int j = 0; j < output[i].length; ++j)\n            {\n                output[i][j] = byteArray.nextInt();\n            }\n        }\n        length = byteArray.nextInt();\n        l = new int[length];\n        for (int i = 0; i < l.length; ++i)\n        {\n            l[i] = byteArray.nextInt();\n        }\n        v = value;\n        return true;\n    }",
    "reference_explanation": "\u8f7d\u5165\n\n@param byteArray \u4e00\u4e2a\u5b57\u8282\u6570\u7ec4\n@param value     \u503c\u6570\u7ec4\n@return \u6210\u529f\u4e0e\u5426",
    "generated_explanation": ""
  },
  {
    "index": 738,
    "code": "public V get(String key)\n    {\n        int index = exactMatchSearch(key);\n        if (index >= 0)\n        {\n            return v[index];\n        }\n\n        return null;\n    }",
    "reference_explanation": "\u83b7\u53d6\u503c\n\n@param key \u952e\n@return",
    "generated_explanation": ""
  },
  {
    "index": 739,
    "code": "private int getState(int currentState, char character)\n    {\n        int newCurrentState = transitionWithRoot(currentState, character);  // \u5148\u6309success\u8df3\u8f6c\n        while (newCurrentState == -1) // \u8df3\u8f6c\u5931\u8d25\u7684\u8bdd\uff0c\u6309failure\u8df3\u8f6c\n        {\n            currentState = fail[currentState];\n            newCurrentState = transitionWithRoot(currentState, character);\n        }\n        return newCurrentState;\n    }",
    "reference_explanation": "\u8f6c\u79fb\u72b6\u6001\uff0c\u652f\u6301failure\u8f6c\u79fb\n\n@param currentState\n@param character\n@return",
    "generated_explanation": ""
  },
  {
    "index": 740,
    "code": "private void storeEmits(int position, int currentState, List<Hit<V>> collectedEmits)\n    {\n        int[] hitArray = output[currentState];\n        if (hitArray != null)\n        {\n            for (int hit : hitArray)\n            {\n                collectedEmits.add(new Hit<V>(position - l[hit], position, v[hit]));\n            }\n        }\n    }",
    "reference_explanation": "\u4fdd\u5b58\u8f93\u51fa\n\n@param position\n@param currentState\n@param collectedEmits",
    "generated_explanation": ""
  },
  {
    "index": 741,
    "code": "protected int transition(int current, char c)\n    {\n        int b = current;\n        int p;\n\n        p = b + c + 1;\n        if (b == check[p])\n            b = base[p];\n        else\n            return -1;\n\n        p = b;\n        return p;\n    }",
    "reference_explanation": "\u8f6c\u79fb\u72b6\u6001\n\n@param current\n@param c\n@return",
    "generated_explanation": ""
  },
  {
    "index": 742,
    "code": "protected int transitionWithRoot(int nodePos, char c)\n    {\n        int b = base[nodePos];\n        int p;\n\n        p = b + c + 1;\n        if (b != check[p])\n        {\n            if (nodePos == 0) return 0;\n            return -1;\n        }\n\n        return p;\n    }",
    "reference_explanation": "c\u8f6c\u79fb\uff0c\u5982\u679c\u662f\u6839\u8282\u70b9\u5219\u8fd4\u56de\u81ea\u5df1\n\n@param nodePos\n@param c\n@return",
    "generated_explanation": ""
  },
  {
    "index": 743,
    "code": "private int fetch(State parent, List<Map.Entry<Integer, State>> siblings)\n    {\n        if (parent.isAcceptable())\n        {\n            State fakeNode = new State(-(parent.getDepth() + 1));  // \u6b64\u8282\u70b9\u662fparent\u7684\u5b50\u8282\u70b9\uff0c\u540c\u65f6\u5177\u5907parent\u7684\u8f93\u51fa\n            fakeNode.addEmit(parent.getLargestValueId());\n            siblings.add(new AbstractMap.SimpleEntry<Integer, State>(0, fakeNode));\n        }\n        for (Map.Entry<Character, State> entry : parent.getSuccess().entrySet())\n        {\n            siblings.add(new AbstractMap.SimpleEntry<Integer, State>(entry.getKey() + 1, entry.getValue()));\n        }\n        return siblings.size();\n    }",
    "reference_explanation": "\u83b7\u53d6\u76f4\u63a5\u76f8\u8fde\u7684\u5b50\u8282\u70b9\n\n@param parent   \u7236\u8282\u70b9\n@param siblings \uff08\u5b50\uff09\u5144\u5f1f\u8282\u70b9\n@return \u5144\u5f1f\u8282\u70b9\u4e2a\u6570",
    "generated_explanation": ""
  },
  {
    "index": 744,
    "code": "public Collection<Token> tokenize(String text)\n    {\n\n        Collection<Token> tokens = new ArrayList<Token>();\n\n        Collection<Emit> collectedEmits = parseText(text);\n        // \u4e0b\u9762\u662f\u6700\u957f\u5206\u8bcd\u7684\u5173\u952e\n        IntervalTree intervalTree = new IntervalTree((List<Intervalable>) (List<?>) collectedEmits);\n        intervalTree.removeOverlaps((List<Intervalable>) (List<?>) collectedEmits);\n        // \u79fb\u9664\u7ed3\u675f\n\n        int lastCollectedPosition = -1;\n        for (Emit emit : collectedEmits)\n        {\n            if (emit.getStart() - lastCollectedPosition > 1)\n            {\n                tokens.add(createFragment(emit, text, lastCollectedPosition));\n            }\n            tokens.add(createMatch(emit, text));\n            lastCollectedPosition = emit.getEnd();\n        }\n        if (text.length() - lastCollectedPosition > 1)\n        {\n            tokens.add(createFragment(null, text, lastCollectedPosition));\n        }\n\n        return tokens;\n    }",
    "reference_explanation": "\u4e00\u4e2a\u6700\u957f\u5206\u8bcd\u5668\n\n@param text \u5f85\u5206\u8bcd\u6587\u672c\n@return",
    "generated_explanation": ""
  },
  {
    "index": 745,
    "code": "@SuppressWarnings(\"unchecked\")\n    public Collection<Emit> parseText(String text)\n    {\n        checkForConstructedFailureStates();\n\n        int position = 0;\n        State currentState = this.rootState;\n        List<Emit> collectedEmits = new ArrayList<Emit>();\n        for (int i = 0; i < text.length(); ++i)\n        {\n            currentState = getState(currentState, text.charAt(i));\n            storeEmits(position, currentState, collectedEmits);\n            ++position;\n        }\n\n        if (!trieConfig.isAllowOverlaps())\n        {\n            IntervalTree intervalTree = new IntervalTree((List<Intervalable>) (List<?>) collectedEmits);\n            intervalTree.removeOverlaps((List<Intervalable>) (List<?>) collectedEmits);\n        }\n\n        if (trieConfig.remainLongest)\n        {\n            remainLongest(collectedEmits);\n        }\n\n        return collectedEmits;\n    }",
    "reference_explanation": "\u6a21\u5f0f\u5339\u914d\n\n@param text \u5f85\u5339\u914d\u7684\u6587\u672c\n@return \u5339\u914d\u5230\u7684\u6a21\u5f0f\u4e32",
    "generated_explanation": ""
  },
  {
    "index": 746,
    "code": "private static void remainLongest(Collection<Emit> collectedEmits)\n    {\n        if (collectedEmits.size() < 2) return;\n        Map<Integer, Emit> emitMapStart = new TreeMap<Integer, Emit>();\n        for (Emit emit : collectedEmits)\n        {\n            Emit pre = emitMapStart.get(emit.getStart());\n            if (pre == null || pre.size() < emit.size())\n            {\n                emitMapStart.put(emit.getStart(), emit);\n            }\n        }\n        if (emitMapStart.size() < 2)\n        {\n            collectedEmits.clear();\n            collectedEmits.addAll(emitMapStart.values());\n            return;\n        }\n        Map<Integer, Emit> emitMapEnd = new TreeMap<Integer, Emit>();\n        for (Emit emit : emitMapStart.values())\n        {\n            Emit pre = emitMapEnd.get(emit.getEnd());\n            if (pre == null || pre.size() < emit.size())\n            {\n                emitMapEnd.put(emit.getEnd(), emit);\n            }\n        }\n\n        collectedEmits.clear();\n        collectedEmits.addAll(emitMapEnd.values());\n    }",
    "reference_explanation": "\u53ea\u4fdd\u7559\u6700\u957f\u8bcd\n@param collectedEmits",
    "generated_explanation": ""
  },
  {
    "index": 747,
    "code": "private static State getState(State currentState, Character character)\n    {\n        State newCurrentState = currentState.nextState(character);  // \u5148\u6309success\u8df3\u8f6c\n        while (newCurrentState == null) // \u8df3\u8f6c\u5931\u8d25\u7684\u8bdd\uff0c\u6309failure\u8df3\u8f6c\n        {\n            currentState = currentState.failure();\n            newCurrentState = currentState.nextState(character);\n        }\n        return newCurrentState;\n    }",
    "reference_explanation": "\u8df3\u8f6c\u5230\u4e0b\u4e00\u4e2a\u72b6\u6001\n\n@param currentState \u5f53\u524d\u72b6\u6001\n@param character    \u63a5\u53d7\u5b57\u7b26\n@return \u8df3\u8f6c\u7ed3\u679c",
    "generated_explanation": ""
  },
  {
    "index": 748,
    "code": "private void constructFailureStates()\n    {\n        Queue<State> queue = new LinkedBlockingDeque<State>();\n\n        // \u7b2c\u4e00\u6b65\uff0c\u5c06\u6df1\u5ea6\u4e3a1\u7684\u8282\u70b9\u7684failure\u8bbe\u4e3a\u6839\u8282\u70b9\n        for (State depthOneState : this.rootState.getStates())\n        {\n            depthOneState.setFailure(this.rootState);\n            queue.add(depthOneState);\n        }\n        this.failureStatesConstructed = true;\n\n        // \u7b2c\u4e8c\u6b65\uff0c\u4e3a\u6df1\u5ea6 > 1 \u7684\u8282\u70b9\u5efa\u7acbfailure\u8868\uff0c\u8fd9\u662f\u4e00\u4e2abfs\n        while (!queue.isEmpty())\n        {\n            State currentState = queue.remove();\n\n            for (Character transition : currentState.getTransitions())\n            {\n                State targetState = currentState.nextState(transition);\n                queue.add(targetState);\n\n                State traceFailureState = currentState.failure();\n                while (traceFailureState.nextState(transition) == null)\n                {\n                    traceFailureState = traceFailureState.failure();\n                }\n                State newFailureState = traceFailureState.nextState(transition);\n                targetState.setFailure(newFailureState);\n                targetState.addEmit(newFailureState.emit());\n            }\n        }\n    }",
    "reference_explanation": "\u5efa\u7acbfailure\u8868",
    "generated_explanation": ""
  },
  {
    "index": 749,
    "code": "private static void storeEmits(int position, State currentState, List<Emit> collectedEmits)\n    {\n        Collection<String> emits = currentState.emit();\n        if (emits != null && !emits.isEmpty())\n        {\n            for (String emit : emits)\n            {\n                collectedEmits.add(new Emit(position - emit.length() + 1, position, emit));\n            }\n        }\n    }",
    "reference_explanation": "\u4fdd\u5b58\u5339\u914d\u7ed3\u679c\n\n@param position       \u5f53\u524d\u4f4d\u7f6e\uff0c\u4e5f\u5c31\u662f\u5339\u914d\u5230\u7684\u6a21\u5f0f\u4e32\u7684\u7ed3\u675f\u4f4d\u7f6e+1\n@param currentState   \u5f53\u524d\u72b6\u6001\n@param collectedEmits \u4fdd\u5b58\u4f4d\u7f6e",
    "generated_explanation": ""
  },
  {
    "index": 750,
    "code": "public boolean hasKeyword(String text)\n    {\n        checkForConstructedFailureStates();\n\n        State currentState = this.rootState;\n        for (int i = 0; i < text.length(); ++i)\n        {\n        \tState nextState = getState(currentState, text.charAt(i));\n            if (nextState != null && nextState != currentState && nextState.emit().size() != 0) {\n                return true;\n            }\n            currentState = nextState;\n        }\n        return false;\n    }",
    "reference_explanation": "\u6587\u672c\u662f\u5426\u5305\u542b\u4efb\u4f55\u6a21\u5f0f\n\n@param text \u5f85\u5339\u914d\u7684\u6587\u672c\n@return \u6587\u672c\u5305\u542b\u6a21\u5f0f\u6642\u56de\u50b3true",
    "generated_explanation": ""
  },
  {
    "index": 751,
    "code": "static boolean load(Map<String, String> storage, boolean reverse, String... pathArray)\n    {\n        StringDictionary dictionary = new StringDictionary(\"=\");\n        for (String path : pathArray)\n        {\n            if (!dictionary.load(path)) return false;\n        }\n        if (reverse) dictionary = dictionary.reverse();\n        Set<Map.Entry<String, String>> entrySet = dictionary.entrySet();\n        for (Map.Entry<String, String> entry : entrySet)\n        {\n            storage.put(entry.getKey(), entry.getValue());\n        }\n\n        return true;\n    }",
    "reference_explanation": "\u8bfb\u53d6\u8bcd\u5178\n@param storage \u50a8\u5b58\u7a7a\u95f4\n@param reverse \u662f\u5426\u7ffb\u8f6c\u952e\u503c\u5bf9\n@param pathArray \u8def\u5f84\n@return \u662f\u5426\u52a0\u8f7d\u6210\u529f",
    "generated_explanation": ""
  },
  {
    "index": 752,
    "code": "static boolean load(String path, AhoCorasickDoubleArrayTrie<String> trie)\n    {\n        return load(path, trie, false);\n    }",
    "reference_explanation": "\u5c06path\u7684\u5185\u5bb9\u8f7d\u5165trie\u4e2d\n@param path\n@param trie\n@return",
    "generated_explanation": ""
  },
  {
    "index": 753,
    "code": "static boolean load(String path, AhoCorasickDoubleArrayTrie<String> trie, boolean reverse)\n    {\n        String datPath = path;\n        if (reverse)\n        {\n            datPath += Predefine.REVERSE_EXT;\n        }\n        if (loadDat(datPath, trie)) return true;\n        // \u4ece\u6587\u672c\u4e2d\u8f7d\u5165\u5e76\u4e14\u5c1d\u8bd5\u751f\u6210dat\n        TreeMap<String, String> map = new TreeMap<String, String>();\n        if (!load(map, reverse, path)) return false;\n        logger.info(\"\u6b63\u5728\u6784\u5efaAhoCorasickDoubleArrayTrie\uff0c\u6765\u6e90\uff1a\" + path);\n        trie.build(map);\n        logger.info(\"\u6b63\u5728\u7f13\u5b58\u53cc\u6570\u7ec4\" + datPath);\n        saveDat(datPath, trie, map.entrySet());\n        return true;\n    }",
    "reference_explanation": "\u8bfb\u53d6\u8bcd\u5178\n@param path\n@param trie\n@param reverse \u662f\u5426\u5c06\u5176\u7ffb\u8f6c\n@return",
    "generated_explanation": ""
  },
  {
    "index": 754,
    "code": "private static TreeMap<Double ,Set<String>> sortScoreMap(TreeMap<String, Double> scoreMap)\n    {\n        TreeMap<Double, Set<String>> result = new TreeMap<Double, Set<String>>(Collections.reverseOrder());\n        for (Map.Entry<String, Double> entry : scoreMap.entrySet())\n        {\n            Set<String> sentenceSet = result.get(entry.getValue());\n            if (sentenceSet == null)\n            {\n                sentenceSet = new HashSet<String>();\n                result.put(entry.getValue(), sentenceSet);\n            }\n            sentenceSet.add(entry.getKey());\n        }\n\n        return result;\n    }",
    "reference_explanation": "\u5c06\u5206\u6570map\u6392\u5e8f\u6298\u53e0\n@param scoreMap\n@return",
    "generated_explanation": ""
  },
  {
    "index": 755,
    "code": "private static Double max(Map<String, Double> map)\n    {\n        Double theMax = 0.0;\n        for (Double v : map.values())\n        {\n            theMax = Math.max(theMax, v);\n        }\n\n        return theMax;\n    }",
    "reference_explanation": "\u4ecemap\u7684\u503c\u4e2d\u627e\u51fa\u6700\u5927\u503c\uff0c\u8fd9\u4e2a\u503c\u662f\u4ece0\u5f00\u59cb\u7684\n@param map\n@return",
    "generated_explanation": ""
  },
  {
    "index": 756,
    "code": "public int size()\n    {\n        int length = 0;\n        for (Pinyin pinyin : pinyinArray)\n        {\n            if (pinyin != Pinyin.none5) ++length;\n        }\n\n        return length;\n    }",
    "reference_explanation": "\u62fc\u97f3\u7684\u4e2a\u6570\n@return",
    "generated_explanation": ""
  },
  {
    "index": 757,
    "code": "protected int addWordToVocab(String word)\n    {\n        vocab[vocabSize] = new VocabWord(word);\n        vocabSize++;\n\n        // Reallocate memory if needed\n        if (vocabSize + 2 >= vocabMaxSize)\n        {\n            vocabMaxSize += 1000;\n            VocabWord[] temp = new VocabWord[vocabMaxSize];\n            System.arraycopy(vocab, 0, temp, 0, vocabSize);\n            vocab = temp;\n        }\n        vocabIndexMap.put(word, vocabSize - 1);\n        return vocabSize - 1;\n    }",
    "reference_explanation": "Adds a word to the vocabulary\n\n@param word\n@return",
    "generated_explanation": ""
  },
  {
    "index": 758,
    "code": "int searchVocab(String word)\n    {\n        if (word == null) return -1;\n        Integer pos = vocabIndexMap.get(word);\n        return pos == null ? -1 : pos.intValue();\n    }",
    "reference_explanation": "Returns position of a word in the vocabulary; if the word is not found, returns -1\n\n@param word\n@return",
    "generated_explanation": ""
  },
  {
    "index": 759,
    "code": "void sortVocab()\n    {\n        Arrays.sort(vocab, 0, vocabSize);\n\n        // re-build vocabIndexMap\n        final int size = vocabSize;\n        trainWords = 0;\n        table = new int[size];\n        for (int i = 0; i < size; i++)\n        {\n            VocabWord word = vocab[i];\n            // Words occuring less than min_count times will be discarded from the vocab\n            if (word.cn < config.getMinCount())\n            {\n                table[vocabIndexMap.get(word.word)] = -4;\n                vocabSize--;\n            }\n            else\n            {\n                // Hash will be re-computed, as after the sorting it is not actual\n                table[vocabIndexMap.get(word.word)] = i;\n                setVocabIndexMap(word, i);\n            }\n        }\n        // lose weight\n        vocabIndexMap = null;\n\n        VocabWord[] nvocab = new VocabWord[vocabSize];\n        System.arraycopy(vocab, 0, nvocab, 0, vocabSize);\n\n    }",
    "reference_explanation": "Sorts the vocabulary by frequency using word counts",
    "generated_explanation": ""
  },
  {
    "index": 760,
    "code": "void createBinaryTree()\n    {\n        int[] point = new int[VocabWord.MAX_CODE_LENGTH];\n        char[] code = new char[VocabWord.MAX_CODE_LENGTH];\n        int[] count = new int[vocabSize * 2 + 1];\n        char[] binary = new char[vocabSize * 2 + 1];\n        int[] parentNode = new int[vocabSize * 2 + 1];\n\n        for (int i = 0; i < vocabSize; i++)\n            count[i] = vocab[i].cn;\n        for (int i = vocabSize; i < vocabSize * 2; i++)\n            count[i] = Integer.MAX_VALUE;\n        int pos1 = vocabSize - 1;\n        int pos2 = vocabSize;\n        // Following algorithm constructs the Huffman tree by adding one node at a time\n        int min1i, min2i;\n        for (int i = 0; i < vocabSize - 1; i++)\n        {\n            // First, find two smallest nodes 'min1, min2'\n            if (pos1 >= 0)\n            {\n                if (count[pos1] < count[pos2])\n                {\n                    min1i = pos1;\n                    pos1--;\n                }\n                else\n                {\n                    min1i = pos2;\n                    pos2++;\n                }\n            }\n            else\n            {\n                min1i = pos2;\n                pos2++;\n            }\n            if (pos1 >= 0)\n            {\n                if (count[pos1] < count[pos2])\n                {\n                    min2i = pos1;\n                    pos1--;\n                }\n                else\n                {\n                    min2i = pos2;\n                    pos2++;\n                }\n            }\n            else\n            {\n                min2i = pos2;\n                pos2++;\n            }\n            count[vocabSize + i] = count[min1i] + count[min2i];\n            parentNode[min1i] = vocabSize + i;\n            parentNode[min2i] = vocabSize + i;\n            binary[min2i] = 1;\n        }\n        // Now assign binary code to each vocabulary word\n        for (int j = 0; j < vocabSize; j++)\n        {\n            int k = j;\n            int i = 0;\n            while (true)\n            {\n                code[i] = binary[k];\n                point[i] = k;\n                i++;\n                k = parentNode[k];\n                if (k == vocabSize * 2 - 2) break;\n            }\n            vocab[j].codelen = i;\n            vocab[j].point[0] = vocabSize - 2;\n            for (k = 0; k < i; k++)\n            {\n                vocab[j].code[i - k - 1] = code[k];\n                vocab[j].point[i - k] = point[k] - vocabSize;\n            }\n        }\n    }",
    "reference_explanation": "Create binary Huffman tree using the word counts.\nFrequent words will have short uniqe binary codes",
    "generated_explanation": ""
  },
  {
    "index": 761,
    "code": "public static List<Document> convert2DocumentList(String folderPath, boolean verbose)\n    {\n        long start = System.currentTimeMillis();\n        List<File> fileList = IOUtil.fileList(folderPath);\n        List<Document> documentList = new LinkedList<Document>();\n        int i = 0;\n        for (File file : fileList)\n        {\n            if (verbose) System.out.print(file);\n            Document document = convert2Document(file);\n            documentList.add(document);\n            if (verbose) System.out.println(\" \" + ++i + \" / \" + fileList.size());\n        }\n        if (verbose)\n        {\n            System.out.println(documentList.size());\n            System.out.printf(\"\u82b1\u8d39\u65f6\u95f4%d ms\\n\", System.currentTimeMillis() - start);\n        }\n        return documentList;\n    }",
    "reference_explanation": "\u8bfb\u53d6\u6574\u4e2a\u76ee\u5f55\u4e2d\u7684\u4eba\u6c11\u65e5\u62a5\u683c\u5f0f\u8bed\u6599\n\n@param folderPath \u8def\u5f84\n@param verbose\n@return",
    "generated_explanation": ""
  },
  {
    "index": 762,
    "code": "public int determineMedian(List<Intervalable> intervals)\n    {\n        int start = -1;\n        int end = -1;\n        for (Intervalable interval : intervals)\n        {\n            int currentStart = interval.getStart();\n            int currentEnd = interval.getEnd();\n            if (start == -1 || currentStart < start)\n            {\n                start = currentStart;\n            }\n            if (end == -1 || currentEnd > end)\n            {\n                end = currentEnd;\n            }\n        }\n        return (start + end) / 2;\n    }",
    "reference_explanation": "\u8ba1\u7b97\u4e2d\u70b9\n@param intervals \u533a\u95f4\u96c6\u5408\n@return \u4e2d\u70b9\u5750\u6807",
    "generated_explanation": ""
  },
  {
    "index": 763,
    "code": "public List<Intervalable> findOverlaps(Intervalable interval)\n    {\n\n        List<Intervalable> overlaps = new ArrayList<Intervalable>();\n\n        if (this.point < interval.getStart())\n        {\n            // \u53f3\u8fb9\u627e\u627e\n            addToOverlaps(interval, overlaps, findOverlappingRanges(this.right, interval));\n            addToOverlaps(interval, overlaps, checkForOverlapsToTheRight(interval));\n        }\n        else if (this.point > interval.getEnd())\n        {\n            // \u5de6\u8fb9\u627e\u627e\n            addToOverlaps(interval, overlaps, findOverlappingRanges(this.left, interval));\n            addToOverlaps(interval, overlaps, checkForOverlapsToTheLeft(interval));\n        }\n        else\n        {\n            // \u5426\u5219\u5728\u5f53\u524d\u533a\u95f4\n            addToOverlaps(interval, overlaps, this.intervals);\n            addToOverlaps(interval, overlaps, findOverlappingRanges(this.left, interval));\n            addToOverlaps(interval, overlaps, findOverlappingRanges(this.right, interval));\n        }\n\n        return overlaps;\n    }",
    "reference_explanation": "\u5bfb\u627e\u4e0einterval\u6709\u91cd\u53e0\u7684\u533a\u95f4\n@param interval\n@return",
    "generated_explanation": ""
  },
  {
    "index": 764,
    "code": "protected void addToOverlaps(Intervalable interval, List<Intervalable> overlaps, List<Intervalable> newOverlaps)\n    {\n        for (Intervalable currentInterval : newOverlaps)\n        {\n            if (!currentInterval.equals(interval))\n            {\n                overlaps.add(currentInterval);\n            }\n        }\n    }",
    "reference_explanation": "\u6dfb\u52a0\u5230\u91cd\u53e0\u533a\u95f4\u5217\u8868\u4e2d\n@param interval \u8ddf\u6b64\u533a\u95f4\u91cd\u53e0\n@param overlaps \u91cd\u53e0\u533a\u95f4\u5217\u8868\n@param newOverlaps \u5e0c\u671b\u5c06\u8fd9\u4e9b\u533a\u95f4\u52a0\u5165",
    "generated_explanation": ""
  },
  {
    "index": 765,
    "code": "protected List<Intervalable> checkForOverlaps(Intervalable interval, Direction direction)\n    {\n\n        List<Intervalable> overlaps = new ArrayList<Intervalable>();\n        for (Intervalable currentInterval : this.intervals)\n        {\n            switch (direction)\n            {\n                case LEFT:\n                    if (currentInterval.getStart() <= interval.getEnd())\n                    {\n                        overlaps.add(currentInterval);\n                    }\n                    break;\n                case RIGHT:\n                    if (currentInterval.getEnd() >= interval.getStart())\n                    {\n                        overlaps.add(currentInterval);\n                    }\n                    break;\n            }\n        }\n        return overlaps;\n    }",
    "reference_explanation": "\u5bfb\u627e\u91cd\u53e0\n@param interval \u4e00\u4e2a\u533a\u95f4\uff0c\u4e0e\u8be5\u533a\u95f4\u91cd\u53e0\n@param direction \u65b9\u5411\uff0c\u8868\u660e\u91cd\u53e0\u533a\u95f4\u5728interval\u7684\u5de6\u8fb9\u8fd8\u662f\u53f3\u8fb9\n@return",
    "generated_explanation": ""
  },
  {
    "index": 766,
    "code": "protected static List<Intervalable> findOverlappingRanges(IntervalNode node, Intervalable interval)\n    {\n        if (node != null)\n        {\n            return node.findOverlaps(interval);\n        }\n        return Collections.emptyList();\n    }",
    "reference_explanation": "\u662f\u5bf9IntervalNode.findOverlaps(Intervalable)\u7684\u4e00\u4e2a\u5305\u88c5\uff0c\u9632\u6b62NPE\n@see com.hankcs.hanlp.algorithm.ahocorasick.interval.IntervalNode#findOverlaps(Intervalable)\n@param node\n@param interval\n@return",
    "generated_explanation": ""
  },
  {
    "index": 767,
    "code": "public boolean learn(Instance instance)\n    {\n        if (instance == null) return false;\n        model.update(instance);\n        return true;\n    }",
    "reference_explanation": "\u5728\u7ebf\u5b66\u4e60\n\n@param instance\n@return",
    "generated_explanation": ""
  },
  {
    "index": 768,
    "code": "public static List<NS> viterbiCompute(List<EnumItem<NS>> roleTagList)\n    {\n        return Viterbi.computeEnum(roleTagList, PlaceDictionary.transformMatrixDictionary);\n    }",
    "reference_explanation": "\u7ef4\u7279\u6bd4\u7b97\u6cd5\u6c42\u89e3\u6700\u4f18\u6807\u7b7e\n@param roleTagList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 769,
    "code": "public BaseNode<V> transition(char path)\n    {\n        BaseNode<V> cur = this;\n        cur = cur.getChild(path);\n        if (cur == null || cur.status == Status.UNDEFINED_0) return null;\n        return cur;\n    }",
    "reference_explanation": "\u8f6c\u79fb\u72b6\u6001\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 770,
    "code": "public void extend(int ordinaryMax)\n    {\n        this.ordinaryMax = ordinaryMax;\n        double[][] n_transititon_probability = new double[ordinaryMax][ordinaryMax];\n        for (int i = 0; i < transititon_probability.length; i++)\n        {\n            System.arraycopy(transititon_probability[i], 0, n_transititon_probability[i], 0, transititon_probability.length);\n        }\n        transititon_probability = n_transititon_probability;\n\n        int[] n_total = new int[ordinaryMax];\n        System.arraycopy(total, 0, n_total, 0, total.length);\n        total = n_total;\n\n        double[] n_start_probability = new double[ordinaryMax];\n        System.arraycopy(start_probability, 0, n_start_probability, 0, start_probability.length);\n        start_probability = n_start_probability;\n\n        int[][] n_matrix = new int[ordinaryMax][ordinaryMax];\n        for (int i = 0; i < matrix.length; i++)\n        {\n            System.arraycopy(matrix[i], 0, n_matrix[i], 0, matrix.length);\n        }\n        matrix = n_matrix;\n    }",
    "reference_explanation": "\u62d3\u5c55\u5185\u90e8\u77e9\u9635,\u4ec5\u7528\u4e8e\u901a\u8fc7\u53cd\u5c04\u65b0\u589e\u4e86\u679a\u4e3e\u5b9e\u4f8b\u4e4b\u540e\u7684\u517c\u5bb9\u63aa\u65bd",
    "generated_explanation": ""
  },
  {
    "index": 771,
    "code": "public long distance(String a, String b)\n    {\n        SynonymItem itemA = get(a);\n        if (itemA == null) return Long.MAX_VALUE / 3;\n        SynonymItem itemB = get(b);\n        if (itemB == null) return Long.MAX_VALUE / 3;\n\n        return itemA.distance(itemB);\n    }",
    "reference_explanation": "\u8bed\u4e49\u8ddd\u79bb\n\n@param a\n@param b\n@return",
    "generated_explanation": ""
  },
  {
    "index": 772,
    "code": "public void addPair(String first, String second)\n    {\n        Map<String, Integer> firstMatrix = transferMatrix.get(first);\n        if (firstMatrix == null)\n        {\n            firstMatrix = new TreeMap<String, Integer>();\n            transferMatrix.put(first, firstMatrix);\n        }\n        Integer frequency = firstMatrix.get(second);\n        if (frequency == null) frequency = 0;\n        firstMatrix.put(second, frequency + 1);\n    }",
    "reference_explanation": "\u6dfb\u52a0\u4e00\u4e2a\u8f6c\u79fb\u4f8b\u5b50\uff0c\u4f1a\u5728\u5185\u90e8\u5b8c\u6210\u7edf\u8ba1\n@param first\n@param second",
    "generated_explanation": ""
  },
  {
    "index": 773,
    "code": "public static final Nature fromString(String name)\n    {\n        Integer id = idMap.get(name);\n        if (id == null)\n            return null;\n        return values[id];\n    }",
    "reference_explanation": "\u5b89\u5168\u5730\u5c06\u5b57\u7b26\u4e32\u7c7b\u578b\u7684\u8bcd\u6027\u8f6c\u4e3aEnum\u7c7b\u578b\uff0c\u5982\u679c\u672a\u5b9a\u4e49\u8be5\u8bcd\u6027\uff0c\u5219\u8fd4\u56denull\n\n@param name \u5b57\u7b26\u4e32\u8bcd\u6027\n@return Enum\u8bcd\u6027",
    "generated_explanation": ""
  },
  {
    "index": 774,
    "code": "public static final Nature create(String name)\n    {\n        Nature nature = fromString(name);\n        if (nature == null)\n            return new Nature(name);\n        return nature;\n    }",
    "reference_explanation": "\u521b\u5efa\u81ea\u5b9a\u4e49\u8bcd\u6027,\u5982\u679c\u5df2\u6709\u8be5\u5bf9\u5e94\u8bcd\u6027,\u5219\u76f4\u63a5\u8fd4\u56de\u5df2\u6709\u7684\u8bcd\u6027\n\n@param name \u5b57\u7b26\u4e32\u8bcd\u6027\n@return Enum\u8bcd\u6027",
    "generated_explanation": ""
  },
  {
    "index": 775,
    "code": "@Override\n    public int[] toIdList(int codePoint)\n    {\n        int count;\n        if (codePoint < 0x80)\n            count = 1;\n        else if (codePoint < 0x800)\n            count = 2;\n        else if (codePoint < 0x10000)\n            count = 3;\n        else if (codePoint < 0x200000)\n            count = 4;\n        else if (codePoint < 0x4000000)\n            count = 5;\n        else if (codePoint <= 0x7fffffff)\n            count = 6;\n        else\n            return EMPTYLIST;\n        int[] r = new int[count];\n        switch (count)\n        { /* note: code falls through cases! */\n            case 6:\n                r[5] = (char) (0x80 | (codePoint & 0x3f));\n                codePoint = codePoint >> 6;\n                codePoint |= 0x4000000;\n            case 5:\n                r[4] = (char) (0x80 | (codePoint & 0x3f));\n                codePoint = codePoint >> 6;\n                codePoint |= 0x200000;\n            case 4:\n                r[3] = (char) (0x80 | (codePoint & 0x3f));\n                codePoint = codePoint >> 6;\n                codePoint |= 0x10000;\n            case 3:\n                r[2] = (char) (0x80 | (codePoint & 0x3f));\n                codePoint = codePoint >> 6;\n                codePoint |= 0x800;\n            case 2:\n                r[1] = (char) (0x80 | (codePoint & 0x3f));\n                codePoint = codePoint >> 6;\n                codePoint |= 0xc0;\n            case 1:\n                r[0] = (char) codePoint;\n        }\n        return r;\n    }",
    "reference_explanation": "codes ported from iconv lib in utf8.h utf8_codepointtomb",
    "generated_explanation": ""
  },
  {
    "index": 776,
    "code": "public static TriaFrequency create(String first, char delimiter, String second, String third)\n    {\n        TriaFrequency triaFrequency = new TriaFrequency(first + delimiter + second + Occurrence.RIGHT + third);\n        triaFrequency.first = first;\n        triaFrequency.second = second;\n        triaFrequency.third = third;\n        triaFrequency.delimiter = delimiter;\n        return triaFrequency;\n    }",
    "reference_explanation": "\u6784\u9020\u4e00\u4e2a\u4e09\u9636\u63a5\u7eed\uff0c\u6b63\u5411\n\n@param first\n@param second\n@param third\n@param delimiter \u4e00\u822c\u4f7f\u7528RIGHT\uff01\n@return",
    "generated_explanation": ""
  },
  {
    "index": 777,
    "code": "public void train(String templFile, String trainFile, String modelFile,\n                      int maxitr, int freq, double eta, double C, int threadNum, int shrinkingSize,\n                      Encoder.Algorithm algorithm) throws IOException\n    {\n        Encoder encoder = new Encoder();\n        if (!encoder.learn(templFile, trainFile, modelFile,\n                           true, maxitr, freq, eta, C, threadNum, shrinkingSize, algorithm))\n        {\n            throw new IOException(\"fail to learn model\");\n        }\n        convert(modelFile);\n    }",
    "reference_explanation": "\u8bad\u7ec3\n\n@param templFile     \u6a21\u677f\u6587\u4ef6\n@param trainFile     \u8bad\u7ec3\u6587\u4ef6\n@param modelFile     \u6a21\u578b\u6587\u4ef6\n@param maxitr        \u6700\u5927\u8fed\u4ee3\u6b21\u6570\n@param freq          \u7279\u5f81\u6700\u4f4e\u9891\u6b21\n@param eta           \u6536\u655b\u9608\u503c\n@param C             cost-factor\n@param threadNum     \u7ebf\u7a0b\u6570\n@param shrinkingSize\n@param algorithm     \u8bad\u7ec3\u7b97\u6cd5\n@return",
    "generated_explanation": ""
  },
  {
    "index": 778,
    "code": "public void dumpTemplate(String templatePath) throws IOException\n    {\n        BufferedWriter bw = IOUtil.newBufferedWriter(templatePath);\n        String template = getTemplate();\n        bw.write(template);\n        bw.close();\n    }",
    "reference_explanation": "\u5bfc\u51fa\u7279\u5f81\u6a21\u677f\n\n@param templatePath\n@throws IOException",
    "generated_explanation": ""
  },
  {
    "index": 779,
    "code": "public String getTemplate()\n    {\n        String template = getDefaultFeatureTemplate();\n        if (model != null && model.getFeatureTemplateArray() != null)\n        {\n            StringBuilder sbTemplate = new StringBuilder();\n            for (FeatureTemplate featureTemplate : model.getFeatureTemplateArray())\n            {\n                sbTemplate.append(featureTemplate.getTemplate()).append('\\n');\n            }\n        }\n        return template;\n    }",
    "reference_explanation": "\u83b7\u53d6\u7279\u5f81\u6a21\u677f\n\n@return",
    "generated_explanation": ""
  },
  {
    "index": 780,
    "code": "public void add(Object id, String text)\n    {\n        List<Term> termList = preprocess(text);\n        add(id, termList);\n    }",
    "reference_explanation": "\u6dfb\u52a0\u6587\u6863\n\n@param id   \u6587\u6863id\n@param text \u6587\u6863\u5185\u5bb9",
    "generated_explanation": ""
  },
  {
    "index": 781,
    "code": "public int add(String text)\n    {\n        int id = tfMap.size();\n        add(id, text);\n        return id;\n    }",
    "reference_explanation": "\u6dfb\u52a0\u6587\u6863\uff0c\u81ea\u52a8\u5206\u914did\n\n@param text",
    "generated_explanation": ""
  },
  {
    "index": 782,
    "code": "public static CRFModel loadTxt(String path, CRFModel instance)\n    {\n        CRFModel CRFModel = instance;\n        // \u5148\u5c1d\u8bd5\u4ecebin\u52a0\u8f7d\n        if (CRFModel.load(ByteArray.createByteArray(path + Predefine.BIN_EXT))) return CRFModel;\n        IOUtil.LineIterator lineIterator = new IOUtil.LineIterator(path);\n        if (!lineIterator.hasNext()) return null;\n        logger.info(lineIterator.next());   // verson\n        logger.info(lineIterator.next());   // cost-factor\n        int maxid = Integer.parseInt(lineIterator.next().substring(\"maxid:\".length()).trim());\n        logger.info(lineIterator.next());   // xsize\n        lineIterator.next();    // blank\n        String line;\n        int id = 0;\n        CRFModel.tag2id = new HashMap<String, Integer>();\n        while ((line = lineIterator.next()).length() != 0)\n        {\n            CRFModel.tag2id.put(line, id);\n            ++id;\n        }\n        CRFModel.id2tag = new String[CRFModel.tag2id.size()];\n        final int size = CRFModel.id2tag.length;\n        for (Map.Entry<String, Integer> entry : CRFModel.tag2id.entrySet())\n        {\n            CRFModel.id2tag[entry.getValue()] = entry.getKey();\n        }\n        TreeMap<String, FeatureFunction> featureFunctionMap = new TreeMap<String, FeatureFunction>();  // \u6784\u5efatrie\u6811\u7684\u65f6\u5019\u7528\n        TreeMap<Integer, FeatureFunction> featureFunctionList = new TreeMap<Integer, FeatureFunction>(); // \u8bfb\u53d6\u6743\u503c\u7684\u65f6\u5019\u7528\n        CRFModel.featureTemplateList = new LinkedList<FeatureTemplate>();\n        while ((line = lineIterator.next()).length() != 0)\n        {\n            if (!\"B\".equals(line))\n            {\n                FeatureTemplate featureTemplate = FeatureTemplate.create(line);\n                CRFModel.featureTemplateList.add(featureTemplate);\n            }\n            else\n            {\n                CRFModel.matrix = new double[size][size];\n            }\n        }\n\n        int b = -1;// \u8f6c\u6362\u77e9\u9635\u7684\u6743\u91cd\u4f4d\u7f6e\n        if (CRFModel.matrix != null)\n        {\n            String[] args = lineIterator.next().split(\" \", 2);    // 0 B\n            b = Integer.valueOf(args[0]);\n            featureFunctionList.put(b, null);\n        }\n\n        while ((line = lineIterator.next()).length() != 0)\n        {\n            String[] args = line.split(\" \", 2);\n            char[] charArray = args[1].toCharArray();\n            FeatureFunction featureFunction = new FeatureFunction(charArray, size);\n            featureFunctionMap.put(args[1], featureFunction);\n            featureFunctionList.put(Integer.parseInt(args[0]), featureFunction);\n        }\n\n        for (Map.Entry<Integer, FeatureFunction> entry : featureFunctionList.entrySet())\n        {\n            int fid = entry.getKey();\n            FeatureFunction featureFunction = entry.getValue();\n            if (fid == b)\n            {\n                for (int i = 0; i < size; i++)\n                {\n                    for (int j = 0; j < size; j++)\n                    {\n                        CRFModel.matrix[i][j] = Double.parseDouble(lineIterator.next());\n                    }\n                }\n            }\n            else\n            {\n                for (int i = 0; i < size; i++)\n                {\n                    featureFunction.w[i] = Double.parseDouble(lineIterator.next());\n                }\n            }\n        }\n        if (lineIterator.hasNext())\n        {\n            logger.warning(\"\u6587\u672c\u8bfb\u53d6\u6709\u6b8b\u7559\uff0c\u53ef\u80fd\u4f1a\u51fa\u95ee\u9898\uff01\" + path);\n        }\n        lineIterator.close();\n        logger.info(\"\u5f00\u59cb\u6784\u5efatrie\u6811\");\n        CRFModel.featureFunctionTrie.build(featureFunctionMap);\n        // \u7f13\u5b58bin\n        try\n        {\n            logger.info(\"\u5f00\u59cb\u7f13\u5b58\" + path + Predefine.BIN_EXT);\n            DataOutputStream out = new DataOutputStream(IOUtil.newOutputStream(path + Predefine.BIN_EXT));\n            CRFModel.save(out);\n            out.close();\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u5728\u7f13\u5b58\" + path + Predefine.BIN_EXT + \"\u65f6\u53d1\u751f\u9519\u8bef\" + TextUtility.exceptionToString(e));\n        }\n        CRFModel.onLoadTxtFinished();\n        return CRFModel;\n    }",
    "reference_explanation": "\u52a0\u8f7dTxt\u5f62\u5f0f\u7684CRF++\u6a21\u578b\n\n@param path     \u6a21\u578b\u8def\u5f84\n@param instance \u6a21\u578b\u7684\u5b9e\u4f8b\uff08\u8fd9\u91cc\u5141\u8bb8\u7528\u6237\u6784\u9020\u4e0d\u540c\u7684CRFModel\u6765\u50a8\u5b58\u6700\u7ec8\u8bfb\u53d6\u7684\u7ed3\u679c\uff09\n@return \u8be5\u6a21\u578b",
    "generated_explanation": ""
  },
  {
    "index": 783,
    "code": "public void tag(Table table)\n    {\n        int size = table.size();\n        if (size == 0) return;\n        int tagSize = id2tag.length;\n        double[][] net = new double[size][tagSize];\n        for (int i = 0; i < size; ++i)\n        {\n            LinkedList<double[]> scoreList = computeScoreList(table, i);\n            for (int tag = 0; tag < tagSize; ++tag)\n            {\n                net[i][tag] = computeScore(scoreList, tag);\n            }\n        }\n\n        if (size == 1)\n        {\n            double maxScore = -1e10;\n            int bestTag = 0;\n            for (int tag = 0; tag < net[0].length; ++tag)\n            {\n                if (net[0][tag] > maxScore)\n                {\n                    maxScore = net[0][tag];\n                    bestTag = tag;\n                }\n            }\n            table.setLast(0, id2tag[bestTag]);\n            return;\n        }\n\n        int[][] from = new int[size][tagSize];\n        double[][] maxScoreAt = new double[2][tagSize]; // \u6eda\u52a8\u6570\u7ec4\n        System.arraycopy(net[0], 0, maxScoreAt[0], 0, tagSize); // \u521d\u59cbpreI=0,  maxScoreAt[preI][pre] = net[0][pre]\n        int curI = 0;\n        for (int i = 1; i < size; ++i)\n        {\n            curI = i & 1;\n            int preI = 1 - curI;\n            for (int now = 0; now < tagSize; ++now)\n            {\n                double maxScore = -1e10;\n                for (int pre = 0; pre < tagSize; ++pre)\n                {\n                    double score = maxScoreAt[preI][pre] + matrix[pre][now] + net[i][now];\n                    if (score > maxScore)\n                    {\n                        maxScore = score;\n                        from[i][now] = pre;\n                        maxScoreAt[curI][now] = maxScore;\n                    }\n                }\n                net[i][now] = maxScore;\n            }\n        }\n        // \u53cd\u5411\u56de\u6eaf\u6700\u4f73\u8def\u5f84\n        double maxScore = -1e10;\n        int maxTag = 0;\n        for (int tag = 0; tag < tagSize; ++tag)\n        {\n            if (maxScoreAt[curI][tag] > maxScore)\n            {\n                maxScore = maxScoreAt[curI][tag];\n                maxTag = tag;\n            }\n        }\n\n        table.setLast(size - 1, id2tag[maxTag]);\n        maxTag = from[size - 1][maxTag];\n        for (int i = size - 2; i > 0; --i)\n        {\n            table.setLast(i, id2tag[maxTag]);\n            maxTag = from[i][maxTag];\n        }\n        table.setLast(0, id2tag[maxTag]);\n    }",
    "reference_explanation": "\u7ef4\u7279\u6bd4\u540e\u5411\u7b97\u6cd5\u6807\u6ce8\n\n@param table",
    "generated_explanation": ""
  },
  {
    "index": 784,
    "code": "protected LinkedList<double[]> computeScoreList(Table table, int current)\n    {\n        LinkedList<double[]> scoreList = new LinkedList<double[]>();\n        for (FeatureTemplate featureTemplate : featureTemplateList)\n        {\n            char[] o = featureTemplate.generateParameter(table, current);\n            FeatureFunction featureFunction = featureFunctionTrie.get(o);\n            if (featureFunction == null) continue;\n            scoreList.add(featureFunction.w);\n        }\n\n        return scoreList;\n    }",
    "reference_explanation": "\u6839\u636e\u7279\u5f81\u51fd\u6570\u8ba1\u7b97\u8f93\u51fa\n\n@param table\n@param current\n@return",
    "generated_explanation": ""
  },
  {
    "index": 785,
    "code": "protected static double computeScore(LinkedList<double[]> scoreList, int tag)\n    {\n        double score = 0;\n        for (double[] w : scoreList)\n        {\n            score += w[tag];\n        }\n        return score;\n    }",
    "reference_explanation": "\u7ed9\u4e00\u7cfb\u5217\u7279\u5f81\u51fd\u6570\u7ed3\u5408tag\u6253\u5206\n\n@param scoreList\n@param tag\n@return",
    "generated_explanation": ""
  },
  {
    "index": 786,
    "code": "public static CRFModel load(String path)\n    {\n        CRFModel model = loadBin(path + BIN_EXT);\n        if (model != null) return model;\n        return loadTxt(path, new CRFModel(new DoubleArrayTrie<FeatureFunction>()));\n    }",
    "reference_explanation": "\u52a0\u8f7dCRF++\u6a21\u578b<br>\n\u5982\u679c\u5b58\u5728\u7f13\u5b58\u7684\u8bdd\uff0c\u4f18\u5148\u8bfb\u53d6\u7f13\u5b58\uff0c\u5426\u5219\u8bfb\u53d6txt\uff0c\u5e76\u4e14\u5efa\u7acb\u7f13\u5b58\n\n@param path txt\u7684\u8def\u5f84\uff0c\u5373\u4f7f\u4e0d\u5b58\u5728.txt\uff0c\u53ea\u5b58\u5728.bin\uff0c\u4e5f\u5e94\u4f20\u5165txt\u7684\u8def\u5f84\uff0c\u65b9\u6cd5\u5185\u90e8\u4f1a\u81ea\u52a8\u52a0.bin\u540e\u7f00\n@return",
    "generated_explanation": ""
  },
  {
    "index": 787,
    "code": "public static CRFModel loadBin(String path)\n    {\n        ByteArray byteArray = ByteArray.createByteArray(path);\n        if (byteArray == null) return null;\n        CRFModel model = new CRFModel();\n        if (model.load(byteArray)) return model;\n        return null;\n    }",
    "reference_explanation": "\u52a0\u8f7dBin\u5f62\u5f0f\u7684CRF++\u6a21\u578b<br>\n\u6ce8\u610f\u8be5Bin\u5f62\u5f0f\u4e0d\u662fCRF++\u7684\u4e8c\u8fdb\u5236\u6a21\u578b,\u800c\u662fHanLP\u7531CRF++\u7684\u6587\u672c\u6a21\u578b\u8f6c\u6362\u8fc7\u6765\u7684\u79c1\u6709\u683c\u5f0f\n\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 788,
    "code": "public static Word create(String param)\n    {\n        if (param == null) return null;\n        int cutIndex = param.lastIndexOf('/');\n        if (cutIndex <= 0 || cutIndex == param.length() - 1)\n        {\n            logger.warning(\"\u4f7f\u7528 \" + param + \"\u521b\u5efa\u5355\u4e2a\u5355\u8bcd\u5931\u8d25\");\n            return null;\n        }\n\n        return new Word(param.substring(0, cutIndex), param.substring(cutIndex + 1));\n    }",
    "reference_explanation": "\u901a\u8fc7\u53c2\u6570\u6784\u9020\u4e00\u4e2a\u5355\u8bcd\n@param param \u6bd4\u5982 \u4eba\u6c11\u7f51/nz\n@return \u4e00\u4e2a\u5355\u8bcd",
    "generated_explanation": ""
  },
  {
    "index": 789,
    "code": "public static IWord create(String param)\n    {\n        if (param == null) return null;\n        if (param.startsWith(\"[\") && !param.startsWith(\"[/\"))\n        {\n            return CompoundWord.create(param);\n        }\n        else\n        {\n            return Word.create(param);\n        }\n    }",
    "reference_explanation": "\u6839\u636e\u53c2\u6570\u5b57\u7b26\u4e32\u4ea7\u751f\u5bf9\u5e94\u7684\u8bcd\u8bed\n@param param\n@return",
    "generated_explanation": ""
  },
  {
    "index": 790,
    "code": "public String[][] getEdgeArray()\n    {\n        String[][] edge = new String[word.length + 1][word.length + 1];\n        for (CoNLLWord coNLLWord : word)\n        {\n            edge[coNLLWord.ID][coNLLWord.HEAD.ID] = coNLLWord.DEPREL;\n        }\n\n        return edge;\n    }",
    "reference_explanation": "\u83b7\u53d6\u8fb9\u7684\u5217\u8868\uff0cedge[i][j]\u8868\u793aid\u4e3ai\u7684\u8bcd\u8bed\u4e0ej\u5b58\u5728\u4e00\u6761\u4f9d\u5b58\u5173\u7cfb\u4e3a\u8be5\u503c\u7684\u8fb9\uff0c\u5426\u5219\u4e3anull\n@return",
    "generated_explanation": ""
  },
  {
    "index": 791,
    "code": "public CoNLLWord[] getWordArrayWithRoot()\n    {\n        CoNLLWord[] wordArray = new CoNLLWord[word.length + 1];\n        wordArray[0] = CoNLLWord.ROOT;\n        System.arraycopy(word, 0, wordArray, 1, word.length);\n\n        return wordArray;\n    }",
    "reference_explanation": "\u83b7\u53d6\u5305\u542b\u6839\u8282\u70b9\u5728\u5185\u7684\u5355\u8bcd\u6570\u7ec4\n@return",
    "generated_explanation": ""
  },
  {
    "index": 792,
    "code": "public List<CoNLLWord> findChildren(CoNLLWord word)\n    {\n        List<CoNLLWord> result = new LinkedList<CoNLLWord>();\n        for (CoNLLWord other : this)\n        {\n            if (other.HEAD == word)\n                result.add(other);\n        }\n        return result;\n    }",
    "reference_explanation": "\u627e\u51fa\u6240\u6709\u5b50\u8282\u70b9\n@param word\n@return",
    "generated_explanation": ""
  },
  {
    "index": 793,
    "code": "public List<CoNLLWord> findChildren(CoNLLWord word, String relation)\n    {\n        List<CoNLLWord> result = new LinkedList<CoNLLWord>();\n        for (CoNLLWord other : this)\n        {\n            if (other.HEAD == word && other.DEPREL.equals(relation))\n                result.add(other);\n        }\n        return result;\n    }",
    "reference_explanation": "\u627e\u51fa\u7279\u5b9a\u4f9d\u5b58\u5173\u7cfb\u7684\u5b50\u8282\u70b9\n@param word\n@param relation\n@return",
    "generated_explanation": ""
  },
  {
    "index": 794,
    "code": "public void parseConllFileNoParallel(String inputFile, String outputFile, boolean rootFirst, int beamWidth, boolean labeled, boolean lowerCased, int numOfThreads, boolean partial, String scorePath) throws IOException, ExecutionException, InterruptedException\n    {\n        CoNLLReader reader = new CoNLLReader(inputFile);\n        boolean addScore = false;\n        if (scorePath.trim().length() > 0)\n            addScore = true;\n        ArrayList<Float> scoreList = new ArrayList<Float>();\n\n        long start = System.currentTimeMillis();\n        int allArcs = 0;\n        int size = 0;\n        BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile + \".tmp\"));\n        int dataCount = 0;\n\n        while (true)\n        {\n            ArrayList<Instance> data = reader.readData(15000, true, labeled, rootFirst, lowerCased, maps);\n            size += data.size();\n            if (data.size() == 0)\n                break;\n\n            for (Instance instance : data)\n            {\n                dataCount++;\n                if (dataCount % 100 == 0)\n                    System.err.print(dataCount + \" ... \");\n                Configuration bestParse;\n                if (partial)\n                    bestParse = parsePartial(instance, instance.getSentence(), rootFirst, beamWidth, numOfThreads);\n                else bestParse = parse(instance.getSentence(), rootFirst, beamWidth, numOfThreads);\n\n                int[] words = instance.getSentence().getWords();\n                allArcs += words.length - 1;\n                if (addScore)\n                    scoreList.add(bestParse.score / bestParse.sentence.size());\n\n                writeParsedSentence(writer, rootFirst, bestParse, words);\n            }\n        }\n\n//        System.err.print(\"\\n\");\n        long end = System.currentTimeMillis();\n        float each = (1.0f * (end - start)) / size;\n        float eacharc = (1.0f * (end - start)) / allArcs;\n\n        writer.flush();\n        writer.close();\n\n//        DecimalFormat format = new DecimalFormat(\"##.00\");\n//\n//        System.err.print(format.format(eacharc) + \" ms for each arc!\\n\");\n//        System.err.print(format.format(each) + \" ms for each sentence!\\n\\n\");\n\n        BufferedReader gReader = new BufferedReader(new FileReader(inputFile));\n        BufferedReader pReader = new BufferedReader(new FileReader(outputFile + \".tmp\"));\n        BufferedWriter pwriter = new BufferedWriter(new FileWriter(outputFile));\n\n        String line;\n\n        while ((line = pReader.readLine()) != null)\n        {\n            String gLine = gReader.readLine();\n            if (line.trim().length() > 0)\n            {\n                while (gLine.trim().length() == 0)\n                    gLine = gReader.readLine();\n                String[] ps = line.split(\"\\t\");\n                String[] gs = gLine.split(\"\\t\");\n                gs[6] = ps[0];\n                gs[7] = ps[1];\n                StringBuilder output = new StringBuilder();\n                for (int i = 0; i < gs.length; i++)\n                {\n                    output.append(gs[i]).append(\"\\t\");\n                }\n                pwriter.write(output.toString().trim() + \"\\n\");\n            }\n            else\n            {\n                pwriter.write(\"\\n\");\n            }\n        }\n        pwriter.flush();\n        pwriter.close();\n\n        if (addScore)\n        {\n            BufferedWriter scoreWriter = new BufferedWriter(new FileWriter(scorePath));\n\n            for (int i = 0; i < scoreList.size(); i++)\n                scoreWriter.write(scoreList.get(i) + \"\\n\");\n            scoreWriter.flush();\n            scoreWriter.close();\n        }\n        IOUtil.deleteFile(outputFile + \".tmp\");\n    }",
    "reference_explanation": "Needs Conll 2006 format\n\n@param inputFile\n@param outputFile\n@param rootFirst\n@param beamWidth\n@throws Exception",
    "generated_explanation": ""
  },
  {
    "index": 795,
    "code": "private static LinearModel trainNaivePerceptron(Instance[] instanceList, FeatureMap featureMap, int maxIteration)\n    {\n        LinearModel model = new LinearModel(featureMap, new float[featureMap.size()]);\n        for (int it = 0; it < maxIteration; ++it)\n        {\n            Utility.shuffleArray(instanceList);\n            for (Instance instance : instanceList)\n            {\n                int y = model.decode(instance.x);\n                if (y != instance.y) // \u8bef\u5dee\u53cd\u9988\n                    model.update(instance.x, instance.y);\n            }\n        }\n        return model;\n    }",
    "reference_explanation": "\u6734\u7d20\u611f\u77e5\u673a\u8bad\u7ec3\u7b97\u6cd5\n@param instanceList \u8bad\u7ec3\u5b9e\u4f8b\n@param featureMap   \u7279\u5f81\u51fd\u6570\n@param maxIteration \u8bad\u7ec3\u8fed\u4ee3\u6b21\u6570",
    "generated_explanation": ""
  },
  {
    "index": 796,
    "code": "private static LinearModel trainAveragedPerceptron(Instance[] instanceList, FeatureMap featureMap, int maxIteration)\n    {\n        float[] parameter = new float[featureMap.size()];\n        double[] sum = new double[featureMap.size()];\n        int[] time = new int[featureMap.size()];\n\n        AveragedPerceptron model = new AveragedPerceptron(featureMap, parameter);\n        int t = 0;\n        for (int it = 0; it < maxIteration; ++it)\n        {\n            Utility.shuffleArray(instanceList);\n            for (Instance instance : instanceList)\n            {\n                ++t;\n                int y = model.decode(instance.x);\n                if (y != instance.y) // \u8bef\u5dee\u53cd\u9988\n                    model.update(instance.x, instance.y, sum, time, t);\n            }\n        }\n        model.average(sum, time, t);\n        return model;\n    }",
    "reference_explanation": "\u5e73\u5747\u611f\u77e5\u673a\u8bad\u7ec3\u7b97\u6cd5\n@param instanceList \u8bad\u7ec3\u5b9e\u4f8b\n@param featureMap   \u7279\u5f81\u51fd\u6570\n@param maxIteration \u8bad\u7ec3\u8fed\u4ee3\u6b21\u6570",
    "generated_explanation": ""
  },
  {
    "index": 797,
    "code": "public BinaryClassificationFMeasure train(String corpus, int maxIteration, boolean averagePerceptron)\n    {\n        FeatureMap featureMap = new LockableFeatureMap(new TagSet(TaskType.CLASSIFICATION));\n        featureMap.mutable = true; // \u8bad\u7ec3\u65f6\u7279\u5f81\u6620\u5c04\u53ef\u62d3\u5145\n        Instance[] instanceList = readInstance(corpus, featureMap);\n        model = averagePerceptron ? trainAveragedPerceptron(instanceList, featureMap, maxIteration)\n            : trainNaivePerceptron(instanceList, featureMap, maxIteration);\n        featureMap.mutable = false; // \u8bad\u7ec3\u7ed3\u675f\u540e\u7279\u5f81\u4e0d\u53ef\u5199\n        return evaluate(instanceList);\n    }",
    "reference_explanation": "\u8bad\u7ec3\n\n@param corpus            \u8bed\u6599\u5e93\n@param maxIteration      \u6700\u5927\u8fed\u4ee3\u6b21\u6570\n@param averagePerceptron \u662f\u5426\u4f7f\u7528\u5e73\u5747\u611f\u77e5\u673a\u7b97\u6cd5\n@return \u6a21\u578b\u5728\u8bad\u7ec3\u96c6\u4e0a\u7684\u51c6\u786e\u7387",
    "generated_explanation": ""
  },
  {
    "index": 798,
    "code": "public String predict(String text)\n    {\n        int y = model.decode(extractFeature(text, model.featureMap));\n        if (y == -1)\n            y = 0;\n        return model.tagSet().stringOf(y);\n    }",
    "reference_explanation": "\u9884\u6d4b\n\n@param text\n@return",
    "generated_explanation": ""
  },
  {
    "index": 799,
    "code": "public BinaryClassificationFMeasure evaluate(String corpus)\n    {\n        Instance[] instanceList = readInstance(corpus, model.featureMap);\n        return evaluate(instanceList);\n    }",
    "reference_explanation": "\u8bc4\u4f30\n\n@param corpus\n@return",
    "generated_explanation": ""
  },
  {
    "index": 800,
    "code": "public BinaryClassificationFMeasure evaluate(Instance[] instanceList)\n    {\n        int TP = 0, FP = 0, FN = 0;\n        for (Instance instance : instanceList)\n        {\n            int y = model.decode(instance.x);\n            if (y == 1)\n            {\n                if (instance.y == 1)\n                    ++TP;\n                else\n                    ++FP;\n            }\n            else if (instance.y == 1)\n                ++FN;\n        }\n        float p = TP / (float) (TP + FP) * 100;\n        float r = TP / (float) (TP + FN) * 100;\n        return new BinaryClassificationFMeasure(p, r, 2 * p * r / (p + r));\n    }",
    "reference_explanation": "\u8bc4\u4f30\n\n@param instanceList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 801,
    "code": "private Instance[] readInstance(String corpus, FeatureMap featureMap)\n    {\n        IOUtil.LineIterator lineIterator = new IOUtil.LineIterator(corpus);\n        List<Instance> instanceList = new LinkedList<Instance>();\n        for (String line : lineIterator)\n        {\n            String[] cells = line.split(\",\");\n            String text = cells[0], label = cells[1];\n            List<Integer> x = extractFeature(text, featureMap);\n            int y = featureMap.tagSet.add(label);\n            if (y == 0)\n                y = -1; // \u611f\u77e5\u673a\u6807\u7b7e\u7ea6\u5b9a\u4e3a\u00b11\n            else if (y > 1)\n                throw new IllegalArgumentException(\"\u7c7b\u522b\u6570\u5927\u4e8e2\uff0c\u76ee\u524d\u53ea\u652f\u6301\u4e8c\u5206\u7c7b\u3002\");\n            instanceList.add(new Instance(x, y));\n        }\n        return instanceList.toArray(new Instance[0]);\n    }",
    "reference_explanation": "\u4ece\u8bed\u6599\u5e93\u8bfb\u53d6\u5b9e\u4f8b\n\n@param corpus     \u8bed\u6599\u5e93\n@param featureMap \u7279\u5f81\u6620\u5c04\n@return \u6570\u636e\u96c6",
    "generated_explanation": ""
  },
  {
    "index": 802,
    "code": "protected static void addFeature(String feature, FeatureMap featureMap, List<Integer> featureList)\n    {\n        int featureId = featureMap.idOf(feature);\n        if (featureId != -1)\n            featureList.add(featureId);\n    }",
    "reference_explanation": "\u5411\u7279\u5f81\u5411\u91cf\u63d2\u5165\u7279\u5f81\n\n@param feature     \u7279\u5f81\n@param featureMap  \u7279\u5f81\u6620\u5c04\n@param featureList \u7279\u5f81\u5411\u91cf",
    "generated_explanation": ""
  },
  {
    "index": 803,
    "code": "public boolean add(E e)\n    {\n        if (queue.size() < maxSize)\n        { // \u672a\u8fbe\u5230\u6700\u5927\u5bb9\u91cf\uff0c\u76f4\u63a5\u6dfb\u52a0\n            queue.add(e);\n            return true;\n        }\n        else\n        { // \u961f\u5217\u5df2\u6ee1\n            E peek = queue.peek();\n            if (queue.comparator().compare(e, peek) > 0)\n            { // \u5c06\u65b0\u5143\u7d20\u4e0e\u5f53\u524d\u5806\u9876\u5143\u7d20\u6bd4\u8f83\uff0c\u4fdd\u7559\u8f83\u5c0f\u7684\u5143\u7d20\n                queue.poll();\n                queue.add(e);\n                return true;\n            }\n        }\n        return false;\n    }",
    "reference_explanation": "\u6dfb\u52a0\u4e00\u4e2a\u5143\u7d20\n@param e \u5143\u7d20\n@return \u662f\u5426\u6dfb\u52a0\u6210\u529f",
    "generated_explanation": ""
  },
  {
    "index": 804,
    "code": "public MaxHeap<E> addAll(Collection<E> collection)\n    {\n        for (E e : collection)\n        {\n            add(e);\n        }\n\n        return this;\n    }",
    "reference_explanation": "\u6dfb\u52a0\u8bb8\u591a\u5143\u7d20\n@param collection",
    "generated_explanation": ""
  },
  {
    "index": 805,
    "code": "public List<E> toList()\n    {\n        ArrayList<E> list = new ArrayList<E>(queue.size());\n        while (!queue.isEmpty())\n        {\n            list.add(0, queue.poll());\n        }\n\n        return list;\n    }",
    "reference_explanation": "\u8f6c\u4e3a\u6709\u5e8f\u5217\u8868\uff0c\u81ea\u6bc1\u6027\u64cd\u4f5c\n@return",
    "generated_explanation": ""
  },
  {
    "index": 806,
    "code": "void normalize()\n    {\n        double nrm = norm();\n        for (Map.Entry<Integer, Double> d : entrySet())\n        {\n            d.setValue(d.getValue() / nrm);\n        }\n    }",
    "reference_explanation": "Normalize a vector.",
    "generated_explanation": ""
  },
  {
    "index": 807,
    "code": "void multiply_constant(double x)\n    {\n        for (Map.Entry<Integer, Double> entry : entrySet())\n        {\n            entry.setValue(entry.getValue() * x);\n        }\n    }",
    "reference_explanation": "Multiply each value of  avector by a constant value.",
    "generated_explanation": ""
  },
  {
    "index": 808,
    "code": "void add_vector(SparseVector vec)\n    {\n\n        for (Map.Entry<Integer, Double> entry : vec.entrySet())\n        {\n            Double v = get(entry.getKey());\n            if (v == null)\n                v = 0.;\n            put(entry.getKey(), v + entry.getValue());\n        }\n    }",
    "reference_explanation": "Add other vector.",
    "generated_explanation": ""
  },
  {
    "index": 809,
    "code": "static double inner_product(SparseVector vec1, SparseVector vec2)\n    {\n        Iterator<Map.Entry<Integer, Double>> it;\n        SparseVector other;\n        if (vec1.size() < vec2.size())\n        {\n            it = vec1.entrySet().iterator();\n            other = vec2;\n        }\n        else\n        {\n            it = vec2.entrySet().iterator();\n            other = vec1;\n        }\n        double prod = 0;\n        while (it.hasNext())\n        {\n            Map.Entry<Integer, Double> entry = it.next();\n            prod += entry.getValue() * other.get(entry.getKey());\n        }\n        return prod;\n    }",
    "reference_explanation": "Calculate the inner product value between vectors.",
    "generated_explanation": ""
  },
  {
    "index": 810,
    "code": "double cosine(SparseVector vec1, SparseVector vec2)\n    {\n        double norm1 = vec1.norm();\n        double norm2 = vec2.norm();\n        double result = 0.0f;\n        if (norm1 == 0 && norm2 == 0)\n        {\n            return result;\n        }\n        else\n        {\n            double prod = inner_product(vec1, vec2);\n            result = prod / (norm1 * norm2);\n            return Double.isNaN(result) ? 0.0f : result;\n        }\n    }",
    "reference_explanation": "Calculate the cosine value between vectors.",
    "generated_explanation": ""
  },
  {
    "index": 811,
    "code": "public static List<Term> segment(char[] text)\n    {\n        List<Term> resultList = SEGMENT.seg(text);\n        ListIterator<Term> listIterator = resultList.listIterator();\n        while (listIterator.hasNext())\n        {\n            if (!CoreStopWordDictionary.shouldInclude(listIterator.next()))\n            {\n                listIterator.remove();\n            }\n        }\n\n        return resultList;\n    }",
    "reference_explanation": "\u5206\u8bcd\n\n@param text \u6587\u672c\n@return \u5206\u8bcd\u7ed3\u679c",
    "generated_explanation": ""
  },
  {
    "index": 812,
    "code": "public static List<List<Term>> seg2sentence(String text)\n    {\n        List<List<Term>> sentenceList = SEGMENT.seg2sentence(text);\n        for (List<Term> sentence : sentenceList)\n        {\n            ListIterator<Term> listIterator = sentence.listIterator();\n            while (listIterator.hasNext())\n            {\n                if (!CoreStopWordDictionary.shouldInclude(listIterator.next()))\n                {\n                    listIterator.remove();\n                }\n            }\n        }\n\n        return sentenceList;\n    }",
    "reference_explanation": "\u5207\u5206\u4e3a\u53e5\u5b50\u5f62\u5f0f\n\n@param text\n@return",
    "generated_explanation": ""
  },
  {
    "index": 813,
    "code": "public static List<List<Term>> seg2sentence(String text, boolean shortest)\n    {\n        return SEGMENT.seg2sentence(text, shortest);\n    }",
    "reference_explanation": "\u5206\u8bcd\u65ad\u53e5 \u8f93\u51fa\u53e5\u5b50\u5f62\u5f0f\n\n@param text     \u5f85\u5206\u8bcd\u53e5\u5b50\n@param shortest \u662f\u5426\u65ad\u53e5\u4e3a\u6700\u7ec6\u7684\u5b50\u53e5\uff08\u5c06\u9017\u53f7\u4e5f\u89c6\u4f5c\u5206\u9694\u7b26\uff09\n@return \u53e5\u5b50\u5217\u8868\uff0c\u6bcf\u4e2a\u53e5\u5b50\u7531\u4e00\u4e2a\u5355\u8bcd\u5217\u8868\u7ec4\u6210",
    "generated_explanation": ""
  },
  {
    "index": 814,
    "code": "public static List<List<Term>> seg2sentence(String text, Filter... filterArrayChain)\n    {\n        List<List<Term>> sentenceList = SEGMENT.seg2sentence(text);\n        for (List<Term> sentence : sentenceList)\n        {\n            ListIterator<Term> listIterator = sentence.listIterator();\n            while (listIterator.hasNext())\n            {\n                if (filterArrayChain != null)\n                {\n                    Term term = listIterator.next();\n                    for (Filter filter : filterArrayChain)\n                    {\n                        if (!filter.shouldInclude(term))\n                        {\n                            listIterator.remove();\n                            break;\n                        }\n                    }\n                }\n            }\n        }\n\n        return sentenceList;\n    }",
    "reference_explanation": "\u5207\u5206\u4e3a\u53e5\u5b50\u5f62\u5f0f\n\n@param text\n@param filterArrayChain \u81ea\u5b9a\u4e49\u8fc7\u6ee4\u5668\u94fe\n@return",
    "generated_explanation": ""
  },
  {
    "index": 815,
    "code": "public static List<List<Term>> seg2sentence(String text)\n    {\n        List<List<Term>> resultList = new LinkedList<List<Term>>();\n        {\n            for (String sentence : SentencesUtil.toSentenceList(text))\n            {\n                resultList.add(segment(sentence));\n            }\n        }\n\n        return resultList;\n    }",
    "reference_explanation": "\u5207\u5206\u4e3a\u53e5\u5b50\u5f62\u5f0f\n\n@param text \u6587\u672c\n@return \u53e5\u5b50\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 816,
    "code": "@Override\n    public String classify(String text) throws IllegalArgumentException, IllegalStateException\n    {\n        Map<String, Double> scoreMap = predict(text);\n\n        return CollectionUtility.max(scoreMap);\n    }",
    "reference_explanation": "\u4f7f\u7528\u4e00\u4e2a\u8bad\u7ec3\u51fa\u6765\u7684\u5206\u7c7b\u5668\u6765\u9884\u6d4b\u5206\u7c7b\n\n@param text\n@return\n@throws IllegalArgumentException\n@throws IllegalStateException",
    "generated_explanation": ""
  },
  {
    "index": 817,
    "code": "void reduceVocab()\n    {\n        table = new int[vocabSize];\n        int j = 0;\n        for (int i = 0; i < vocabSize; i++)\n        {\n            if (vocab[i].cn > minReduce)\n            {\n                vocab[j].cn = vocab[i].cn;\n                vocab[j].word = vocab[i].word;\n                table[vocabIndexMap.get(vocab[j].word)] = j;\n                j++;\n            }\n            else\n            {\n                table[vocabIndexMap.get(vocab[j].word)] = -4;\n            }\n        }\n        // adjust the index in the cache\n        try\n        {\n            cache.close();\n            File fixingFile = new File(cacheFile.getAbsolutePath() + \".fixing\");\n            cache = new DataOutputStream(new FileOutputStream(fixingFile));\n            DataInputStream oldCache = new DataInputStream(new FileInputStream(cacheFile));\n            while (oldCache.available() >= 4)\n            {\n                int oldId = oldCache.readInt();\n                if (oldId < 0)\n                {\n                    cache.writeInt(oldId);\n                    continue;\n                }\n                int id = table[oldId];\n                if (id == -4) continue;\n                cache.writeInt(id);\n            }\n            oldCache.close();\n            cache.close();\n            if (!fixingFile.renameTo(cacheFile))\n            {\n                throw new RuntimeException(String.format(\"moving %s to %s failed\", fixingFile.getAbsolutePath(), cacheFile.getName()));\n            }\n            cache = new DataOutputStream(new FileOutputStream(cacheFile));\n        }\n        catch (IOException e)\n        {\n            throw new RuntimeException(String.format(\"failed to adjust cache file\", e));\n        }\n        table = null;\n        vocabSize = j;\n        vocabIndexMap.clear();\n        for (int i = 0; i < vocabSize; i++)\n        {\n            vocabIndexMap.put(vocab[i].word, i);\n        }\n        minReduce++;\n    }",
    "reference_explanation": "Reduces the vocabulary by removing infrequent tokens",
    "generated_explanation": ""
  },
  {
    "index": 818,
    "code": "String readWord(BufferedReader raf) throws IOException\n    {\n        while (true)\n        {\n            // check the buffer first\n            if (wbp < wordsBuffer.length)\n            {\n                return wordsBuffer[wbp++];\n            }\n\n            String line = raf.readLine();\n            if (line == null)\n            {      // end of corpus\n                eoc = true;\n                return null;\n            }\n            line = line.trim();\n            if (line.length() == 0)\n            {\n                continue;\n            }\n            cache.writeInt(-3); // mark end of sentence\n            wordsBuffer = line.split(\"\\\\s+\");\n            wbp = 0;\n            eoc = false;\n        }\n    }",
    "reference_explanation": "Reads a single word from a file, assuming space + tab + EOL to be word boundaries\n\n@param raf\n@return null if EOF\n@throws IOException",
    "generated_explanation": ""
  },
  {
    "index": 819,
    "code": "static boolean loadDat(String path)\n    {\n        try\n        {\n            ByteArray byteArray = ByteArray.createByteArray(path + Predefine.BIN_EXT);\n            if (byteArray == null) return false;\n            int size = byteArray.nextInt();\n            CoreDictionary.Attribute[] attributes = new CoreDictionary.Attribute[size];\n            final Nature[] natureIndexArray = Nature.values();\n            for (int i = 0; i < size; ++i)\n            {\n                // \u7b2c\u4e00\u4e2a\u662f\u5168\u90e8\u9891\u6b21\uff0c\u7b2c\u4e8c\u4e2a\u662f\u8bcd\u6027\u4e2a\u6570\n                int currentTotalFrequency = byteArray.nextInt();\n                int length = byteArray.nextInt();\n                attributes[i] = new CoreDictionary.Attribute(length);\n                attributes[i].totalFrequency = currentTotalFrequency;\n                for (int j = 0; j < length; ++j)\n                {\n                    attributes[i].nature[j] = natureIndexArray[byteArray.nextInt()];\n                    attributes[i].frequency[j] = byteArray.nextInt();\n                }\n            }\n            if (!trie.load(byteArray, attributes) || byteArray.hasMore()) return false;\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u8bfb\u53d6\u5931\u8d25\uff0c\u95ee\u9898\u53d1\u751f\u5728\" + e);\n            return false;\n        }\n        return true;\n    }",
    "reference_explanation": "\u4ece\u78c1\u76d8\u52a0\u8f7d\u53cc\u6570\u7ec4\n\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 820,
    "code": "public static int getTermFrequency(String term)\n    {\n        Attribute attribute = get(term);\n        if (attribute == null) return 0;\n        return attribute.totalFrequency;\n    }",
    "reference_explanation": "\u83b7\u53d6\u8bcd\u9891\n\n@param term\n@return",
    "generated_explanation": ""
  },
  {
    "index": 821,
    "code": "public void addTerm(String key)\n    {\n        TermFrequency value = trieSingle.get(key);\n        if (value == null)\n        {\n            value = new TermFrequency(key);\n            trieSingle.put(key, value);\n        }\n        else\n        {\n            value.increase();\n        }\n        ++totalTerm;\n    }",
    "reference_explanation": "\u7edf\u8ba1\u8bcd\u9891\n\n@param key \u589e\u52a0\u4e00\u4e2a\u8bcd",
    "generated_explanation": ""
  },
  {
    "index": 822,
    "code": "public int getTermFrequency(String term)\n    {\n        TermFrequency termFrequency = trieSingle.get(term);\n        if (termFrequency == null) return 0;\n        return termFrequency.getValue();\n    }",
    "reference_explanation": "\u83b7\u53d6\u8bcd\u9891\n\n@param term\n@return",
    "generated_explanation": ""
  },
  {
    "index": 823,
    "code": "public double computeLeftEntropy(PairFrequency pair)\n    {\n        Set<Map.Entry<String, TriaFrequency>> entrySet = trieTria.prefixSearch(pair.getKey() + LEFT);\n        return computeEntropy(entrySet);\n    }",
    "reference_explanation": "\u8ba1\u7b97\u5de6\u71b5\n\n@param pair\n@return",
    "generated_explanation": ""
  },
  {
    "index": 824,
    "code": "public double computeRightEntropy(PairFrequency pair)\n    {\n        Set<Map.Entry<String, TriaFrequency>> entrySet = trieTria.prefixSearch(pair.getKey() + RIGHT);\n        return computeEntropy(entrySet);\n    }",
    "reference_explanation": "\u8ba1\u7b97\u53f3\u71b5\n\n@param pair\n@return",
    "generated_explanation": ""
  },
  {
    "index": 825,
    "code": "public void compute()\n    {\n        entrySetPair = triePair.entrySet();\n        double total_mi = 0;\n        double total_le = 0;\n        double total_re = 0;\n        for (Map.Entry<String, PairFrequency> entry : entrySetPair)\n        {\n            PairFrequency value = entry.getValue();\n            value.mi = computeMutualInformation(value);\n            value.le = computeLeftEntropy(value);\n            value.re = computeRightEntropy(value);\n            total_mi += value.mi;\n            total_le += value.le;\n            total_re += value.re;\n        }\n\n        for (Map.Entry<String, PairFrequency> entry : entrySetPair)\n        {\n            PairFrequency value = entry.getValue();\n            value.score = value.mi / total_mi + value.le / total_le+ value.re / total_re;   // \u5f52\u4e00\u5316\n            value.score *= entrySetPair.size();\n        }\n    }",
    "reference_explanation": "\u8f93\u5165\u6570\u636e\u5b8c\u6bd5\uff0c\u6267\u884c\u8ba1\u7b97",
    "generated_explanation": ""
  },
  {
    "index": 826,
    "code": "public void segment(String text, List<String> output)\n    {\n        String normalized = CharTable.convert(text);\n        segment(text, normalized, output);\n    }",
    "reference_explanation": "\u4e2d\u6587\u5206\u8bcd\n\n@param text\n@param output",
    "generated_explanation": ""
  },
  {
    "index": 827,
    "code": "public String[] partOfSpeechTag(List<String> wordList)\n    {\n        if (posTagger == null)\n        {\n            throw new IllegalStateException(\"\u672a\u63d0\u4f9b\u8bcd\u6027\u6807\u6ce8\u6a21\u578b\");\n        }\n        return tag(wordList);\n    }",
    "reference_explanation": "\u8bcd\u6027\u6807\u6ce8\n\n@param wordList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 828,
    "code": "public String[] namedEntityRecognize(String[] wordArray, String[] posArray)\n    {\n        if (neRecognizer == null)\n        {\n            throw new IllegalStateException(\"\u672a\u63d0\u4f9b\u547d\u540d\u5b9e\u4f53\u8bc6\u522b\u6a21\u578b\");\n        }\n        return recognize(wordArray, posArray);\n    }",
    "reference_explanation": "\u547d\u540d\u5b9e\u4f53\u8bc6\u522b\n\n@param wordArray\n@param posArray\n@return",
    "generated_explanation": ""
  },
  {
    "index": 829,
    "code": "public boolean learn(String segmentedTaggedSentence)\n    {\n        Sentence sentence = Sentence.create(segmentedTaggedSentence);\n        return learn(sentence);\n    }",
    "reference_explanation": "\u5728\u7ebf\u5b66\u4e60\n\n@param segmentedTaggedSentence \u5df2\u5206\u8bcd\u3001\u6807\u597d\u8bcd\u6027\u548c\u547d\u540d\u5b9e\u4f53\u7684\u4eba\u6c11\u65e5\u62a52014\u683c\u5f0f\u7684\u53e5\u5b50\n@return \u662f\u5426\u5b66\u4e60\u6210\u679c\uff08\u5931\u8d25\u7684\u539f\u56e0\u662f\u53e5\u5b50\u683c\u5f0f\u4e0d\u5408\u6cd5\uff09",
    "generated_explanation": ""
  },
  {
    "index": 830,
    "code": "public boolean learn(Sentence sentence)\n    {\n        CharTable.normalize(sentence);\n        if (!getPerceptronSegmenter().learn(sentence)) return false;\n        if (posTagger != null && !getPerceptronPOSTagger().learn(sentence)) return false;\n        if (neRecognizer != null && !getPerceptionNERecognizer().learn(sentence)) return false;\n        return true;\n    }",
    "reference_explanation": "\u5728\u7ebf\u5b66\u4e60\n\n@param sentence \u5df2\u5206\u8bcd\u3001\u6807\u597d\u8bcd\u6027\u548c\u547d\u540d\u5b9e\u4f53\u7684\u4eba\u6c11\u65e5\u62a52014\u683c\u5f0f\u7684\u53e5\u5b50\n@return \u662f\u5426\u5b66\u4e60\u6210\u679c\uff08\u5931\u8d25\u7684\u539f\u56e0\u662f\u53e5\u5b50\u683c\u5f0f\u4e0d\u5408\u6cd5\uff09",
    "generated_explanation": ""
  },
  {
    "index": 831,
    "code": "public String get(int x, int y)\n    {\n        if (x < 0) return HEAD + x;\n        if (x >= v.length) return HEAD + \"+\" + (x - v.length + 1);\n\n        return v[x][y];\n    }",
    "reference_explanation": "\u83b7\u53d6\u8868\u4e2d\u67d0\u4e00\u4e2a\u5143\u7d20\n@param x\n@param y\n@return",
    "generated_explanation": ""
  },
  {
    "index": 832,
    "code": "public boolean load(String path)\n    {\n        trie = new DoubleArrayTrie<V>();\n        long start = System.currentTimeMillis();\n        if (loadDat(ByteArray.createByteArray(path + BIN_EXT)))\n        {\n            return true;\n        }\n        TreeMap<String, V> map = new TreeMap<String, V>();\n        try\n        {\n            BufferedReader br = new BufferedReader(new InputStreamReader(IOUtil.newInputStream(path), \"UTF-8\"));\n            String line;\n            while ((line = br.readLine()) != null)\n            {\n                String[] paramArray = line.split(\"\\\\s\");\n                map.put(paramArray[0], createValue(paramArray));\n            }\n            br.close();\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u8bfb\u53d6\" + path + \"\u5931\u8d25\" + e);\n            return false;\n        }\n        onLoaded(map);\n        Set<Map.Entry<String, V>> entrySet = map.entrySet();\n        List<String> keyList = new ArrayList<String>(entrySet.size());\n        List<V> valueList = new ArrayList<V>(entrySet.size());\n        for (Map.Entry<String, V> entry : entrySet)\n        {\n            keyList.add(entry.getKey());\n            valueList.add(entry.getValue());\n        }\n        int resultCode = trie.build(keyList, valueList);\n        if (resultCode != 0)\n        {\n            logger.warning(\"trie\u5efa\u7acb\u5931\u8d25\");\n            return false;\n        }\n        logger.info(path + \"\u52a0\u8f7d\u6210\u529f\uff0c\u8017\u65f6\" + (System.currentTimeMillis() - start) + \"ms\");\n        saveDat(path + BIN_EXT, valueList);\n        return true;\n    }",
    "reference_explanation": "\u4ecetxt\u8def\u5f84\u52a0\u8f7d\n\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 833,
    "code": "protected boolean loadDat(ByteArray byteArray)\n    {\n        V[] valueArray = loadValueArray(byteArray);\n        if (valueArray == null)\n        {\n            return false;\n        }\n        return trie.load(byteArray.getBytes(), byteArray.getOffset(), valueArray);\n    }",
    "reference_explanation": "\u4ecedat\u8def\u5f84\u52a0\u8f7d\n\n@param byteArray\n@return",
    "generated_explanation": ""
  },
  {
    "index": 834,
    "code": "protected boolean saveDat(String path, List<V> valueArray)\n    {\n        try\n        {\n            DataOutputStream out = new DataOutputStream(new BufferedOutputStream(IOUtil.newOutputStream(path)));\n            out.writeInt(valueArray.size());\n            for (V item : valueArray)\n            {\n                saveValue(item, out);\n            }\n            trie.save(out);\n            out.close();\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u4fdd\u5b58\u5931\u8d25\" + TextUtility.exceptionToString(e));\n            return false;\n        }\n        return true;\n    }",
    "reference_explanation": "\u4fdd\u5b58dat\u5230\u8def\u5f84\n\n@param path\n@param valueArray\n@return",
    "generated_explanation": ""
  },
  {
    "index": 835,
    "code": "public static boolean saveObjectTo(Object o, String path)\n    {\n        try\n        {\n            ObjectOutputStream oos = new ObjectOutputStream(IOUtil.newOutputStream(path));\n            oos.writeObject(o);\n            oos.close();\n        }\n        catch (IOException e)\n        {\n            logger.warning(\"\u5728\u4fdd\u5b58\u5bf9\u8c61\" + o + \"\u5230\" + path + \"\u65f6\u53d1\u751f\u5f02\u5e38\" + e);\n            return false;\n        }\n\n        return true;\n    }",
    "reference_explanation": "\u5e8f\u5217\u5316\u5bf9\u8c61\n\n@param o\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 836,
    "code": "public static Object readObjectFrom(String path)\n    {\n        ObjectInputStream ois = null;\n        try\n        {\n            ois = new ObjectInputStream(IOUtil.newInputStream(path));\n            Object o = ois.readObject();\n            ois.close();\n            return o;\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u5728\u4ece\" + path + \"\u8bfb\u53d6\u5bf9\u8c61\u65f6\u53d1\u751f\u5f02\u5e38\" + e);\n        }\n\n        return null;\n    }",
    "reference_explanation": "\u53cd\u5e8f\u5217\u5316\u5bf9\u8c61\n\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 837,
    "code": "public static String readTxt(String path)\n    {\n        if (path == null) return null;\n        try\n        {\n            InputStream in = IOAdapter == null ? new FileInputStream(path) :\n                    IOAdapter.open(path);\n            byte[] fileContent = new byte[in.available()];\n            int read = readBytesFromOtherInputStream(in, fileContent);\n            in.close();\n            // \u5904\u7406 UTF-8 BOM\n            if (read >= 3 && fileContent[0] == -17 && fileContent[1] == -69 && fileContent[2] == -65)\n                return new String(fileContent, 3, fileContent.length - 3, Charset.forName(\"UTF-8\"));\n            return new String(fileContent, Charset.forName(\"UTF-8\"));\n        }\n        catch (FileNotFoundException e)\n        {\n            logger.warning(\"\u627e\u4e0d\u5230\" + path + e);\n            return null;\n        }\n        catch (IOException e)\n        {\n            logger.warning(\"\u8bfb\u53d6\" + path + \"\u53d1\u751fIO\u5f02\u5e38\" + e);\n            return null;\n        }\n    }",
    "reference_explanation": "\u4e00\u6b21\u6027\u8bfb\u5165\u7eaf\u6587\u672c\n\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 838,
    "code": "public static boolean saveTxt(String path, String content)\n    {\n        try\n        {\n            FileChannel fc = new FileOutputStream(path).getChannel();\n            fc.write(ByteBuffer.wrap(content.getBytes()));\n            fc.close();\n        }\n        catch (Exception e)\n        {\n            logger.throwing(\"IOUtil\", \"saveTxt\", e);\n            logger.warning(\"IOUtil saveTxt \u5230\" + path + \"\u5931\u8d25\" + e.toString());\n            return false;\n        }\n        return true;\n    }",
    "reference_explanation": "\u5feb\u901f\u4fdd\u5b58\n\n@param path\n@param content\n@return",
    "generated_explanation": ""
  },
  {
    "index": 839,
    "code": "public static byte[] readBytes(String path)\n    {\n        try\n        {\n            if (IOAdapter == null) return readBytesFromFileInputStream(new FileInputStream(path));\n\n            InputStream is = IOAdapter.open(path);\n            if (is instanceof FileInputStream)\n                return readBytesFromFileInputStream((FileInputStream) is);\n            else\n                return readBytesFromOtherInputStream(is);\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u8bfb\u53d6\" + path + \"\u65f6\u53d1\u751f\u5f02\u5e38\" + e);\n        }\n\n        return null;\n    }",
    "reference_explanation": "\u5c06\u6574\u4e2a\u6587\u4ef6\u8bfb\u53d6\u4e3a\u5b57\u8282\u6570\u7ec4\n\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 840,
    "code": "public static byte[] readBytesFromOtherInputStream(InputStream is) throws IOException\n    {\n        ByteArrayOutputStream data = new ByteArrayOutputStream();\n\n        int readBytes;\n        byte[] buffer = new byte[Math.max(is.available(), 4096)]; // \u6700\u4f4e4KB\u7684\u7f13\u51b2\u533a\n\n        while ((readBytes = is.read(buffer, 0, buffer.length)) != -1)\n        {\n            data.write(buffer, 0, readBytes);\n        }\n\n        data.flush();\n\n        return data.toByteArray();\n    }",
    "reference_explanation": "\u5c06\u975eFileInputStream\u7684\u67d0InputStream\u4e2d\u7684\u5168\u90e8\u6570\u636e\u8bfb\u5165\u5230\u5b57\u8282\u6570\u7ec4\u4e2d\n\n@param is\n@return\n@throws IOException",
    "generated_explanation": ""
  },
  {
    "index": 841,
    "code": "public static int readBytesFromOtherInputStream(InputStream is, byte[] targetArray) throws IOException\n    {\n        assert targetArray != null;\n        if (targetArray.length == 0) return 0;\n        int len;\n        int off = 0;\n        while (off < targetArray.length && (len = is.read(targetArray, off, targetArray.length - off)) != -1)\n        {\n            off += len;\n        }\n        return off;\n    }",
    "reference_explanation": "\u4eceInputStream\u8bfb\u53d6\u6307\u5b9a\u957f\u5ea6\u7684\u5b57\u8282\u51fa\u6765\n@param is \u6d41\n@param targetArray output\n@return \u5b9e\u9645\u8bfb\u53d6\u4e86\u591a\u5c11\u5b57\u8282\uff0c\u8fd4\u56de0\u8868\u793a\u9047\u5230\u4e86\u6587\u4ef6\u5c3e\u90e8\n@throws IOException",
    "generated_explanation": ""
  },
  {
    "index": 842,
    "code": "public static LinkedList<String> readLineListWithLessMemory(String path)\n    {\n        LinkedList<String> result = new LinkedList<String>();\n        String line = null;\n        boolean first = true;\n        try\n        {\n            BufferedReader bw = new BufferedReader(new InputStreamReader(IOUtil.newInputStream(path), \"UTF-8\"));\n            while ((line = bw.readLine()) != null)\n            {\n                if (first)\n                {\n                    first = false;\n                    if (!line.isEmpty() && line.charAt(0) == '\\uFEFF')\n                        line = line.substring(1);\n                }\n                result.add(line);\n            }\n            bw.close();\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u52a0\u8f7d\" + path + \"\u5931\u8d25\uff0c\" + e);\n        }\n\n        return result;\n    }",
    "reference_explanation": "\u7528\u7701\u5185\u5b58\u7684\u65b9\u5f0f\u8bfb\u53d6\u5927\u6587\u4ef6\n\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 843,
    "code": "public static String dirname(String path)\n    {\n        int index = path.lastIndexOf('/');\n        if (index == -1) return path;\n        return path.substring(0, index + 1);\n    }",
    "reference_explanation": "\u83b7\u53d6\u6587\u4ef6\u6240\u5728\u76ee\u5f55\u7684\u8def\u5f84\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 844,
    "code": "public static String removeUTF8BOM(String line)\n    {\n        if (line != null && line.startsWith(\"\\uFEFF\")) // UTF-8 byte order mark (EF BB BF)\n        {\n            line = line.substring(1);\n        }\n        return line;\n    }",
    "reference_explanation": "\u53bb\u9664\u6587\u4ef6\u7b2c\u4e00\u884c\u4e2d\u7684UTF8 BOM<br>\n\u8fd9\u662fJava\u7684bug\uff0c\u4e14\u5b98\u65b9\u4e0d\u4f1a\u4fee\u590d\u3002\u53c2\u8003 https://stackoverflow.com/questions/4897876/reading-utf-8-bom-marker\n@param line \u6587\u4ef6\u7b2c\u4e00\u884c\n@return \u53bb\u9664BOM\u7684\u90e8\u5206",
    "generated_explanation": ""
  },
  {
    "index": 845,
    "code": "public static List<File> fileList(String path)\n    {\n        List<File> fileList = new LinkedList<File>();\n        File folder = new File(path);\n        if (folder.isDirectory())\n            enumerate(folder, fileList);\n        else\n            fileList.add(folder); // \u517c\u5bb9\u8def\u5f84\u4e3a\u6587\u4ef6\u7684\u60c5\u51b5\n        return fileList;\n    }",
    "reference_explanation": "\u9012\u5f52\u904d\u5386\u83b7\u53d6\u76ee\u5f55\u4e0b\u7684\u6240\u6709\u6587\u4ef6\n\n@param path \u6839\u76ee\u5f55\n@return \u6587\u4ef6\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 846,
    "code": "private static void enumerate(File folder, List<File> fileList)\n    {\n        File[] fileArray = folder.listFiles();\n        if (fileArray != null)\n        {\n            for (File file : fileArray)\n            {\n                if (file.isFile() && !file.getName().startsWith(\".\")) // \u8fc7\u6ee4\u9690\u85cf\u6587\u4ef6\n                {\n                    fileList.add(file);\n                }\n                else\n                {\n                    enumerate(file, fileList);\n                }\n            }\n        }\n    }",
    "reference_explanation": "\u9012\u5f52\u904d\u5386\u76ee\u5f55\n\n@param folder   \u76ee\u5f55\n@param fileList \u50a8\u5b58\u6587\u4ef6",
    "generated_explanation": ""
  },
  {
    "index": 847,
    "code": "public static BufferedWriter newBufferedWriter(String path) throws IOException\n    {\n        return new BufferedWriter(new OutputStreamWriter(IOUtil.newOutputStream(path), \"UTF-8\"));\n    }",
    "reference_explanation": "\u521b\u5efa\u4e00\u4e2aBufferedWriter\n\n@param path\n@return\n@throws FileNotFoundException\n@throws UnsupportedEncodingException",
    "generated_explanation": ""
  },
  {
    "index": 848,
    "code": "public static BufferedReader newBufferedReader(String path) throws IOException\n    {\n        return new BufferedReader(new InputStreamReader(IOUtil.newInputStream(path), \"UTF-8\"));\n    }",
    "reference_explanation": "\u521b\u5efa\u4e00\u4e2aBufferedReader\n@param path\n@return\n@throws FileNotFoundException\n@throws UnsupportedEncodingException",
    "generated_explanation": ""
  },
  {
    "index": 849,
    "code": "public static InputStream newInputStream(String path) throws IOException\n    {\n        if (IOAdapter == null) return new FileInputStream(path);\n        return IOAdapter.open(path);\n    }",
    "reference_explanation": "\u521b\u5efa\u8f93\u5165\u6d41\uff08\u7ecf\u8fc7IO\u9002\u914d\u5668\u521b\u5efa\uff09\n@param path\n@return\n@throws IOException",
    "generated_explanation": ""
  },
  {
    "index": 850,
    "code": "public static OutputStream newOutputStream(String path) throws IOException\n    {\n        if (IOAdapter == null) return new FileOutputStream(path);\n        return IOAdapter.create(path);\n    }",
    "reference_explanation": "\u521b\u5efa\u8f93\u51fa\u6d41\uff08\u7ecf\u8fc7IO\u9002\u914d\u5668\u521b\u5efa\uff09\n@param path\n@return\n@throws IOException",
    "generated_explanation": ""
  },
  {
    "index": 851,
    "code": "public static String getSuffix(String name, String delimiter)\n    {\n        return name.substring(name.lastIndexOf(delimiter) + 1);\n    }",
    "reference_explanation": "\u83b7\u53d6\u6700\u540e\u4e00\u4e2a\u5206\u9694\u7b26\u7684\u540e\u7f00\n@param name\n@param delimiter\n@return",
    "generated_explanation": ""
  },
  {
    "index": 852,
    "code": "public static void writeLine(BufferedWriter bw, String... params) throws IOException\n    {\n        for (int i = 0; i < params.length - 1; i++)\n        {\n            bw.write(params[i]);\n            bw.write('\\t');\n        }\n        bw.write(params[params.length - 1]);\n    }",
    "reference_explanation": "\u5199\u6570\u7ec4\uff0c\u7528\u5236\u8868\u7b26\u5206\u5272\n@param bw\n@param params\n@throws IOException",
    "generated_explanation": ""
  },
  {
    "index": 853,
    "code": "public static TreeMap<String, CoreDictionary.Attribute> loadDictionary(String... pathArray) throws IOException\n    {\n        TreeMap<String, CoreDictionary.Attribute> map = new TreeMap<String, CoreDictionary.Attribute>();\n        for (String path : pathArray)\n        {\n            File file = new File(path);\n            String fileName = file.getName();\n            int natureIndex = fileName.lastIndexOf(' ');\n            Nature defaultNature = Nature.n;\n            if (natureIndex > 0)\n            {\n                String natureString = fileName.substring(natureIndex + 1);\n                path = file.getParent() + File.separator + fileName.substring(0, natureIndex);\n                if (natureString.length() > 0 && !natureString.endsWith(\".txt\") && !natureString.endsWith(\".csv\"))\n                {\n                    defaultNature = Nature.create(natureString);\n                }\n            }\n            BufferedReader br = new BufferedReader(new InputStreamReader(IOUtil.newInputStream(path), \"UTF-8\"));\n            loadDictionary(br, map, path.endsWith(\".csv\"), defaultNature);\n        }\n\n        return map;\n    }",
    "reference_explanation": "\u52a0\u8f7d\u8bcd\u5178\uff0c\u8bcd\u5178\u5fc5\u987b\u9075\u5b88HanLP\u6838\u5fc3\u8bcd\u5178\u683c\u5f0f\n@param pathArray \u8bcd\u5178\u8def\u5f84\uff0c\u53ef\u4ee5\u6709\u4efb\u610f\u4e2a\u3002\u6bcf\u4e2a\u8def\u5f84\u652f\u6301\u7528\u7a7a\u683c\u8868\u793a\u9ed8\u8ba4\u8bcd\u6027\uff0c\u6bd4\u5982\u201c\u5168\u56fd\u5730\u540d\u5927\u5168.txt ns\u201d\n@return \u4e00\u4e2a\u50a8\u5b58\u4e86\u8bcd\u6761\u7684map\n@throws IOException \u5f02\u5e38\u8868\u793a\u52a0\u8f7d\u5931\u8d25",
    "generated_explanation": ""
  },
  {
    "index": 854,
    "code": "public static void loadDictionary(BufferedReader br, TreeMap<String, CoreDictionary.Attribute> storage, boolean isCSV, Nature defaultNature) throws IOException\n    {\n        String splitter = \"\\\\s\";\n        if (isCSV)\n        {\n            splitter = \",\";\n        }\n        String line;\n        boolean firstLine = true;\n        while ((line = br.readLine()) != null)\n        {\n            if (firstLine)\n            {\n                line = IOUtil.removeUTF8BOM(line);\n                firstLine = false;\n            }\n            String param[] = line.split(splitter);\n\n            int natureCount = (param.length - 1) / 2;\n            CoreDictionary.Attribute attribute;\n            if (natureCount == 0)\n            {\n                attribute = new CoreDictionary.Attribute(defaultNature);\n            }\n            else\n            {\n                attribute = new CoreDictionary.Attribute(natureCount);\n                for (int i = 0; i < natureCount; ++i)\n                {\n                    attribute.nature[i] = LexiconUtility.convertStringToNature(param[1 + 2 * i]);\n                    attribute.frequency[i] = Integer.parseInt(param[2 + 2 * i]);\n                    attribute.totalFrequency += attribute.frequency[i];\n                }\n            }\n            storage.put(param[0], attribute);\n        }\n        br.close();\n    }",
    "reference_explanation": "\u5c06\u4e00\u4e2aBufferedReader\u4e2d\u7684\u8bcd\u6761\u52a0\u8f7d\u5230\u8bcd\u5178\n@param br \u6e90\n@param storage \u50a8\u5b58\u4f4d\u7f6e\n@throws IOException \u5f02\u5e38\u8868\u793a\u52a0\u8f7d\u5931\u8d25",
    "generated_explanation": ""
  },
  {
    "index": 855,
    "code": "public static boolean isFileExisted(String path)\n    {\n        File file = new File(path);\n        return file.isFile() && file.exists();\n    }",
    "reference_explanation": "\u672c\u5730\u6587\u4ef6\u662f\u5426\u5b58\u5728\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 856,
    "code": "public Edge getEdge(Node from, Node to)\n    {\n        // \u9996\u5148\u5c1d\u8bd5\u8bcd+\u8bcd\n        Attribute attribute = get(from.compiledWord, to.compiledWord);\n        if (attribute == null) attribute = get(from.compiledWord, WordNatureWeightModelMaker.wrapTag(to.label));\n        if (attribute == null) attribute = get(WordNatureWeightModelMaker.wrapTag(from.label), to.compiledWord);\n        if (attribute == null) attribute = get(WordNatureWeightModelMaker.wrapTag(from.label), WordNatureWeightModelMaker.wrapTag(to.label));\n        if (attribute == null)\n        {\n            attribute = Attribute.NULL;\n        }\n        if (HanLP.Config.DEBUG)\n        {\n            System.out.println(from + \" \u5230 \" + to + \" : \" + attribute);\n        }\n        return new Edge(from.id, to.id, attribute.dependencyRelation[0], attribute.p[0]);\n    }",
    "reference_explanation": "\u6253\u5206\n@param from\n@param to\n@return",
    "generated_explanation": ""
  },
  {
    "index": 857,
    "code": "public int add(K key)\n    {\n        int[] f = get(key);\n        if (f == null)\n        {\n            f = new int[]{1};\n            put(key, f);\n        }\n        else ++f[0];\n\n        return f[0];\n    }",
    "reference_explanation": "\u589e\u52a0\u4e00\u4e2a\u8bcd\u7684\u8bcd\u9891\n@param key\n@return",
    "generated_explanation": ""
  },
  {
    "index": 858,
    "code": "public List<Map.Entry<String, Float>> analogy(String A, String B, String C)\n    {\n        return analogy(A, B, C, 10);\n    }",
    "reference_explanation": "\u8fd4\u56de\u8ddf A - B + C \u6700\u76f8\u4f3c\u7684\u8bcd\u8bed,\u6bd4\u5982 \u4e2d\u56fd - \u5317\u4eac + \u4e1c\u4eac = \u65e5\u672c\u3002\u8f93\u5165\u987a\u5e8f\u6309\u7167 \u4e2d\u56fd \u5317\u4eac \u4e1c\u4eac\n\n@param A \u505a\u52a0\u6cd5\u7684\u8bcd\u8bed\n@param B \u505a\u51cf\u6cd5\u7684\u8bcd\u8bed\n@param C \u505a\u52a0\u6cd5\u7684\u8bcd\u8bed\n@return \u4e0e(A - B + C)\u8bed\u4e49\u8ddd\u79bb\u6700\u8fd1\u7684\u8bcd\u8bed\u53ca\u5176\u76f8\u4f3c\u5ea6\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 859,
    "code": "public List<Map.Entry<String, Float>> analogy(String A, String B, String C, int size)\n    {\n        Vector a = storage.get(A);\n        Vector b = storage.get(B);\n        Vector c = storage.get(C);\n        if (a == null || b == null || c == null)\n        {\n            return Collections.emptyList();\n        }\n\n        List<Map.Entry<String, Float>> resultList = nearest(a.minus(b).add(c), size + 3);\n        ListIterator<Map.Entry<String, Float>> listIterator = resultList.listIterator();\n        while (listIterator.hasNext())\n        {\n            String key = listIterator.next().getKey();\n            if (key.equals(A) || key.equals(B) || key.equals(C))\n            {\n                listIterator.remove();\n            }\n        }\n\n        if (resultList.size() > size)\n        {\n            resultList = resultList.subList(0, size);\n        }\n\n        return resultList;\n    }",
    "reference_explanation": "\u8fd4\u56de\u8ddf A - B + C \u6700\u76f8\u4f3c\u7684\u8bcd\u8bed,\u6bd4\u5982 \u4e2d\u56fd - \u5317\u4eac + \u4e1c\u4eac = \u65e5\u672c\u3002\u8f93\u5165\u987a\u5e8f\u6309\u7167 \u4e2d\u56fd \u5317\u4eac \u4e1c\u4eac\n\n@param A    \u505a\u52a0\u6cd5\u7684\u8bcd\u8bed\n@param B    \u505a\u51cf\u6cd5\u7684\u8bcd\u8bed\n@param C    \u505a\u52a0\u6cd5\u7684\u8bcd\u8bed\n@param size topN\u4e2a\n@return \u4e0e(A - B + C)\u8bed\u4e49\u8ddd\u79bb\u6700\u8fd1\u7684\u8bcd\u8bed\u53ca\u5176\u76f8\u4f3c\u5ea6\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 860,
    "code": "private static String[][] resizeArray(String[][] array, int size)\n    {\n        if (array.length == size) return array;\n        String[][] nArray = new String[size][];\n        System.arraycopy(array, 0, nArray, 0, size);\n        return nArray;\n    }",
    "reference_explanation": "\u6570\u7ec4\u51cf\u80a5\uff0c\u539f\u5b50\u5206\u8bcd\u53ef\u80fd\u4f1a\u5bfc\u81f4\u8868\u683c\u6bd4\u539f\u6765\u7684\u77ed\n\n@param array\n@param size\n@return",
    "generated_explanation": ""
  },
  {
    "index": 861,
    "code": "public static List<String> to863(List<Term> termList)\n    {\n        List<String> posTagList = new ArrayList<String>(termList.size());\n        for (Term term : termList)\n        {\n            String posTag = posConverter.get(term.nature.toString());\n            if (posTag == null)\n                posTag = term.nature.toString();\n            posTagList.add(posTag);\n        }\n\n        return posTagList;\n    }",
    "reference_explanation": "\u8f6c\u4e3a863\u6807\u6ce8\u96c6<br>\n863\u8bcd\u6027\u6807\u6ce8\u96c6\uff0c\u5176\u5404\u4e2a\u8bcd\u6027\u542b\u4e49\u5982\u4e0b\u8868\uff1a\n<p>\nTag\tDescription\tExample\tTag\tDescription\tExample\na\tadjective\t\u7f8e\u4e3d\tni\torganization name\t\u4fdd\u9669\u516c\u53f8\nb\tother noun-modifier\t\u5927\u578b, \u897f\u5f0f\tnl\tlocation noun\t\u57ce\u90ca\nc\tconjunction\t\u548c, \u867d\u7136\tns\tgeographical name\t\u5317\u4eac\nd\tadverb\t\u5f88\tnt\ttemporal noun\t\u8fd1\u65e5, \u660e\u4ee3\ne\texclamation\t\u54ce\tnz\tother proper noun\t\u8bfa\u8d1d\u5c14\u5956\ng\tmorpheme\t\u8328, \u7525\to\tonomatopoeia\t\u54d7\u5566\nh\tprefix\t\u963f, \u4f2a\tp\tpreposition\t\u5728, \u628a\ni\tidiom\t\u767e\u82b1\u9f50\u653e\tq\tquantity\t\u4e2a\nj\tabbreviation\t\u516c\u68c0\u6cd5\tr\tpronoun\t\u6211\u4eec\nk\tsuffix\t\u754c, \u7387\tu\tauxiliary\t\u7684, \u5730\nm\tnumber\t\u4e00, \u7b2c\u4e00\tv\tverb\t\u8dd1, \u5b66\u4e60\nn\tgeneral noun\t\u82f9\u679c\twp\tpunctuation\t\uff0c\u3002\uff01\nnd\tdirection noun\t\u53f3\u4fa7\tws\tforeign words\tCPU\nnh\tperson name\t\u675c\u752b, \u6c64\u59c6\tx\tnon-lexeme\t\u8404, \u7ff1\n\n@param termList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 862,
    "code": "public static float evaluate(POSTagger tagger, String corpus)\n    {\n        int correct = 0, total = 0;\n        IOUtil.LineIterator lineIterator = new IOUtil.LineIterator(corpus);\n        for (String line : lineIterator)\n        {\n            Sentence sentence = Sentence.create(line);\n            if (sentence == null) continue;\n            String[][] wordTagArray = sentence.toWordTagArray();\n            String[] prediction = tagger.tag(wordTagArray[0]);\n            assert prediction.length == wordTagArray[1].length;\n            total += prediction.length;\n            for (int i = 0; i < prediction.length; i++)\n            {\n                if (prediction[i].equals(wordTagArray[1][i]))\n                    ++correct;\n            }\n        }\n        if (total == 0) return 0;\n        return correct / (float) total * 100;\n    }",
    "reference_explanation": "\u8bc4\u4f30\u8bcd\u6027\u6807\u6ce8\u5668\u7684\u51c6\u786e\u7387\n\n@param tagger \u8bcd\u6027\u6807\u6ce8\u5668\n@param corpus \u6d4b\u8bd5\u96c6\n@return Accuracy\u767e\u5206\u6bd4",
    "generated_explanation": ""
  },
  {
    "index": 863,
    "code": "public static PairFrequency create(String first, char delimiter ,String second)\n    {\n        PairFrequency pairFrequency = new PairFrequency(first + delimiter + second);\n        pairFrequency.first = first;\n        pairFrequency.delimiter = delimiter;\n        pairFrequency.second = second;\n        return pairFrequency;\n    }",
    "reference_explanation": "\u6784\u9020\u4e00\u4e2apf\n@param first\n@param delimiter\n@param second\n@return",
    "generated_explanation": ""
  },
  {
    "index": 864,
    "code": "final public Vector vector(K key)\n    {\n        Vector vector = storage.get(key);\n        if (vector == null) return null;\n        return vector;\n    }",
    "reference_explanation": "\u83b7\u53d6\u4e00\u4e2a\u952e\u7684\u5411\u91cf\uff08\u952e\u4e0d\u4f1a\u88ab\u9884\u5904\u7406\uff09\n\n@param key \u952e\n@return \u5411\u91cf",
    "generated_explanation": ""
  },
  {
    "index": 865,
    "code": "public float similarity(K what, K with)\n    {\n        Vector vectorWhat = storage.get(what);\n        if (vectorWhat == null)\n        {\n            return -1f;\n        }\n        Vector vectorWith = storage.get(with);\n        if (vectorWith == null)\n        {\n            return -1f;\n        }\n        return vectorWhat.cosineForUnitVector(vectorWith);\n    }",
    "reference_explanation": "\u4f59\u5f26\u76f8\u4f3c\u5ea6\n\n@param what \u4e00\u4e2a\u8bcd\n@param with \u53e6\u4e00\u4e2a\u8bcd\n@return \u4f59\u5f26\u76f8\u4f3c\u5ea6",
    "generated_explanation": ""
  },
  {
    "index": 866,
    "code": "public List<Map.Entry<K, Float>> nearest(K key, int size)\n    {\n        Vector vector = storage.get(key);\n        if (vector == null)\n        {\n            return Collections.emptyList();\n        }\n        return nearest(key, vector, size);\n    }",
    "reference_explanation": "\u67e5\u8be2\u4e0ekey\u6700\u76f8\u4f3c\u7684\u5143\u7d20\n\n@param key  \u952e\n@param size topN\u4e2a\n@return \u952e\u503c\u5bf9\u5217\u8868, \u952e\u662f\u76f8\u4f3c\u8bcd\u8bed, \u503c\u662f\u76f8\u4f3c\u5ea6, \u6309\u76f8\u4f3c\u5ea6\u964d\u5e8f\u6392\u5217",
    "generated_explanation": ""
  },
  {
    "index": 867,
    "code": "public List<Map.Entry<K, Float>> nearest(Vector vector, int size)\n    {\n        MaxHeap<Map.Entry<K, Float>> maxHeap = new MaxHeap<Map.Entry<K, Float>>(size, new Comparator<Map.Entry<K, Float>>()\n        {\n            @Override\n            public int compare(Map.Entry<K, Float> o1, Map.Entry<K, Float> o2)\n            {\n                return o1.getValue().compareTo(o2.getValue());\n            }\n        });\n\n        for (Map.Entry<K, Vector> entry : storage.entrySet())\n        {\n            maxHeap.add(new AbstractMap.SimpleEntry<K, Float>(entry.getKey(), entry.getValue().cosineForUnitVector(vector)));\n        }\n        return maxHeap.toList();\n    }",
    "reference_explanation": "\u83b7\u53d6\u4e0e\u5411\u91cf\u6700\u76f8\u4f3c\u7684\u8bcd\u8bed\n\n@param vector \u5411\u91cf\n@param size   topN\u4e2a\n@return \u952e\u503c\u5bf9\u5217\u8868, \u952e\u662f\u76f8\u4f3c\u8bcd\u8bed, \u503c\u662f\u76f8\u4f3c\u5ea6, \u6309\u76f8\u4f3c\u5ea6\u964d\u5e8f\u6392\u5217",
    "generated_explanation": ""
  },
  {
    "index": 868,
    "code": "public List<Map.Entry<K, Float>> nearest(Vector vector)\n    {\n        return nearest(vector, 10);\n    }",
    "reference_explanation": "\u83b7\u53d6\u4e0e\u5411\u91cf\u6700\u76f8\u4f3c\u7684\u8bcd\u8bed\uff08\u9ed8\u8ba410\u4e2a\uff09\n\n@param vector \u5411\u91cf\n@return \u952e\u503c\u5bf9\u5217\u8868, \u952e\u662f\u76f8\u4f3c\u8bcd\u8bed, \u503c\u662f\u76f8\u4f3c\u5ea6, \u6309\u76f8\u4f3c\u5ea6\u964d\u5e8f\u6392\u5217",
    "generated_explanation": ""
  },
  {
    "index": 869,
    "code": "public List<Map.Entry<K, Float>> nearest(K key)\n    {\n        return nearest(key, 10);\n    }",
    "reference_explanation": "\u67e5\u8be2\u4e0e\u8bcd\u8bed\u6700\u76f8\u4f3c\u7684\u8bcd\u8bed\n\n@param key \u8bcd\u8bed\n@return \u952e\u503c\u5bf9\u5217\u8868, \u952e\u662f\u76f8\u4f3c\u8bcd\u8bed, \u503c\u662f\u76f8\u4f3c\u5ea6, \u6309\u76f8\u4f3c\u5ea6\u964d\u5e8f\u6392\u5217",
    "generated_explanation": ""
  },
  {
    "index": 870,
    "code": "final List<Map.Entry<K, Float>> queryNearest(String query, int size)\n    {\n        if (query == null || query.length() == 0)\n        {\n            return Collections.emptyList();\n        }\n        try\n        {\n            return nearest(query(query), size);\n        }\n        catch (Exception e)\n        {\n            return Collections.emptyList();\n        }\n    }",
    "reference_explanation": "\u6267\u884c\u67e5\u8be2\u6700\u76f8\u4f3c\u7684\u5bf9\u8c61\uff08\u5b50\u7c7b\u901a\u8fc7query\u65b9\u6cd5\u51b3\u5b9a\u5982\u4f55\u89e3\u6790query\uff0c\u7136\u540e\u901a\u8fc7\u6b64\u65b9\u6cd5\u6267\u884c\u67e5\u8be2\uff09\n\n@param query \u67e5\u8be2\u8bed\u53e5\uff08\u6216\u8005\u8bf4\u4e00\u4e2a\u5bf9\u8c61\u7684\u5185\u5bb9\uff09\n@param size  \u9700\u8981\u8fd4\u56de\u524d\u591a\u5c11\u4e2a\u5bf9\u8c61\n@return",
    "generated_explanation": ""
  },
  {
    "index": 871,
    "code": "public int dimension()\n    {\n        if (storage == null || storage.isEmpty())\n        {\n            return 0;\n        }\n        return storage.values().iterator().next().size();\n    }",
    "reference_explanation": "\u6a21\u578b\u4e2d\u7684\u8bcd\u5411\u91cf\u7ef4\u5ea6\n\n@return",
    "generated_explanation": ""
  },
  {
    "index": 872,
    "code": "public final List<Pair<String, Double>> predict(String[] context)\n    {\n        List<Pair<String, Double>> result = new ArrayList<Pair<String, Double>>(outcomeNames.length);\n        double[] p = eval(context);\n        for (int i = 0; i < p.length; ++i)\n        {\n            result.add(new Pair<String, Double>(outcomeNames[i], p[i]));\n        }\n        return result;\n    }",
    "reference_explanation": "\u9884\u6d4b\u5206\u5e03\n\n@param context\n@return",
    "generated_explanation": ""
  },
  {
    "index": 873,
    "code": "public final Pair<String, Double> predictBest(String[] context)\n    {\n        List<Pair<String, Double>> resultList = predict(context);\n        double bestP = -1.0;\n        Pair<String, Double> bestPair = null;\n        for (Pair<String, Double> pair : resultList)\n        {\n            if (pair.getSecond() > bestP)\n            {\n                bestP = pair.getSecond();\n                bestPair = pair;\n            }\n        }\n\n        return bestPair;\n    }",
    "reference_explanation": "\u9884\u6d4b\u6982\u7387\u6700\u9ad8\u7684\u5206\u7c7b\n\n@param context\n@return",
    "generated_explanation": ""
  },
  {
    "index": 874,
    "code": "public final List<Pair<String, Double>> predict(Collection<String> context)\n    {\n        return predict(context.toArray(new String[0]));\n    }",
    "reference_explanation": "\u9884\u6d4b\u5206\u5e03\n\n@param context\n@return",
    "generated_explanation": ""
  },
  {
    "index": 875,
    "code": "public final double[] eval(String[] context, double[] outsums)\n    {\n        assert context != null;\n        int[] scontexts = new int[context.length];\n        for (int i = 0; i < context.length; i++)\n        {\n            Integer ci = pmap.get(context[i]);\n            scontexts[i] = ci == null ? -1 : ci;\n        }\n        prior.logPrior(outsums);\n        return eval(scontexts, outsums, evalParams);\n    }",
    "reference_explanation": "\u9884\u6d4b\u5206\u5e03\n\n@param context \u73af\u5883\n@param outsums \u5148\u9a8c\u5206\u5e03\n@return \u6982\u7387\u6570\u7ec4",
    "generated_explanation": ""
  },
  {
    "index": 876,
    "code": "public static double[] eval(int[] context, double[] prior, EvalParameters model)\n    {\n        Context[] params = model.getParams();\n        int numfeats[] = new int[model.getNumOutcomes()];\n        int[] activeOutcomes;\n        double[] activeParameters;\n        double value = 1;\n        for (int ci = 0; ci < context.length; ci++)\n        {\n            if (context[ci] >= 0)\n            {\n                Context predParams = params[context[ci]];\n                activeOutcomes = predParams.getOutcomes();\n                activeParameters = predParams.getParameters();\n                for (int ai = 0; ai < activeOutcomes.length; ai++)\n                {\n                    int oid = activeOutcomes[ai];\n                    numfeats[oid]++;\n                    prior[oid] += activeParameters[ai] * value;\n                }\n            }\n        }\n\n        double normal = 0.0;\n        for (int oid = 0; oid < model.getNumOutcomes(); oid++)\n        {\n            if (model.getCorrectionParam() != 0)\n            {\n                prior[oid] = Math\n                        .exp(prior[oid]\n                                     * model.getConstantInverse()\n                                     + ((1.0 - ((double) numfeats[oid] / model\n                                .getCorrectionConstant())) * model.getCorrectionParam()));\n            }\n            else\n            {\n                prior[oid] = Math.exp(prior[oid] * model.getConstantInverse());\n            }\n            normal += prior[oid];\n        }\n\n        for (int oid = 0; oid < model.getNumOutcomes(); oid++)\n        {\n            prior[oid] /= normal;\n        }\n        return prior;\n    }",
    "reference_explanation": "\u9884\u6d4b\n@param context \u73af\u5883\n@param prior \u5148\u9a8c\u6982\u7387\n@param model \u7279\u5f81\u51fd\u6570\n@return",
    "generated_explanation": ""
  },
  {
    "index": 877,
    "code": "public static MaxEntModel create(String path)\n    {\n        MaxEntModel m = new MaxEntModel();\n        try\n        {\n            BufferedReader br = new BufferedReader(new InputStreamReader(IOUtil.newInputStream(path), \"UTF-8\"));\n            DataOutputStream out = new DataOutputStream(IOUtil.newOutputStream(path + Predefine.BIN_EXT));\n            br.readLine();  // type\n            m.correctionConstant = Integer.parseInt(br.readLine());  // correctionConstant\n            out.writeInt(m.correctionConstant);\n            m.correctionParam = Double.parseDouble(br.readLine());  // getCorrectionParameter\n            out.writeDouble(m.correctionParam);\n            // label\n            int numOutcomes = Integer.parseInt(br.readLine());\n            out.writeInt(numOutcomes);\n            String[] outcomeLabels = new String[numOutcomes];\n            m.outcomeNames = outcomeLabels;\n            for (int i = 0; i < numOutcomes; i++)\n            {\n                outcomeLabels[i] = br.readLine();\n                TextUtility.writeString(outcomeLabels[i], out);\n            }\n            // pattern\n            int numOCTypes = Integer.parseInt(br.readLine());\n            out.writeInt(numOCTypes);\n            int[][] outcomePatterns = new int[numOCTypes][];\n            for (int i = 0; i < numOCTypes; i++)\n            {\n                StringTokenizer tok = new StringTokenizer(br.readLine(), \" \");\n                int[] infoInts = new int[tok.countTokens()];\n                out.writeInt(infoInts.length);\n                for (int j = 0; tok.hasMoreTokens(); j++)\n                {\n                    infoInts[j] = Integer.parseInt(tok.nextToken());\n                    out.writeInt(infoInts[j]);\n                }\n                outcomePatterns[i] = infoInts;\n            }\n            // feature\n            int NUM_PREDS = Integer.parseInt(br.readLine());\n            out.writeInt(NUM_PREDS);\n            String[] predLabels = new String[NUM_PREDS];\n            m.pmap = new DoubleArrayTrie<Integer>();\n            TreeMap<String, Integer> tmpMap = new TreeMap<String, Integer>();\n            for (int i = 0; i < NUM_PREDS; i++)\n            {\n                predLabels[i] = br.readLine();\n                assert !tmpMap.containsKey(predLabels[i]) : \"\u91cd\u590d\u7684\u952e\uff1a \" + predLabels[i] + \" \u8bf7\u4f7f\u7528 -Dfile.encoding=UTF-8 \u8bad\u7ec3\";\n                TextUtility.writeString(predLabels[i], out);\n                tmpMap.put(predLabels[i], i);\n            }\n            m.pmap.build(tmpMap);\n            for (Map.Entry<String, Integer> entry : tmpMap.entrySet())\n            {\n                out.writeInt(entry.getValue());\n            }\n            m.pmap.save(out);\n            // params\n            Context[] params = new Context[NUM_PREDS];\n            int pid = 0;\n            for (int i = 0; i < outcomePatterns.length; i++)\n            {\n                int[] outcomePattern = new int[outcomePatterns[i].length - 1];\n                for (int k = 1; k < outcomePatterns[i].length; k++)\n                {\n                    outcomePattern[k - 1] = outcomePatterns[i][k];\n                }\n                for (int j = 0; j < outcomePatterns[i][0]; j++)\n                {\n                    double[] contextParameters = new double[outcomePatterns[i].length - 1];\n                    for (int k = 1; k < outcomePatterns[i].length; k++)\n                    {\n                        contextParameters[k - 1] = Double.parseDouble(br.readLine());\n                        out.writeDouble(contextParameters[k - 1]);\n                    }\n                    params[pid] = new Context(outcomePattern, contextParameters);\n                    pid++;\n                }\n            }\n            // prior\n            m.prior = new UniformPrior();\n            m.prior.setLabels(outcomeLabels);\n            // eval\n            m.evalParams = new EvalParameters(params, m.correctionParam, m.correctionConstant, outcomeLabels.length);\n            out.close();\n        }\n        catch (Exception e)\n        {\n            logger.severe(\"\u4ece\" + path + \"\u52a0\u8f7d\u6700\u5927\u71b5\u6a21\u578b\u5931\u8d25\uff01\" + TextUtility.exceptionToString(e));\n            return null;\n        }\n        return m;\n    }",
    "reference_explanation": "\u4ece\u6587\u4ef6\u52a0\u8f7d\uff0c\u540c\u65f6\u7f13\u5b58\u4e3a\u4e8c\u8fdb\u5236\u6587\u4ef6\n@param path\n@return",
    "generated_explanation": ""
  },
  {
    "index": 878,
    "code": "public static MaxEntModel create(ByteArray byteArray)\n    {\n        MaxEntModel m = new MaxEntModel();\n        m.correctionConstant = byteArray.nextInt();  // correctionConstant\n        m.correctionParam = byteArray.nextDouble();  // getCorrectionParameter\n        // label\n        int numOutcomes = byteArray.nextInt();\n        String[] outcomeLabels = new String[numOutcomes];\n        m.outcomeNames = outcomeLabels;\n        for (int i = 0; i < numOutcomes; i++) outcomeLabels[i] = byteArray.nextString();\n        // pattern\n        int numOCTypes = byteArray.nextInt();\n        int[][] outcomePatterns = new int[numOCTypes][];\n        for (int i = 0; i < numOCTypes; i++)\n        {\n            int length = byteArray.nextInt();\n            int[] infoInts = new int[length];\n            for (int j = 0; j < length; j++)\n            {\n                infoInts[j] = byteArray.nextInt();\n            }\n            outcomePatterns[i] = infoInts;\n        }\n        // feature\n        int NUM_PREDS = byteArray.nextInt();\n        String[] predLabels = new String[NUM_PREDS];\n        m.pmap = new DoubleArrayTrie<Integer>();\n        for (int i = 0; i < NUM_PREDS; i++)\n        {\n            predLabels[i] = byteArray.nextString();\n        }\n        Integer[] v = new Integer[NUM_PREDS];\n        for (int i = 0; i < v.length; i++)\n        {\n            v[i] = byteArray.nextInt();\n        }\n        m.pmap.load(byteArray, v);\n        // params\n        Context[] params = new Context[NUM_PREDS];\n        int pid = 0;\n        for (int i = 0; i < outcomePatterns.length; i++)\n        {\n            int[] outcomePattern = new int[outcomePatterns[i].length - 1];\n            for (int k = 1; k < outcomePatterns[i].length; k++)\n            {\n                outcomePattern[k - 1] = outcomePatterns[i][k];\n            }\n            for (int j = 0; j < outcomePatterns[i][0]; j++)\n            {\n                double[] contextParameters = new double[outcomePatterns[i].length - 1];\n                for (int k = 1; k < outcomePatterns[i].length; k++)\n                {\n                    contextParameters[k - 1] = byteArray.nextDouble();\n                }\n                params[pid] = new Context(outcomePattern, contextParameters);\n                pid++;\n            }\n        }\n        // prior\n        m.prior = new UniformPrior();\n        m.prior.setLabels(outcomeLabels);\n        // eval\n        m.evalParams = new EvalParameters(params, m.correctionParam, m.correctionConstant, outcomeLabels.length);\n        return m;\n    }",
    "reference_explanation": "\u4ece\u5b57\u8282\u6d41\u5feb\u901f\u52a0\u8f7d\n@param byteArray\n@return",
    "generated_explanation": ""
  },
  {
    "index": 879,
    "code": "public static MaxEntModel load(String txtPath)\n    {\n        ByteArray byteArray = ByteArray.createByteArray(txtPath + Predefine.BIN_EXT);\n        if (byteArray != null) return create(byteArray);\n        return create(txtPath);\n    }",
    "reference_explanation": "\u52a0\u8f7d\u6700\u5927\u71b5\u6a21\u578b<br>\n\u5982\u679c\u5b58\u5728\u7f13\u5b58\u7684\u8bdd\uff0c\u4f18\u5148\u8bfb\u53d6\u7f13\u5b58\uff0c\u5426\u5219\u8bfb\u53d6txt\uff0c\u5e76\u4e14\u5efa\u7acb\u7f13\u5b58\n@param txtPath txt\u7684\u8def\u5f84\uff0c\u5373\u4f7f\u4e0d\u5b58\u5728.txt\uff0c\u53ea\u5b58\u5728.bin\uff0c\u4e5f\u5e94\u4f20\u5165txt\u7684\u8def\u5f84\uff0c\u65b9\u6cd5\u5185\u90e8\u4f1a\u81ea\u52a8\u52a0.bin\u540e\u7f00\n@return",
    "generated_explanation": ""
  },
  {
    "index": 880,
    "code": "void set_composite_vector()\n    {\n        composite_.clear();\n        for (Document<K> document : documents_)\n        {\n            composite_.add_vector(document.feature());\n        }\n    }",
    "reference_explanation": "Add the vectors of all documents to a composite vector.",
    "generated_explanation": ""
  },
  {
    "index": 881,
    "code": "void clear()\n    {\n        documents_.clear();\n        composite_.clear();\n        if (centroid_ != null)\n            centroid_.clear();\n        if (sectioned_clusters_ != null)\n            sectioned_clusters_.clear();\n        sectioned_gain_ = 0.0;\n    }",
    "reference_explanation": "Clear status.",
    "generated_explanation": ""
  },
  {
    "index": 882,
    "code": "SparseVector centroid_vector()\n    {\n        if (documents_.size() > 0 && composite_.size() == 0)\n            set_composite_vector();\n        centroid_ = (SparseVector) composite_vector().clone();\n        centroid_.normalize();\n        return centroid_;\n    }",
    "reference_explanation": "Get the pointer of a centroid vector.\n\n@return the pointer of a centroid vector",
    "generated_explanation": ""
  },
  {
    "index": 883,
    "code": "void add_document(Document doc)\n    {\n        doc.feature().normalize();\n        documents_.add(doc);\n        composite_.add_vector(doc.feature());\n    }",
    "reference_explanation": "Add a document.\n\n@param doc the pointer of a document object",
    "generated_explanation": ""
  },
  {
    "index": 884,
    "code": "void remove_document(int index)\n    {\n        ListIterator<Document<K>> listIterator = documents_.listIterator(index);\n        Document<K> document = listIterator.next();\n        listIterator.set(null);\n        composite_.sub_vector(document.feature());\n    }",
    "reference_explanation": "Remove a document from this cluster.\n\n@param index the index of vector container of documents",
    "generated_explanation": ""
  },
  {
    "index": 885,
    "code": "void remove_document(Document doc)\n    {\n        for (Document<K> document : documents_)\n        {\n            if (document.equals(doc))\n            {\n                remove_document(doc);\n                return;\n            }\n        }\n    }",
    "reference_explanation": "Remove a document from this cluster.\n\n@param doc the pointer of a document object",
    "generated_explanation": ""
  },
  {
    "index": 886,
    "code": "void refresh()\n    {\n        ListIterator<Document<K>> listIterator = documents_.listIterator();\n        while (listIterator.hasNext())\n        {\n            if (listIterator.next() == null)\n                listIterator.remove();\n        }\n    }",
    "reference_explanation": "Delete removed documents from the internal container.",
    "generated_explanation": ""
  },
  {
    "index": 887,
    "code": "void set_sectioned_gain()\n    {\n        double gain = 0.0f;\n        if (sectioned_gain_ == 0 && sectioned_clusters_.size() > 1)\n        {\n            for (Cluster<K> cluster : sectioned_clusters_)\n            {\n                gain += cluster.composite_vector().norm();\n            }\n            gain -= composite_.norm();\n        }\n        sectioned_gain_ = gain;\n    }",
    "reference_explanation": "Set a gain when the cluster sectioned.",
    "generated_explanation": ""
  },
  {
    "index": 888,
    "code": "void choose_smartly(int ndocs, List<Document> docs)\n    {\n        int siz = size();\n        double[] closest = new double[siz];\n        if (siz < ndocs)\n            ndocs = siz;\n        int index, count = 0;\n\n        index = random.nextInt(siz);  // initial center\n        docs.add(documents_.get(index));\n        ++count;\n        double potential = 0.0;\n        for (int i = 0; i < documents_.size(); i++)\n        {\n            double dist = 1.0 - SparseVector.inner_product(documents_.get(i).feature(), documents_.get(index).feature());\n            potential += dist;\n            closest[i] = dist;\n        }\n\n        // choose each center\n        while (count < ndocs)\n        {\n            double randval = random.nextDouble() * potential;\n\n            for (index = 0; index < documents_.size(); index++)\n            {\n                double dist = closest[index];\n                if (randval <= dist)\n                    break;\n                randval -= dist;\n            }\n            if (index == documents_.size())\n                index--;\n            docs.add(documents_.get(index));\n            ++count;\n\n            double new_potential = 0.0;\n            for (int i = 0; i < documents_.size(); i++)\n            {\n                double dist = 1.0 - SparseVector.inner_product(documents_.get(i).feature(), documents_.get(index).feature());\n                double min = closest[i];\n                if (dist < min)\n                {\n                    closest[i] = dist;\n                    min = dist;\n                }\n                new_potential += min;\n            }\n            potential = new_potential;\n        }\n    }",
    "reference_explanation": "\u9009\u53d6\u521d\u59cb\u8d28\u5fc3\n\n@param ndocs \u8d28\u5fc3\u6570\u91cf\n@param docs  \u8f93\u51fa\u5230\u8be5\u5217\u8868\u4e2d",
    "generated_explanation": ""
  },
  {
    "index": 889,
    "code": "void section(int nclusters)\n    {\n        if (size() < nclusters)\n            return;\n\n        sectioned_clusters_ = new ArrayList<Cluster<K>>(nclusters);\n        List<Document> centroids = new ArrayList<Document>(nclusters);\n        // choose_randomly(nclusters, centroids);\n        choose_smartly(nclusters, centroids);\n        for (int i = 0; i < centroids.size(); i++)\n        {\n            Cluster<K> cluster = new Cluster<K>();\n            sectioned_clusters_.add(cluster);\n        }\n\n        for (Document<K> d : documents_)\n        {\n            double max_similarity = -1.0;\n            int max_index = 0;\n            for (int j = 0; j < centroids.size(); j++)\n            {\n                double similarity = SparseVector.inner_product(d.feature(), centroids.get(j).feature());\n                if (max_similarity < similarity)\n                {\n                    max_similarity = similarity;\n                    max_index = j;\n                }\n            }\n            sectioned_clusters_.get(max_index).add_document(d);\n        }\n    }",
    "reference_explanation": "\u5c06\u672c\u7c07\u5212\u5206\u4e3anclusters\u4e2a\u7c07\n\n@param nclusters",
    "generated_explanation": ""
  },
  {
    "index": 890,
    "code": "public static String extractGivenName(String name)\n    {\n        if (name.length() <= 2)\n            return \"_\" + name.substring(name.length() - 1);\n        else\n            return name.substring(name.length() - 2);\n\n    }",
    "reference_explanation": "\u53bb\u6389\u59d3\u6c0f\uff0c\u622a\u53d6\u4e2d\u56fd\u4eba\u540d\u4e2d\u7684\u540d\u5b57\n\n@param name \u59d3\u540d\n@return \u540d",
    "generated_explanation": ""
  },
  {
    "index": 891,
    "code": "public static void parsePattern(List<NT> ntList, List<Vertex> vertexList, final WordNet wordNetOptimum, final WordNet wordNetAll)\n    {\n//        ListIterator<Vertex> listIterator = vertexList.listIterator();\n        StringBuilder sbPattern = new StringBuilder(ntList.size());\n        for (NT nt : ntList)\n        {\n            sbPattern.append(nt.toString());\n        }\n        String pattern = sbPattern.toString();\n        final Vertex[] wordArray = vertexList.toArray(new Vertex[0]);\n        trie.parseText(pattern, new AhoCorasickDoubleArrayTrie.IHit<String>()\n        {\n            @Override\n            public void hit(int begin, int end, String keyword)\n            {\n                StringBuilder sbName = new StringBuilder();\n                for (int i = begin; i < end; ++i)\n                {\n                    sbName.append(wordArray[i].realWord);\n                }\n                String name = sbName.toString();\n                // \u5bf9\u4e00\u4e9bbad case\u505a\u51fa\u8c03\u6574\n                if (isBadCase(name)) return;\n\n                // \u6b63\u5f0f\u7b97\u5b83\u662f\u4e00\u4e2a\u540d\u5b57\n                if (HanLP.Config.DEBUG)\n                {\n                    System.out.printf(\"\u8bc6\u522b\u51fa\u673a\u6784\u540d\uff1a%s %s\\n\", name, keyword);\n                }\n                int offset = 0;\n                for (int i = 0; i < begin; ++i)\n                {\n                    offset += wordArray[i].realWord.length();\n                }\n                wordNetOptimum.insert(offset, new Vertex(Predefine.TAG_GROUP, name, ATTRIBUTE, WORD_ID), wordNetAll);\n            }\n        });\n    }",
    "reference_explanation": "\u6a21\u5f0f\u5339\u914d\n\n@param ntList         \u786e\u5b9a\u7684\u6807\u6ce8\u5e8f\u5217\n@param vertexList     \u539f\u59cb\u7684\u672a\u52a0\u89d2\u8272\u6807\u6ce8\u7684\u5e8f\u5217\n@param wordNetOptimum \u5f85\u4f18\u5316\u7684\u56fe\n@param wordNetAll",
    "generated_explanation": ""
  },
  {
    "index": 892,
    "code": "public static void normalizeExp(Map<String, Double> predictionScores)\n    {\n        Set<Map.Entry<String, Double>> entrySet = predictionScores.entrySet();\n        double max = Double.NEGATIVE_INFINITY;\n        for (Map.Entry<String, Double> entry : entrySet)\n        {\n            max = Math.max(max, entry.getValue());\n        }\n\n        double sum = 0.0;\n        //\u901a\u8fc7\u51cf\u53bb\u6700\u5927\u503c\u9632\u6b62\u6d6e\u70b9\u6570\u6ea2\u51fa\n        for (Map.Entry<String, Double> entry : entrySet)\n        {\n            Double value = Math.exp(entry.getValue() - max);\n            entry.setValue(value);\n\n            sum += value;\n        }\n\n        if (sum != 0.0)\n        {\n            for (Map.Entry<String, Double> entry : entrySet)\n            {\n                predictionScores.put(entry.getKey(), entry.getValue() / sum);\n            }\n        }\n    }",
    "reference_explanation": "\u4f7f\u7528log-sum-exp\u6280\u5de7\u6765\u5f52\u4e00\u5316\u4e00\u7ec4\u5bf9\u6570\u503c\n\n@param predictionScores",
    "generated_explanation": ""
  },
  {
    "index": 893,
    "code": "public static double calculateWeight(Vertex from, Vertex to)\n    {\n        int frequency = from.getAttribute().totalFrequency;\n        if (frequency == 0)\n        {\n            frequency = 1;  // \u9632\u6b62\u53d1\u751f\u9664\u96f6\u9519\u8bef\n        }\n//        int nTwoWordsFreq = BiGramDictionary.getBiFrequency(from.word, to.word);\n        int nTwoWordsFreq = CoreBiGramTableDictionary.getBiFrequency(from.wordID, to.wordID);\n        double value = -Math.log(dSmoothingPara * frequency / (MAX_FREQUENCY) + (1 - dSmoothingPara) * ((1 - dTemp) * nTwoWordsFreq / frequency + dTemp));\n        if (value < 0.0)\n        {\n            value = -value;\n        }\n//        logger.info(String.format(\"%5s frequency:%6d, %s nTwoWordsFreq:%3d, weight:%.2f\", from.word, frequency, from.word + \"@\" + to.word, nTwoWordsFreq, value));\n        return value;\n    }",
    "reference_explanation": "\u4ece\u4e00\u4e2a\u8bcd\u5230\u53e6\u4e00\u4e2a\u8bcd\u7684\u8bcd\u7684\u82b1\u8d39\n\n@param from \u524d\u9762\u7684\u8bcd\n@param to   \u540e\u9762\u7684\u8bcd\n@return \u5206\u6570",
    "generated_explanation": ""
  },
  {
    "index": 894,
    "code": "public static <TERM> Map<TERM, Double> tf(Collection<TERM> document, TfType type)\n    {\n        Map<TERM, Double> tf = new HashMap<TERM, Double>();\n        for (TERM term : document)\n        {\n            Double f = tf.get(term);\n            if (f == null) f = 0.0;\n            tf.put(term, f + 1);\n        }\n        if (type != TfType.NATURAL)\n        {\n            for (TERM term : tf.keySet())\n            {\n                switch (type)\n                {\n                    case LOGARITHM:\n                        tf.put(term, 1 + Math.log(tf.get(term)));\n                        break;\n                    case BOOLEAN:\n                        tf.put(term, tf.get(term) == 0.0 ? 0.0 : 1.0);\n                        break;\n                }\n            }\n        }\n        return tf;\n    }",
    "reference_explanation": "\u5355\u6587\u6863\u8bcd\u9891\n\n@param document \u8bcd\u888b\n@param type     \u8bcd\u9891\u8ba1\u7b97\u65b9\u5f0f\n@param <TERM>   \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u5305\u542b\u8bcd\u9891\u7684Map",
    "generated_explanation": ""
  },
  {
    "index": 895,
    "code": "public static <TERM> Map<TERM, Double> tf(Collection<TERM> document)\n    {\n        return tf(document, TfType.NATURAL);\n    }",
    "reference_explanation": "\u5355\u6587\u6863\u8bcd\u9891\n\n@param document \u8bcd\u888b\n@param <TERM>   \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u5305\u542b\u8bcd\u9891\u7684Map",
    "generated_explanation": ""
  },
  {
    "index": 896,
    "code": "public static <TERM> Iterable<Map<TERM, Double>> tfs(Iterable<Collection<TERM>> documents, TfType type)\n    {\n        List<Map<TERM, Double>> tfs = new ArrayList<Map<TERM, Double>>();\n        for (Collection<TERM> document : documents)\n        {\n            tfs.add(tf(document, type));\n        }\n        return tfs;\n    }",
    "reference_explanation": "\u591a\u6587\u6863\u8bcd\u9891\n\n@param documents \u591a\u4e2a\u6587\u6863\uff0c\u6bcf\u4e2a\u6587\u6863\u90fd\u662f\u4e00\u4e2a\u8bcd\u888b\n@param type      \u8bcd\u9891\u8ba1\u7b97\u65b9\u5f0f\n@param <TERM>    \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u5305\u542b\u8bcd\u9891\u7684Map\u7684\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 897,
    "code": "public static <TERM> Iterable<Map<TERM, Double>> tfs(Iterable<Collection<TERM>> documents)\n    {\n        return tfs(documents, TfType.NATURAL);\n    }",
    "reference_explanation": "\u591a\u6587\u6863\u8bcd\u9891\n\n@param documents \u591a\u4e2a\u6587\u6863\uff0c\u6bcf\u4e2a\u6587\u6863\u90fd\u662f\u4e00\u4e2a\u8bcd\u888b\n@param <TERM>    \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u5305\u542b\u8bcd\u9891\u7684Map\u7684\u5217\u8868",
    "generated_explanation": ""
  },
  {
    "index": 898,
    "code": "public static <TERM> Map<TERM, Double> idf(Iterable<Iterable<TERM>> documentVocabularies,\n                                               boolean smooth, boolean addOne)\n    {\n        Map<TERM, Integer> df = new HashMap<TERM, Integer>();\n        int d = smooth ? 1 : 0;\n        int a = addOne ? 1 : 0;\n        int n = d;\n        for (Iterable<TERM> documentVocabulary : documentVocabularies)\n        {\n            n += 1;\n            for (TERM term : documentVocabulary)\n            {\n                Integer t = df.get(term);\n                if (t == null) t = d;\n                df.put(term, t + 1);\n            }\n        }\n        Map<TERM, Double> idf = new HashMap<TERM, Double>();\n        for (Map.Entry<TERM, Integer> e : df.entrySet())\n        {\n            TERM term = e.getKey();\n            double f = e.getValue();\n            idf.put(term, Math.log(n / f) + a);\n        }\n        return idf;\n    }",
    "reference_explanation": "\u4e00\u7cfb\u5217\u6587\u6863\u7684\u5012\u6392\u8bcd\u9891\n\n@param documentVocabularies \u8bcd\u8868\n@param smooth               \u5e73\u6ed1\u53c2\u6570\uff0c\u89c6\u4f5c\u989d\u5916\u6709\u4e00\u4e2a\u6587\u6863\uff0c\u8be5\u6587\u6863\u542b\u6709smooth\u4e2a\u6bcf\u4e2a\u8bcd\u8bed\n@param addOne               tf-idf\u52a0\u4e00\u5e73\u6ed1\n@param <TERM>               \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u8bcd\u8bed->\u5012\u6392\u6587\u6863\u7684Map",
    "generated_explanation": ""
  },
  {
    "index": 899,
    "code": "public static <TERM> Map<TERM, Double> idf(Iterable<Iterable<TERM>> documentVocabularies)\n    {\n        return idf(documentVocabularies, true, true);\n    }",
    "reference_explanation": "\u5e73\u6ed1\u5904\u7406\u540e\u7684\u4e00\u7cfb\u5217\u6587\u6863\u7684\u5012\u6392\u8bcd\u9891\n\n@param documentVocabularies \u8bcd\u8868\n@param <TERM>               \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u8bcd\u8bed->\u5012\u6392\u6587\u6863\u7684Map",
    "generated_explanation": ""
  },
  {
    "index": 900,
    "code": "public static <TERM> Map<TERM, Double> tfIdf(Map<TERM, Double> tf, Map<TERM, Double> idf,\n                                                 Normalization normalization)\n    {\n        Map<TERM, Double> tfIdf = new HashMap<TERM, Double>();\n        for (TERM term : tf.keySet())\n        {\n            Double TF = tf.get(term);\n            if (TF == null) TF = 1.;\n            Double IDF = idf.get(term);\n            if (IDF == null) IDF = 1.;\n            tfIdf.put(term, TF * IDF);\n        }\n        if (normalization == Normalization.COSINE)\n        {\n            double n = 0.0;\n            for (double x : tfIdf.values())\n            {\n                n += x * x;\n            }\n            n = Math.sqrt(n);\n\n            for (TERM term : tfIdf.keySet())\n            {\n                tfIdf.put(term, tfIdf.get(term) / n);\n            }\n        }\n        return tfIdf;\n    }",
    "reference_explanation": "\u8ba1\u7b97\u6587\u6863\u7684tf-idf\n\n@param tf            \u8bcd\u9891\n@param idf           \u5012\u6392\u9891\u7387\n@param normalization \u6b63\u89c4\u5316\n@param <TERM>        \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u8bcd\u8bed->tf-idf\u7684Map",
    "generated_explanation": ""
  },
  {
    "index": 901,
    "code": "public static <TERM> Map<TERM, Double> tfIdf(Map<TERM, Double> tf, Map<TERM, Double> idf)\n    {\n        return tfIdf(tf, idf, Normalization.NONE);\n    }",
    "reference_explanation": "\u8ba1\u7b97\u6587\u6863\u7684tf-idf\uff08\u4e0d\u6b63\u89c4\u5316\uff09\n\n@param tf     \u8bcd\u9891\n@param idf    \u5012\u6392\u9891\u7387\n@param <TERM> \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u8bcd\u8bed->tf-idf\u7684Map",
    "generated_explanation": ""
  },
  {
    "index": 902,
    "code": "public static <TERM> Map<TERM, Double> idfFromTfs(Iterable<Map<TERM, Double>> tfs, boolean smooth, boolean addOne)\n    {\n        return idf(new KeySetIterable<TERM, Double>(tfs), smooth, addOne);\n    }",
    "reference_explanation": "\u4ece\u8bcd\u9891\u96c6\u5408\u5efa\u7acb\u5012\u6392\u9891\u7387\n\n@param tfs    \u6b21\u54c1\u96c6\u5408\n@param smooth \u5e73\u6ed1\u53c2\u6570\uff0c\u89c6\u4f5c\u989d\u5916\u6709\u4e00\u4e2a\u6587\u6863\uff0c\u8be5\u6587\u6863\u542b\u6709smooth\u4e2a\u6bcf\u4e2a\u8bcd\u8bed\n@param addOne tf-idf\u52a0\u4e00\u5e73\u6ed1\n@param <TERM> \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u8bcd\u8bed->\u5012\u6392\u6587\u6863\u7684Map",
    "generated_explanation": ""
  },
  {
    "index": 903,
    "code": "public static <TERM> Map<TERM, Double> idfFromTfs(Iterable<Map<TERM, Double>> tfs)\n    {\n        return idfFromTfs(tfs, true, true);\n    }",
    "reference_explanation": "\u4ece\u8bcd\u9891\u96c6\u5408\u5efa\u7acb\u5012\u6392\u9891\u7387\uff08\u9ed8\u8ba4\u5e73\u6ed1\u8bcd\u9891\uff0c\u4e14\u52a0\u4e00\u5e73\u6ed1tf-idf\uff09\n\n@param tfs    \u6b21\u54c1\u96c6\u5408\n@param <TERM> \u8bcd\u8bed\u7c7b\u578b\n@return \u4e00\u4e2a\u8bcd\u8bed->\u5012\u6392\u6587\u6863\u7684Map",
    "generated_explanation": ""
  },
  {
    "index": 904,
    "code": "public static Pinyin[] convert2Array(String complexText, boolean removeTone)\n    {\n        return PinyinUtil.convertList2Array(convert(complexText, removeTone));\n    }",
    "reference_explanation": "\u5c06\u62fc\u97f3\u6587\u672c\u8f6c\u5316\u4e3a\u5b8c\u6574\u7684\u62fc\u97f3\uff0c\u652f\u6301\u6c49\u82f1\u6df7\u5408\u7684\u6742\u4e71\u6587\u672c\uff0c\u6ce8\u610f\u5982\u679c\u6df7\u7528\u62fc\u97f3\u548c\u8f93\u5165\u6cd5\u5934\u7684\u8bdd\uff0c\u5e76\u4e0d\u4f1a\u6709\u591a\u9ad8\u7684\u51c6\u786e\u7387\uff0c\u58f0\u8c03\u4e5f\u4e0d\u4f1a\u51c6\u7684\n@param complexText\n@return",
    "generated_explanation": ""
  },
  {
    "index": 905,
    "code": "public static List<Pinyin> convert(String complexText)\n    {\n        List<Pinyin> pinyinList = new LinkedList<Pinyin>();\n        Collection<Token> tokenize = trie.tokenize(complexText);\n//        System.out.println(tokenize);\n        for (Token token : tokenize)\n        {\n            String fragment = token.getFragment();\n            if (token.isMatch())\n            {\n                // \u662f\u62fc\u97f3\u6216\u62fc\u97f3\u7684\u4e00\u90e8\u5206\uff0c\u7528map\u8f6c\n                pinyinList.add(convertSingle(fragment));\n            }\n            else\n            {\n                pinyinList.addAll(PinyinDictionary.convertToPinyin(fragment));\n            }\n        }\n\n        return pinyinList;\n    }",
    "reference_explanation": "\u6587\u672c\u8f6c\u62fc\u97f3\n@param complexText\n@return",
    "generated_explanation": ""
  },
  {
    "index": 906,
    "code": "public static List<Pinyin> convert(String complexText, boolean removeTone)\n    {\n        List<Pinyin> pinyinList = convert(complexText);\n        if (removeTone)\n        {\n            makeToneToTheSame(pinyinList);\n        }\n        return pinyinList;\n    }",
    "reference_explanation": "\u6587\u672c\u8f6c\u62fc\u97f3\n@param complexText \u6587\u672c\n@param removeTone \u662f\u5426\u5c06\u6240\u6709\u7684\u97f3\u8c03\u90fd\u540c\u4e00\u5316\n@return",
    "generated_explanation": ""
  },
  {
    "index": 907,
    "code": "public static Pair<List<Pinyin>, List<Boolean>> convert2Pair(String complexText, boolean removeTone)\n    {\n        List<Pinyin> pinyinList = new LinkedList<Pinyin>();\n        List<Boolean> booleanList = new LinkedList<Boolean>();\n        Collection<Token> tokenize = trie.tokenize(complexText);\n        for (Token token : tokenize)\n        {\n            String fragment = token.getFragment();\n            if (token.isMatch())\n            {\n                // \u662f\u62fc\u97f3\u6216\u62fc\u97f3\u7684\u4e00\u90e8\u5206\uff0c\u7528map\u8f6c\n                Pinyin pinyin = convertSingle(fragment);\n                pinyinList.add(pinyin);\n                if (fragment.length() == pinyin.getPinyinWithoutTone().length())\n                {\n                    booleanList.add(true);\n                }\n                else\n                {\n                    booleanList.add(false);\n                }\n            }\n            else\n            {\n                List<Pinyin> pinyinListFragment = PinyinDictionary.convertToPinyin(fragment);\n                pinyinList.addAll(pinyinListFragment);\n                for (int i = 0; i < pinyinListFragment.size(); ++i)\n                {\n                    booleanList.add(true);\n                }\n            }\n        }\n        makeToneToTheSame(pinyinList);\n        return new Pair<List<Pinyin>, List<Boolean>>(pinyinList, booleanList);\n    }",
    "reference_explanation": "\u5c06\u6df7\u5408\u6587\u672c\u8f6c\u4e3a\u62fc\u97f3\n@param complexText \u6df7\u5408\u6c49\u5b57\u3001\u62fc\u97f3\u3001\u8f93\u5165\u6cd5\u5934\u7684\u6587\u672c\uff0c\u6bd4\u5982\u201c\u98de\u6d41zh\u4e0bsqianch\u201d\n@param removeTone\n@return \u4e00\u4e2a\u952e\u503c\u5bf9\uff0c\u952e\u4e3a\u62fc\u97f3\u5217\u8868\uff0c\u503c\u4e3a\u7c7b\u578b\uff08true\u8868\u793a\u8fd9\u662f\u4e00\u4e2a\u62fc\u97f3\uff0cfalse\u8868\u793a\u8fd9\u662f\u4e00\u4e2a\u8f93\u5165\u6cd5\u5934\uff09",
    "generated_explanation": ""
  },
  {
    "index": 908,
    "code": "public static Pinyin convertSingle(String single)\n    {\n        Pinyin pinyin = map.get(single);\n        if (pinyin == null) return Pinyin.none5;\n\n        return pinyin;\n    }",
    "reference_explanation": "\u5c06\u5355\u4e2a\u97f3\u8282\u8f6c\u4e3a\u62fc\u97f3\n@param single\n@return",
    "generated_explanation": ""
  },
  {
    "index": 909,
    "code": "public static List<Pinyin> makeToneToTheSame(List<Pinyin> pinyinList)\n    {\n        ListIterator<Pinyin> listIterator = pinyinList.listIterator();\n        while (listIterator.hasNext())\n        {\n            listIterator.set(convert2Tone5(listIterator.next()));\n        }\n\n        return pinyinList;\n    }",
    "reference_explanation": "\u5c06\u6240\u6709\u97f3\u8c03\u90fd\u8f6c\u4e3a1\n@param pinyinList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 910,
    "code": "public IDependencyParser setDeprelTranslater(String deprelTranslatorPath)\n    {\n        deprelTranslater = GlobalObjectPool.get(deprelTranslatorPath);\n        if (deprelTranslater != null) return this;\n\n        IOUtil.LineIterator iterator = new IOUtil.LineIterator(deprelTranslatorPath);\n        deprelTranslater = new TreeMap<String, String>();\n        while (iterator.hasNext())\n        {\n            String[] args = iterator.next().split(\"\\\\s\");\n            deprelTranslater.put(args[0], args[1]);\n        }\n        if (deprelTranslater.size() == 0)\n        {\n            deprelTranslater = null;\n        }\n        GlobalObjectPool.put(deprelTranslatorPath, deprelTranslater);\n\n        return this;\n    }",
    "reference_explanation": "\u8bbe\u7f6e\u6620\u5c04\u8868\n@param deprelTranslatorPath \u6620\u5c04\u8868\u8def\u5f84\n@return",
    "generated_explanation": ""
  },
  {
    "index": 911,
    "code": "public void add(String word)\n    {\n        word = reverse(word);\n        trie.put(word, word.length());\n    }",
    "reference_explanation": "\u6dfb\u52a0\u4e00\u4e2a\u8bcd\u8bed\n@param word",
    "generated_explanation": ""
  },
  {
    "index": 912,
    "code": "public int get(String suffix)\n    {\n        suffix = reverse(suffix);\n        Integer length = trie.get(suffix);\n        if (length == null) return 0;\n\n        return length;\n    }",
    "reference_explanation": "\u67e5\u627e\u662f\u5426\u6709\u8be5\u540e\u7f00\n@param suffix\n@return",
    "generated_explanation": ""
  },
  {
    "index": 913,
    "code": "public boolean endsWith(String word)\n    {\n        word = reverse(word);\n        return trie.commonPrefixSearchWithValue(word).size() > 0;\n    }",
    "reference_explanation": "\u8bcd\u8bed\u662f\u5426\u4ee5\u8be5\u8bcd\u5178\u4e2d\u7684\u67d0\u4e2a\u5355\u8bcd\u7ed3\u5c3e\n@param word\n@return",
    "generated_explanation": ""
  },
  {
    "index": 914,
    "code": "public int getLongestSuffixLength(String word)\n    {\n        word = reverse(word);\n        LinkedList<Map.Entry<String, Integer>> suffixList = trie.commonPrefixSearchWithValue(word);\n        if (suffixList.size() == 0) return 0;\n        return suffixList.getLast().getValue();\n    }",
    "reference_explanation": "\u83b7\u53d6\u6700\u957f\u7684\u540e\u7f00\n@param word\n@return",
    "generated_explanation": ""
  },
  {
    "index": 915,
    "code": "public Set<Map.Entry<String, Integer>> entrySet()\n    {\n        Set<Map.Entry<String, Integer>> treeSet = new LinkedHashSet<Map.Entry<String, Integer>>();\n        for (Map.Entry<String, Integer> entry : trie.entrySet())\n        {\n            treeSet.add(new AbstractMap.SimpleEntry<String, Integer>(reverse(entry.getKey()), entry.getValue()));\n        }\n\n        return treeSet;\n    }",
    "reference_explanation": "\u952e\u503c\u5bf9\n@return",
    "generated_explanation": ""
  },
  {
    "index": 916,
    "code": "public static CoreDictionary.Attribute getAttribute(String word)\n    {\n        CoreDictionary.Attribute attribute = CoreDictionary.get(word);\n        if (attribute != null) return attribute;\n        return CustomDictionary.get(word);\n    }",
    "reference_explanation": "\u4eceHanLP\u7684\u8bcd\u5e93\u4e2d\u63d0\u53d6\u67d0\u4e2a\u5355\u8bcd\u7684\u5c5e\u6027\uff08\u5305\u62ec\u6838\u5fc3\u8bcd\u5178\u548c\u7528\u6237\u8bcd\u5178\uff09\n\n@param word \u5355\u8bcd\n@return \u5305\u542b\u8bcd\u6027\u4e0e\u9891\u6b21\u7684\u4fe1\u606f",
    "generated_explanation": ""
  },
  {
    "index": 917,
    "code": "public static int getFrequency(String word)\n    {\n        CoreDictionary.Attribute attribute = getAttribute(word);\n        if (attribute == null) return 0;\n        return attribute.totalFrequency;\n    }",
    "reference_explanation": "\u83b7\u53d6\u67d0\u4e2a\u5355\u8bcd\u7684\u8bcd\u9891\n@param word\n@return",
    "generated_explanation": ""
  },
  {
    "index": 918,
    "code": "public static boolean setAttribute(String word, CoreDictionary.Attribute attribute)\n    {\n        if (attribute == null) return false;\n\n        if (CoreDictionary.trie.set(word, attribute)) return true;\n        if (CustomDictionary.dat.set(word, attribute)) return true;\n        if (CustomDictionary.trie == null)\n        {\n            CustomDictionary.add(word);\n        }\n        CustomDictionary.trie.put(word, attribute);\n        return true;\n    }",
    "reference_explanation": "\u8bbe\u7f6e\u67d0\u4e2a\u5355\u8bcd\u7684\u5c5e\u6027\n@param word\n@param attribute\n@return",
    "generated_explanation": ""
  },
  {
    "index": 919,
    "code": "public static boolean setAttribute(String word, Nature... natures)\n    {\n        if (natures == null) return false;\n\n        CoreDictionary.Attribute attribute = new CoreDictionary.Attribute(natures, new int[natures.length]);\n        Arrays.fill(attribute.frequency, 1);\n\n        return setAttribute(word, attribute);\n    }",
    "reference_explanation": "\u8bbe\u7f6e\u67d0\u4e2a\u5355\u8bcd\u7684\u5c5e\u6027\n@param word\n@param natures\n@return",
    "generated_explanation": ""
  },
  {
    "index": 920,
    "code": "public static boolean setAttribute(String word, String... natures)\n    {\n        if (natures == null) return false;\n\n        Nature[] natureArray = new Nature[natures.length];\n        for (int i = 0; i < natureArray.length; i++)\n        {\n            natureArray[i] = Nature.create(natures[i]);\n        }\n\n        return setAttribute(word, natureArray);\n    }",
    "reference_explanation": "\u8bbe\u7f6e\u67d0\u4e2a\u5355\u8bcd\u7684\u5c5e\u6027\n@param word\n@param natures\n@return",
    "generated_explanation": ""
  },
  {
    "index": 921,
    "code": "public static boolean setAttribute(String word, String natureWithFrequency)\n    {\n        CoreDictionary.Attribute attribute = CoreDictionary.Attribute.create(natureWithFrequency);\n        return setAttribute(word, attribute);\n    }",
    "reference_explanation": "\u8bbe\u7f6e\u67d0\u4e2a\u5355\u8bcd\u7684\u5c5e\u6027\n@param word\n@param natureWithFrequency\n@return",
    "generated_explanation": ""
  },
  {
    "index": 922,
    "code": "public static Nature convertStringToNature(String name, LinkedHashSet<Nature> customNatureCollector)\n    {\n        Nature nature = Nature.fromString(name);\n        if (nature == null)\n        {\n            nature = Nature.create(name);\n            if (customNatureCollector != null) customNatureCollector.add(nature);\n        }\n        return nature;\n    }",
    "reference_explanation": "\u5c06\u5b57\u7b26\u4e32\u8bcd\u6027\u8f6c\u4e3aEnum\u8bcd\u6027\n@param name \u8bcd\u6027\u540d\u79f0\n@param customNatureCollector \u4e00\u4e2a\u6536\u96c6\u96c6\u5408\n@return \u8f6c\u6362\u7ed3\u679c",
    "generated_explanation": ""
  },
  {
    "index": 923,
    "code": "public void addEmit(int keyword)\n    {\n        if (this.emits == null)\n        {\n            this.emits = new TreeSet<Integer>(Collections.reverseOrder());\n        }\n        this.emits.add(keyword);\n    }",
    "reference_explanation": "\u6dfb\u52a0\u4e00\u4e2a\u5339\u914d\u5230\u7684\u6a21\u5f0f\u4e32\uff08\u8fd9\u4e2a\u72b6\u6001\u5bf9\u5e94\u7740\u8fd9\u4e2a\u6a21\u5f0f\u4e32)\n@param keyword",
    "generated_explanation": ""
  },
  {
    "index": 924,
    "code": "public Integer getLargestValueId()\n    {\n        if (emits == null || emits.size() == 0) return null;\n\n        return emits.iterator().next();\n    }",
    "reference_explanation": "\u83b7\u53d6\u6700\u5927\u7684\u503c\n@return",
    "generated_explanation": ""
  },
  {
    "index": 925,
    "code": "public void setFailure(State failState, int fail[])\n    {\n        this.failure = failState;\n        fail[index] = failState.index;\n    }",
    "reference_explanation": "\u8bbe\u7f6efailure\u72b6\u6001\n@param failState",
    "generated_explanation": ""
  },
  {
    "index": 926,
    "code": "private State nextState(Character character, boolean ignoreRootState)\n    {\n        State nextState = this.success.get(character);\n        if (!ignoreRootState && nextState == null && this.depth == 0)\n        {\n            nextState = this;\n        }\n        return nextState;\n    }",
    "reference_explanation": "\u8f6c\u79fb\u5230\u4e0b\u4e00\u4e2a\u72b6\u6001\n@param character \u5e0c\u671b\u6309\u6b64\u5b57\u7b26\u8f6c\u79fb\n@param ignoreRootState \u662f\u5426\u5ffd\u7565\u6839\u8282\u70b9\uff0c\u5982\u679c\u662f\u6839\u8282\u70b9\u81ea\u5df1\u8c03\u7528\u5219\u5e94\u8be5\u662ftrue\uff0c\u5426\u5219\u4e3afalse\n@return \u8f6c\u79fb\u7ed3\u679c",
    "generated_explanation": ""
  },
  {
    "index": 927,
    "code": "public static IWord compile(IWord word)\n    {\n        String label = word.getLabel();\n        if (\"nr\".equals(label)) return new Word(word.getValue(), TAG_PEOPLE);\n        else if (\"m\".equals(label) || \"mq\".equals(label)) return new Word(word.getValue(), TAG_NUMBER);\n        else if (\"t\".equals(label)) return new Word(word.getValue(), TAG_TIME);\n        else if (\"ns\".equals(label)) return new Word(word.getValue(), TAG_PLACE);\n//        switch (word.getLabel())\n//        {\n//            case \"nr\":\n//                return new Word(word.getValue(), TAG_PEOPLE);\n//            case \"m\":\n//            case \"mq\":\n//                return new Word(word.getValue(), TAG_NUMBER);\n//            case \"t\":\n//                return new Word(word.getValue(), TAG_TIME);\n//            case \"ns\":\n//                return new Word(word.getValue(), TAG_TIME);\n//        }\n\n        return word;\n    }",
    "reference_explanation": "\u7f16\u8bd1\u5355\u8bcd\n\n@param word\n@return",
    "generated_explanation": ""
  },
  {
    "index": 928,
    "code": "public static List<List<IWord>> convert2CompatibleList(List<List<Word>> simpleSentenceList)\n    {\n        List<List<IWord>> compatibleList = new LinkedList<List<IWord>>();\n        for (List<Word> wordList : simpleSentenceList)\n        {\n            compatibleList.add(new LinkedList<IWord>(wordList));\n        }\n        return compatibleList;\n    }",
    "reference_explanation": "\u5c06word\u5217\u8868\u8f6c\u4e3a\u517c\u5bb9\u7684IWord\u5217\u8868\n\n@param simpleSentenceList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 929,
    "code": "public static List<Term> segment(String text)\n    {\n        List<Term> termList = new LinkedList<Term>();\n        Matcher matcher = WEB_URL.matcher(text);\n        int begin = 0;\n        int end;\n        while (matcher.find())\n        {\n            end = matcher.start();\n            termList.addAll(SEGMENT.seg(text.substring(begin, end)));\n            termList.add(new Term(matcher.group(), Nature.xu));\n            begin = matcher.end();\n        }\n        if (begin < text.length()) termList.addAll(SEGMENT.seg(text.substring(begin)));\n\n        return termList;\n    }",
    "reference_explanation": "\u5206\u8bcd\n@param text \u6587\u672c\n@return \u5206\u8bcd\u7ed3\u679c",
    "generated_explanation": ""
  },
  {
    "index": 930,
    "code": "public static List<String> convertPinyinList2TonePinyinList(List<Pinyin> pinyinList)\n    {\n        List<String> tonePinyinList = new ArrayList<String>(pinyinList.size());\n        for (Pinyin pinyin : pinyinList)\n        {\n            tonePinyinList.add(pinyin.getPinyinWithToneMark());\n        }\n\n        return tonePinyinList;\n    }",
    "reference_explanation": "\u8f6c\u6362List<Pinyin> pinyinList\u5230List<String>\uff0c\u5176\u4e2d\u7684String\u4e3a\u5e26\u58f0\u8c03\u7b26\u53f7\u5f62\u5f0f\n@param pinyinList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 931,
    "code": "public void set(int index, float value)\n    {\n        if (index < offset + array.length && index >= offset)\n        {\n            array[index - offset] += value;\n        }\n        else if (index < offset)\n        {  //expand from left\n            int gap = offset - index;\n            int newSize = gap + array.length;\n            float[] newArray = new float[newSize];\n            newArray[0] = value;\n            for (int i = 0; i < array.length; i++)\n            {\n                newArray[gap + i] = array[i];\n            }\n            this.offset = index;\n            this.array = newArray;\n        }\n        else\n        {\n            int gap = index - (array.length + offset - 1);\n            int newSize = array.length + gap;\n            float[] newArray = new float[newSize];\n            newArray[newSize - 1] = value;\n            for (int i = 0; i < array.length; i++)\n            {\n                newArray[i] = array[i];\n            }\n            this.array = newArray;\n        }\n    }",
    "reference_explanation": "\u5c06index\u5904\u7684\u5143\u7d20\u8bbe\u7f6e\u4e3avalue\n\n@param index\n@param value",
    "generated_explanation": ""
  },
  {
    "index": 932,
    "code": "public static String get(String fromWord, String fromPos, String toWord, String toPos)\n    {\n        String dependency = get(fromWord + \"@\" + toWord);\n        if (dependency == null) dependency = get(fromWord + \"@\" + WordNatureWeightModelMaker.wrapTag(toPos));\n        if (dependency == null) dependency = get(WordNatureWeightModelMaker.wrapTag(fromPos) + \"@\" + toWord);\n        if (dependency == null) dependency = get(WordNatureWeightModelMaker.wrapTag(fromPos) + \"@\" + WordNatureWeightModelMaker.wrapTag(toPos));\n        if (dependency == null) dependency = \"\u672a\u77e5\";\n\n        return dependency;\n    }",
    "reference_explanation": "\u83b7\u53d6\u4e00\u4e2a\u8bcd\u548c\u53e6\u4e00\u4e2a\u8bcd\u6700\u53ef\u80fd\u7684\u4f9d\u5b58\u5173\u7cfb\n@param fromWord\n@param fromPos\n@param toWord\n@param toPos\n@return",
    "generated_explanation": ""
  },
  {
    "index": 933,
    "code": "public List<String> getKeywords(String document, int size)\n    {\n        return getKeywords(defaultSegment.seg(document), size);\n    }",
    "reference_explanation": "\u63d0\u53d6\u5173\u952e\u8bcd\n\n@param document \u5173\u952e\u8bcd\n@param size     \u9700\u8981\u51e0\u4e2a\u5173\u952e\u8bcd\n@return",
    "generated_explanation": ""
  },
  {
    "index": 934,
    "code": "public void read(LineHandler handler, int size) throws Exception\n    {\n        File rootFile = new File(root);\n        File[] files;\n        if (rootFile.isDirectory())\n        {\n            files = rootFile.listFiles(new FileFilter()\n            {\n                @Override\n                public boolean accept(File pathname)\n                {\n                    return pathname.isFile() && !pathname.getName().endsWith(\".bin\");\n                }\n            });\n            if (files == null)\n            {\n                if (rootFile.isFile())\n                    files = new File[]{rootFile};\n                else return;\n            }\n        }\n        else\n        {\n            files = new File[]{rootFile};\n        }\n\n        int n = 0;\n        int totalAddress = 0;\n        long start = System.currentTimeMillis();\n        for (File file : files)\n        {\n            if (size-- == 0) break;\n            if (file.isDirectory()) continue;\n            if (verbose) System.out.printf(\"\u6b63\u5728\u5904\u7406%s, %d / %d\\n\", file.getName(), ++n, files.length);\n            IOUtil.LineIterator lineIterator = new IOUtil.LineIterator(file.getAbsolutePath());\n            while (lineIterator.hasNext())\n            {\n                ++totalAddress;\n                String line = lineIterator.next();\n                if (line.length() == 0) continue;\n                handler.handle(line);\n            }\n        }\n        handler.done();\n        if (verbose) System.out.printf(\"\u5904\u7406\u4e86 %.2f \u4e07\u884c\uff0c\u82b1\u8d39\u4e86 %.2f min\\n\", totalAddress / 10000.0, (System.currentTimeMillis() - start) / 1000.0 / 60.0);\n    }",
    "reference_explanation": "\u8bfb\u53d6\n@param handler \u5904\u7406\u903b\u8f91\n@param size \u8bfb\u53d6\u591a\u5c11\u4e2a\u6587\u4ef6\n@throws Exception",
    "generated_explanation": ""
  },
  {
    "index": 935,
    "code": "public static List<String> parseOrExit(Object target, String[] args)\n    {\n        try\n        {\n            return parse(target, args);\n        }\n        catch (IllegalArgumentException e)\n        {\n            System.err.println(e.getMessage());\n            Args.usage(target);\n            System.exit(1);\n            throw e;\n        }\n    }",
    "reference_explanation": "A convenience method for parsing and automatically producing error messages.\n\n@param target Either an instance or a class\n@param args   The arguments you want to parse and populate\n@return The list of arguments that were not consumed",
    "generated_explanation": ""
  },
  {
    "index": 936,
    "code": "public static ValueCreator byStaticMethodInvocation(final Class<?> compatibleType, final String methodName)\n    {\n        return new ValueCreator()\n        {\n            public Object createValue(Class<?> type, String value)\n            {\n                Object v = null;\n                if (compatibleType.isAssignableFrom(type))\n                {\n                    try\n                    {\n                        Method m = type.getMethod(methodName, String.class);\n                        return m.invoke(null, value);\n                    }\n                    catch (NoSuchMethodException e)\n                    {\n                        // ignore\n                    }\n                    catch (Exception e)\n                    {\n                        throw new IllegalArgumentException(String.format(\"could not invoke %s#%s to create an obejct from %s\", type.toString(), methodName, value));\n                    }\n                }\n                return v;\n            }\n        };\n    }",
    "reference_explanation": "Creates a {@link ValueCreator} object able to create object assignable from given type,\nusing a static one arg method which name is the the given one taking a String object as parameter\n\n@param compatibleType the base assignable for which this object will try to invoke the given method\n@param methodName     the name of the one arg method taking a String as parameter that will be used to built a new value\n@return null if the object could not be created, the value otherwise",
    "generated_explanation": ""
  },
  {
    "index": 937,
    "code": "public static List<EnumItem<NR>> roleObserve(List<Vertex> wordSegResult)\n    {\n        List<EnumItem<NR>> tagList = new LinkedList<EnumItem<NR>>();\n        Iterator<Vertex> iterator = wordSegResult.iterator();\n        iterator.next();\n        tagList.add(new EnumItem<NR>(NR.A, NR.K)); //  \u59cb##\u59cb A K\n        while (iterator.hasNext())\n        {\n            Vertex vertex = iterator.next();\n            EnumItem<NR> nrEnumItem = PersonDictionary.dictionary.get(vertex.realWord);\n            if (nrEnumItem == null)\n            {\n                Nature nature = vertex.guessNature();\n                if (nature == nr)\n                {\n                    // \u6709\u4e9b\u53cc\u540d\u5b9e\u9645\u4e0a\u53ef\u4ee5\u6784\u6210\u66f4\u957f\u7684\u4e09\u540d\n                    if (vertex.getAttribute().totalFrequency <= 1000 && vertex.realWord.length() == 2)\n                    {\n                        nrEnumItem = new EnumItem<NR>();\n                        nrEnumItem.labelMap.put(NR.X, 2); // \u8ba4\u4e3a\u662f\u4e09\u5b57\u4eba\u540d\u524d2\u4e2a\u5b57=\u53cc\u5b57\u4eba\u540d\u7684\u53ef\u80fd\u6027\u66f4\u9ad8\n                        nrEnumItem.labelMap.put(NR.G, 1);\n                    }\n                    else\n                        nrEnumItem = new EnumItem<NR>(NR.A, PersonDictionary.transformMatrixDictionary.getTotalFrequency(NR.A));\n                }\n                else if (nature == nnt)\n                {\n                    // \u59d3+\u804c\u4f4d\n                    nrEnumItem = new EnumItem<NR>(NR.G, NR.K);\n                }\n                else\n                {\n                    nrEnumItem = new EnumItem<NR>(NR.A, PersonDictionary.transformMatrixDictionary.getTotalFrequency(NR.A));\n                }\n            }\n            tagList.add(nrEnumItem);\n        }\n        return tagList;\n    }",
    "reference_explanation": "\u89d2\u8272\u89c2\u5bdf(\u4ece\u6a21\u578b\u4e2d\u52a0\u8f7d\u6240\u6709\u8bcd\u8bed\u5bf9\u5e94\u7684\u6240\u6709\u89d2\u8272,\u5141\u8bb8\u8fdb\u884c\u4e00\u4e9b\u89c4\u5219\u8865\u5145)\n@param wordSegResult \u7c97\u5206\u7ed3\u679c\n@return",
    "generated_explanation": ""
  },
  {
    "index": 938,
    "code": "public static List<NR> viterbiCompute(List<EnumItem<NR>> roleTagList)\n    {\n        return Viterbi.computeEnum(roleTagList, PersonDictionary.transformMatrixDictionary);\n    }",
    "reference_explanation": "\u7ef4\u7279\u6bd4\u7b97\u6cd5\u6c42\u89e3\u6700\u4f18\u6807\u7b7e\n@param roleTagList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 939,
    "code": "public static List<NR> viterbiComputeSimply(List<EnumItem<NR>> roleTagList)\n    {\n        return Viterbi.computeEnumSimply(roleTagList, PersonDictionary.transformMatrixDictionary);\n    }",
    "reference_explanation": "\u7b80\u5316\u7684\"\u7ef4\u7279\u6bd4\u7b97\u6cd5\"\u6c42\u89e3\u6700\u4f18\u6807\u7b7e\n@param roleTagList\n@return",
    "generated_explanation": ""
  },
  {
    "index": 940,
    "code": "public static <V> LinkedList<ResultTerm<V>> segment(String text, AhoCorasickDoubleArrayTrie<V> trie)\n    {\n        return segment(text.toCharArray(), trie);\n    }",
    "reference_explanation": "\u6700\u957f\u5206\u8bcd\uff0c\u5408\u5e76\u672a\u77e5\u8bed\u7d20\n@param text \u6587\u672c\n@param trie \u81ea\u52a8\u673a\n@param <V> \u7c7b\u578b\n@return \u7ed3\u679c\u94fe\u8868",
    "generated_explanation": ""
  },
  {
    "index": 941,
    "code": "public static <V> LinkedList<ResultTerm<V>> segment(final char[] charArray, AhoCorasickDoubleArrayTrie<V> trie)\n    {\n        LinkedList<ResultTerm<V>> termList = new LinkedList<ResultTerm<V>>();\n        final ResultTerm<V>[] wordNet = new ResultTerm[charArray.length];\n        trie.parseText(charArray, new AhoCorasickDoubleArrayTrie.IHit<V>()\n        {\n            @Override\n            public void hit(int begin, int end, V value)\n            {\n                if (wordNet[begin] == null || wordNet[begin].word.length() < end - begin)\n                {\n                    wordNet[begin] = new ResultTerm<V>(new String(charArray, begin, end - begin), value, begin);\n                }\n            }\n        });\n        for (int i = 0; i < charArray.length;)\n        {\n            if (wordNet[i] == null)\n            {\n                StringBuilder sbTerm = new StringBuilder();\n                int offset = i;\n                while (i < charArray.length && wordNet[i] == null)\n                {\n                    sbTerm.append(charArray[i]);\n                    ++i;\n                }\n                termList.add(new ResultTerm<V>(sbTerm.toString(), null, offset));\n            }\n            else\n            {\n                termList.add(wordNet[i]);\n                i += wordNet[i].word.length();\n            }\n        }\n        return termList;\n    }",
    "reference_explanation": "\u6700\u957f\u5206\u8bcd\uff0c\u5408\u5e76\u672a\u77e5\u8bed\u7d20\n@param charArray \u6587\u672c\n@param trie \u81ea\u52a8\u673a\n@param <V> \u7c7b\u578b\n@return \u7ed3\u679c\u94fe\u8868",
    "generated_explanation": ""
  },
  {
    "index": 942,
    "code": "public static <V> LinkedList<ResultTerm<V>> segmentReverseOrder(final char[] charArray, AhoCorasickDoubleArrayTrie<V> trie)\n    {\n        LinkedList<ResultTerm<V>> termList = new LinkedList<ResultTerm<V>>();\n        final ResultTerm<V>[] wordNet = new ResultTerm[charArray.length + 1];\n        trie.parseText(charArray, new AhoCorasickDoubleArrayTrie.IHit<V>()\n        {\n            @Override\n            public void hit(int begin, int end, V value)\n            {\n                if (wordNet[end] == null || wordNet[end].word.length() < end - begin)\n                {\n                    wordNet[end] = new ResultTerm<V>(new String(charArray, begin, end - begin), value, begin);\n                }\n            }\n        });\n        for (int i = charArray.length; i > 0;)\n        {\n            if (wordNet[i] == null)\n            {\n                StringBuilder sbTerm = new StringBuilder();\n                int offset = i - 1;\n                byte preCharType = CharType.get(charArray[offset]);\n                while (i > 0 && wordNet[i] == null && CharType.get(charArray[i - 1]) == preCharType)\n                {\n                    sbTerm.append(charArray[i - 1]);\n                    preCharType = CharType.get(charArray[i - 1]);\n                    --i;\n                }\n                termList.addFirst(new ResultTerm<V>(sbTerm.reverse().toString(), null, offset));\n            }\n            else\n            {\n                termList.addFirst(wordNet[i]);\n                i -= wordNet[i].word.length();\n            }\n        }\n        return termList;\n    }",
    "reference_explanation": "\u9006\u5411\u6700\u957f\u5206\u8bcd\uff0c\u5408\u5e76\u672a\u77e5\u8bed\u7d20\n@param charArray \u6587\u672c\n@param trie \u81ea\u52a8\u673a\n@param <V> \u7c7b\u578b\n@return \u7ed3\u679c\u94fe\u8868",
    "generated_explanation": ""
  },
  {
    "index": 943,
    "code": "void resize(int size, byte value)\n    {\n        if (size > _capacity)\n        {\n            resizeBuf(size);\n        }\n        while (_size < size)\n        {\n            _buf[_size++] = value;\n        }\n    }",
    "reference_explanation": "\u91cd\u8bbe\u5927\u5c0f\uff0c\u5e76\u4e14\u5728\u672b\u5c3e\u52a0\u4e00\u4e2a\u503c\n@param size \u5927\u5c0f\n@param value \u503c",
    "generated_explanation": ""
  },
  {
    "index": 944,
    "code": "private void resizeBuf(int size)\n    {\n        int capacity;\n        if (size >= _capacity * 2)\n        {\n            capacity = size;\n        }\n        else\n        {\n            capacity = 1;\n            while (capacity < size)\n            {\n                capacity <<= 1;\n            }\n        }\n        byte[] buf = new byte[capacity];\n        if (_size > 0)\n        {\n            System.arraycopy(_buf, 0, buf, 0, _size);\n        }\n        _buf = buf;\n        _capacity = capacity;\n    }",
    "reference_explanation": "\u8bbe\u7f6e\u7f13\u51b2\u533a\u5927\u5c0f\n@param size \u5927\u5c0f",
    "generated_explanation": ""
  },
  {
    "index": 945,
    "code": "public static boolean loadMainDictionary(String mainPath, String path[], DoubleArrayTrie<CoreDictionary.Attribute> dat, boolean isCache)\n    {\n        logger.info(\"\u81ea\u5b9a\u4e49\u8bcd\u5178\u5f00\u59cb\u52a0\u8f7d:\" + mainPath);\n        if (loadDat(mainPath, dat)) return true;\n        TreeMap<String, CoreDictionary.Attribute> map = new TreeMap<String, CoreDictionary.Attribute>();\n        LinkedHashSet<Nature> customNatureCollector = new LinkedHashSet<Nature>();\n        try\n        {\n            //String path[] = HanLP.Config.CustomDictionaryPath;\n            for (String p : path)\n            {\n                Nature defaultNature = Nature.n;\n                File file = new File(p);\n                String fileName = file.getName();\n                int cut = fileName.lastIndexOf(' ');\n                if (cut > 0)\n                {\n                    // \u6709\u9ed8\u8ba4\u8bcd\u6027\n                    String nature = fileName.substring(cut + 1);\n                    p = file.getParent() + File.separator + fileName.substring(0, cut);\n                    try\n                    {\n                        defaultNature = LexiconUtility.convertStringToNature(nature, customNatureCollector);\n                    }\n                    catch (Exception e)\n                    {\n                        logger.severe(\"\u914d\u7f6e\u6587\u4ef6\u3010\" + p + \"\u3011\u5199\u9519\u4e86\uff01\" + e);\n                        continue;\n                    }\n                }\n                logger.info(\"\u4ee5\u9ed8\u8ba4\u8bcd\u6027[\" + defaultNature + \"]\u52a0\u8f7d\u81ea\u5b9a\u4e49\u8bcd\u5178\" + p + \"\u4e2d\u2026\u2026\");\n                boolean success = load(p, defaultNature, map, customNatureCollector);\n                if (!success) logger.warning(\"\u5931\u8d25\uff1a\" + p);\n            }\n            if (map.size() == 0)\n            {\n                logger.warning(\"\u6ca1\u6709\u52a0\u8f7d\u5230\u4efb\u4f55\u8bcd\u6761\");\n                map.put(Predefine.TAG_OTHER, null);     // \u5f53\u4f5c\u7a7a\u767d\u5360\u4f4d\u7b26\n            }\n            logger.info(\"\u6b63\u5728\u6784\u5efaDoubleArrayTrie\u2026\u2026\");\n            dat.build(map);\n            if (isCache)\n            {\n                // \u7f13\u5b58\u6210dat\u6587\u4ef6\uff0c\u4e0b\u6b21\u52a0\u8f7d\u4f1a\u5feb\u5f88\u591a\n                logger.info(\"\u6b63\u5728\u7f13\u5b58\u8bcd\u5178\u4e3adat\u6587\u4ef6\u2026\u2026\");\n                // \u7f13\u5b58\u503c\u6587\u4ef6\n                List<CoreDictionary.Attribute> attributeList = new LinkedList<CoreDictionary.Attribute>();\n                for (Map.Entry<String, CoreDictionary.Attribute> entry : map.entrySet())\n                {\n                    attributeList.add(entry.getValue());\n                }\n                DataOutputStream out = new DataOutputStream(new BufferedOutputStream(IOUtil.newOutputStream(mainPath + Predefine.BIN_EXT)));\n                // \u7f13\u5b58\u7528\u6237\u8bcd\u6027\n                if (customNatureCollector.isEmpty()) // \u70ed\u66f4\u65b0\n                {\n                    for (int i = Nature.begin.ordinal() + 1; i < Nature.values().length; ++i)\n                    {\n                        customNatureCollector.add(Nature.values()[i]);\n                    }\n                }\n                IOUtil.writeCustomNature(out, customNatureCollector);\n                // \u7f13\u5b58\u6b63\u6587\n                out.writeInt(attributeList.size());\n                for (CoreDictionary.Attribute attribute : attributeList)\n                {\n                    attribute.save(out);\n                }\n                dat.save(out);\n                out.close();\n            }\n        }\n        catch (FileNotFoundException e)\n        {\n            logger.severe(\"\u81ea\u5b9a\u4e49\u8bcd\u5178\" + mainPath + \"\u4e0d\u5b58\u5728\uff01\" + e);\n            return false;\n        }\n        catch (IOException e)\n        {\n            logger.severe(\"\u81ea\u5b9a\u4e49\u8bcd\u5178\" + mainPath + \"\u8bfb\u53d6\u9519\u8bef\uff01\" + e);\n            return false;\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u81ea\u5b9a\u4e49\u8bcd\u5178\" + mainPath + \"\u7f13\u5b58\u5931\u8d25\uff01\\n\" + TextUtility.exceptionToString(e));\n        }\n        return true;\n    }",
    "reference_explanation": "\u52a0\u8f7d\u8bcd\u5178\n@param mainPath \u7f13\u5b58\u6587\u4ef6\u6587\u4ef6\u540d\n@param path \u81ea\u5b9a\u4e49\u8bcd\u5178\n@param isCache \u662f\u5426\u7f13\u5b58\u7ed3\u679c",
    "generated_explanation": ""
  },
  {
    "index": 946,
    "code": "public static boolean load(String path, Nature defaultNature, TreeMap<String, CoreDictionary.Attribute> map, LinkedHashSet<Nature> customNatureCollector)\n    {\n        try\n        {\n            String splitter = \"\\\\s\";\n            if (path.endsWith(\".csv\"))\n            {\n                splitter = \",\";\n            }\n            BufferedReader br = new BufferedReader(new InputStreamReader(IOUtil.newInputStream(path), \"UTF-8\"));\n            String line;\n            boolean firstLine = true;\n            while ((line = br.readLine()) != null)\n            {\n                if (firstLine)\n                {\n                    line = IOUtil.removeUTF8BOM(line);\n                    firstLine = false;\n                }\n                String[] param = line.split(splitter);\n                if (param[0].length() == 0) continue;   // \u6392\u9664\u7a7a\u884c\n                if (HanLP.Config.Normalization) param[0] = CharTable.convert(param[0]); // \u6b63\u89c4\u5316\n\n                int natureCount = (param.length - 1) / 2;\n                CoreDictionary.Attribute attribute;\n                if (natureCount == 0)\n                {\n                    attribute = new CoreDictionary.Attribute(defaultNature);\n                }\n                else\n                {\n                    attribute = new CoreDictionary.Attribute(natureCount);\n                    for (int i = 0; i < natureCount; ++i)\n                    {\n                        attribute.nature[i] = LexiconUtility.convertStringToNature(param[1 + 2 * i], customNatureCollector);\n                        attribute.frequency[i] = Integer.parseInt(param[2 + 2 * i]);\n                        attribute.totalFrequency += attribute.frequency[i];\n                    }\n                }\n//                if (updateAttributeIfExist(param[0], attribute, map, rewriteTable)) continue;\n                map.put(param[0], attribute);\n            }\n            br.close();\n        }\n        catch (Exception e)\n        {\n            logger.severe(\"\u81ea\u5b9a\u4e49\u8bcd\u5178\" + path + \"\u8bfb\u53d6\u9519\u8bef\uff01\" + e);\n            return false;\n        }\n\n        return true;\n    }",
    "reference_explanation": "\u52a0\u8f7d\u7528\u6237\u8bcd\u5178\uff08\u8ffd\u52a0\uff09\n\n@param path          \u8bcd\u5178\u8def\u5f84\n@param defaultNature \u9ed8\u8ba4\u8bcd\u6027\n@param customNatureCollector \u6536\u96c6\u7528\u6237\u8bcd\u6027\n@return",
    "generated_explanation": ""
  },
  {
    "index": 947,
    "code": "private static boolean updateAttributeIfExist(String key, CoreDictionary.Attribute attribute, TreeMap<String, CoreDictionary.Attribute> map, TreeMap<Integer, CoreDictionary.Attribute> rewriteTable)\n    {\n        int wordID = CoreDictionary.getWordID(key);\n        CoreDictionary.Attribute attributeExisted;\n        if (wordID != -1)\n        {\n            attributeExisted = CoreDictionary.get(wordID);\n            attributeExisted.nature = attribute.nature;\n            attributeExisted.frequency = attribute.frequency;\n            attributeExisted.totalFrequency = attribute.totalFrequency;\n            // \u6536\u96c6\u8be5\u8986\u5199\n            rewriteTable.put(wordID, attribute);\n            return true;\n        }\n\n        attributeExisted = map.get(key);\n        if (attributeExisted != null)\n        {\n            attributeExisted.nature = attribute.nature;\n            attributeExisted.frequency = attribute.frequency;\n            attributeExisted.totalFrequency = attribute.totalFrequency;\n            return true;\n        }\n\n        return false;\n    }",
    "reference_explanation": "\u5982\u679c\u5df2\u7ecf\u5b58\u5728\u8be5\u8bcd\u6761,\u76f4\u63a5\u66f4\u65b0\u8be5\u8bcd\u6761\u7684\u5c5e\u6027\n@param key \u8bcd\u8bed\n@param attribute \u8bcd\u8bed\u7684\u5c5e\u6027\n@param map \u52a0\u8f7d\u671f\u95f4\u7684map\n@param rewriteTable\n@return \u662f\u5426\u66f4\u65b0\u4e86",
    "generated_explanation": ""
  },
  {
    "index": 948,
    "code": "public static boolean add(String word, String natureWithFrequency)\n    {\n        if (contains(word)) return false;\n        return insert(word, natureWithFrequency);\n    }",
    "reference_explanation": "\u5f80\u81ea\u5b9a\u4e49\u8bcd\u5178\u4e2d\u63d2\u5165\u4e00\u4e2a\u65b0\u8bcd\uff08\u975e\u8986\u76d6\u6a21\u5f0f\uff09<br>\n\u52a8\u6001\u589e\u5220\u4e0d\u4f1a\u6301\u4e45\u5316\u5230\u8bcd\u5178\u6587\u4ef6\n\n@param word                \u65b0\u8bcd \u5982\u201c\u88f8\u5a5a\u201d\n@param natureWithFrequency \u8bcd\u6027\u548c\u5176\u5bf9\u5e94\u7684\u9891\u6b21\uff0c\u6bd4\u5982\u201cnz 1 v 2\u201d\uff0cnull\u65f6\u8868\u793a\u201cnz 1\u201d\n@return \u662f\u5426\u63d2\u5165\u6210\u529f\uff08\u5931\u8d25\u7684\u539f\u56e0\u53ef\u80fd\u662f\u4e0d\u8986\u76d6\u3001natureWithFrequency\u6709\u95ee\u9898\u7b49\uff0c\u540e\u8005\u53ef\u4ee5\u901a\u8fc7\u8c03\u8bd5\u6a21\u5f0f\u4e86\u89e3\u539f\u56e0\uff09",
    "generated_explanation": ""
  },
  {
    "index": 949,
    "code": "public static boolean add(String word)\n    {\n        if (HanLP.Config.Normalization) word = CharTable.convert(word);\n        if (contains(word)) return false;\n        return insert(word, null);\n    }",
    "reference_explanation": "\u5f80\u81ea\u5b9a\u4e49\u8bcd\u5178\u4e2d\u63d2\u5165\u4e00\u4e2a\u65b0\u8bcd\uff08\u975e\u8986\u76d6\u6a21\u5f0f\uff09<br>\n\u52a8\u6001\u589e\u5220\u4e0d\u4f1a\u6301\u4e45\u5316\u5230\u8bcd\u5178\u6587\u4ef6\n\n@param word                \u65b0\u8bcd \u5982\u201c\u88f8\u5a5a\u201d\n@return \u662f\u5426\u63d2\u5165\u6210\u529f\uff08\u5931\u8d25\u7684\u539f\u56e0\u53ef\u80fd\u662f\u4e0d\u8986\u76d6\u7b49\uff0c\u53ef\u4ee5\u901a\u8fc7\u8c03\u8bd5\u6a21\u5f0f\u4e86\u89e3\u539f\u56e0\uff09",
    "generated_explanation": ""
  },
  {
    "index": 950,
    "code": "public static boolean insert(String word, String natureWithFrequency)\n    {\n        if (word == null) return false;\n        if (HanLP.Config.Normalization) word = CharTable.convert(word);\n        CoreDictionary.Attribute att = natureWithFrequency == null ? new CoreDictionary.Attribute(Nature.nz, 1) : CoreDictionary.Attribute.create(natureWithFrequency);\n        if (att == null) return false;\n        if (dat.set(word, att)) return true;\n        if (trie == null) trie = new BinTrie<CoreDictionary.Attribute>();\n        trie.put(word, att);\n        return true;\n    }",
    "reference_explanation": "\u5f80\u81ea\u5b9a\u4e49\u8bcd\u5178\u4e2d\u63d2\u5165\u4e00\u4e2a\u65b0\u8bcd\uff08\u8986\u76d6\u6a21\u5f0f\uff09<br>\n\u52a8\u6001\u589e\u5220\u4e0d\u4f1a\u6301\u4e45\u5316\u5230\u8bcd\u5178\u6587\u4ef6\n\n@param word                \u65b0\u8bcd \u5982\u201c\u88f8\u5a5a\u201d\n@param natureWithFrequency \u8bcd\u6027\u548c\u5176\u5bf9\u5e94\u7684\u9891\u6b21\uff0c\u6bd4\u5982\u201cnz 1 v 2\u201d\uff0cnull\u65f6\u8868\u793a\u201cnz 1\u201d\u3002\n@return \u662f\u5426\u63d2\u5165\u6210\u529f\uff08\u5931\u8d25\u7684\u539f\u56e0\u53ef\u80fd\u662fnatureWithFrequency\u95ee\u9898\uff0c\u53ef\u4ee5\u901a\u8fc7\u8c03\u8bd5\u6a21\u5f0f\u4e86\u89e3\u539f\u56e0\uff09",
    "generated_explanation": ""
  },
  {
    "index": 951,
    "code": "public static boolean loadDat(String path, String customDicPath[], DoubleArrayTrie<CoreDictionary.Attribute> dat)\n    {\n        try\n        {\n            if (isDicNeedUpdate(path, customDicPath))\n            {\n                return false;\n            }\n            ByteArray byteArray = ByteArray.createByteArray(path + Predefine.BIN_EXT);\n            if (byteArray == null) return false;\n            int size = byteArray.nextInt();\n            if (size < 0)   // \u4e00\u79cd\u517c\u5bb9\u63aa\u65bd,\u5f53size\u5c0f\u4e8e\u96f6\u8868\u793a\u6587\u4ef6\u5934\u90e8\u50a8\u5b58\u4e86-size\u4e2a\u7528\u6237\u8bcd\u6027\n            {\n                while (++size <= 0)\n                {\n                    Nature.create(byteArray.nextString());\n                }\n                size = byteArray.nextInt();\n            }\n            CoreDictionary.Attribute[] attributes = new CoreDictionary.Attribute[size];\n            final Nature[] natureIndexArray = Nature.values();\n            for (int i = 0; i < size; ++i)\n            {\n                // \u7b2c\u4e00\u4e2a\u662f\u5168\u90e8\u9891\u6b21\uff0c\u7b2c\u4e8c\u4e2a\u662f\u8bcd\u6027\u4e2a\u6570\n                int currentTotalFrequency = byteArray.nextInt();\n                int length = byteArray.nextInt();\n                attributes[i] = new CoreDictionary.Attribute(length);\n                attributes[i].totalFrequency = currentTotalFrequency;\n                for (int j = 0; j < length; ++j)\n                {\n                    attributes[i].nature[j] = natureIndexArray[byteArray.nextInt()];\n                    attributes[i].frequency[j] = byteArray.nextInt();\n                }\n            }\n            if (!dat.load(byteArray, attributes)) return false;\n        }\n        catch (Exception e)\n        {\n            logger.warning(\"\u8bfb\u53d6\u5931\u8d25\uff0c\u95ee\u9898\u53d1\u751f\u5728\" + TextUtility.exceptionToString(e));\n            return false;\n        }\n        return true;\n    }",
    "reference_explanation": "\u4ece\u78c1\u76d8\u52a0\u8f7d\u53cc\u6570\u7ec4\n\n@param path \u4e3b\u8bcd\u5178\u8def\u5f84\n@param customDicPath \u7528\u6237\u8bcd\u5178\u8def\u5f84\n@return",
    "generated_explanation": ""
  },
  {
    "index": 952,
    "code": "private static boolean isDicNeedUpdate(String mainPath, String path[])\n    {\n        if (HanLP.Config.IOAdapter != null &&\n            !HanLP.Config.IOAdapter.getClass().getName().contains(\"com.hankcs.hanlp.corpus.io.FileIOAdapter\"))\n        {\n            return false;\n        }\n        String binPath = mainPath + Predefine.BIN_EXT;\n        File binFile = new File(binPath);\n        if (!binFile.exists())\n        {\n            return true;\n        }\n        long lastModified = binFile.lastModified();\n        //String path[] = HanLP.Config.CustomDictionaryPath;\n        for (String p : path)\n        {\n            File f = new File(p);\n            String fileName = f.getName();\n            int cut = fileName.lastIndexOf(' ');\n            if (cut > 0)\n            {\n                p = f.getParent() + File.separator + fileName.substring(0, cut);\n            }\n            f = new File(p);\n            if (f.exists() && f.lastModified() > lastModified)\n            {\n                IOUtil.deleteFile(binPath); // \u5220\u6389\u7f13\u5b58\n                logger.info(\"\u5df2\u6e05\u9664\u81ea\u5b9a\u4e49\u8bcd\u5178\u7f13\u5b58\u6587\u4ef6\uff01\");\n                return true;\n            }\n        }\n        return false;\n    }",
    "reference_explanation": "\u83b7\u53d6\u672c\u5730\u8bcd\u5178\u66f4\u65b0\u72b6\u6001\n@return true \u8868\u793a\u672c\u5730\u8bcd\u5178\u6bd4\u7f13\u5b58\u6587\u4ef6\u65b0\uff0c\u9700\u8981\u5220\u9664\u7f13\u5b58",
    "generated_explanation": ""
  },
  {
    "index": 953,
    "code": "public static CoreDictionary.Attribute get(String key)\n    {\n        if (HanLP.Config.Normalization) key = CharTable.convert(key);\n        CoreDictionary.Attribute attribute = dat.get(key);\n        if (attribute != null) return attribute;\n        if (trie == null) return null;\n        return trie.get(key);\n    }",
    "reference_explanation": "\u67e5\u5355\u8bcd\n\n@param key\n@return",
    "generated_explanation": ""
  },
  {
    "index": 954,
    "code": "public static void remove(String key)\n    {\n        if (HanLP.Config.Normalization) key = CharTable.convert(key);\n        if (trie == null) return;\n        trie.remove(key);\n    }",
    "reference_explanation": "\u5220\u9664\u5355\u8bcd<br>\n\u52a8\u6001\u589e\u5220\u4e0d\u4f1a\u6301\u4e45\u5316\u5230\u8bcd\u5178\u6587\u4ef6\n\n@param key",
    "generated_explanation": ""
  },
  {
    "index": 955,
    "code": "public static LinkedList<Map.Entry<String, CoreDictionary.Attribute>> commonPrefixSearch(String key)\n    {\n        return trie.commonPrefixSearchWithValue(key);\n    }",
    "reference_explanation": "\u524d\u7f00\u67e5\u8be2\n\n@param key\n@return",
    "generated_explanation": ""
  },
  {
    "index": 956,
    "code": "public static LinkedList<Map.Entry<String, CoreDictionary.Attribute>> commonPrefixSearch(char[] chars, int begin)\n    {\n        return trie.commonPrefixSearchWithValue(chars, begin);\n    }",
    "reference_explanation": "\u524d\u7f00\u67e5\u8be2\n\n@param chars\n@param begin\n@return",
    "generated_explanation": ""
  },
  {
    "index": 957,
    "code": "public static boolean contains(String key)\n    {\n        if (dat.exactMatchSearch(key) >= 0) return true;\n        return trie != null && trie.containsKey(key);\n    }",
    "reference_explanation": "\u8bcd\u5178\u4e2d\u662f\u5426\u542b\u6709\u8bcd\u8bed\n@param key \u8bcd\u8bed\n@return \u662f\u5426\u5305\u542b",
    "generated_explanation": ""
  },
  {
    "index": 958,
    "code": "public static void parseText(char[] text, AhoCorasickDoubleArrayTrie.IHit<CoreDictionary.Attribute> processor)\n    {\n        if (trie != null)\n        {\n            trie.parseText(text, processor);\n        }\n        DoubleArrayTrie<CoreDictionary.Attribute>.Searcher searcher = dat.getSearcher(text, 0);\n        while (searcher.next())\n        {\n            processor.hit(searcher.begin, searcher.begin + searcher.length, searcher.value);\n        }\n    }",
    "reference_explanation": "\u89e3\u6790\u4e00\u6bb5\u6587\u672c\uff08\u76ee\u524d\u91c7\u7528\u4e86BinTrie+DAT\u7684\u6df7\u5408\u50a8\u5b58\u5f62\u5f0f\uff0c\u6b64\u65b9\u6cd5\u53ef\u4ee5\u7edf\u4e00\u4e24\u4e2a\u6570\u636e\u7ed3\u6784\uff09\n@param text         \u6587\u672c\n@param processor    \u5904\u7406\u5668",
    "generated_explanation": ""
  },
  {
    "index": 959,
    "code": "public static void parseText(String text, AhoCorasickDoubleArrayTrie.IHit<CoreDictionary.Attribute> processor)\n    {\n        if (trie != null)\n        {\n            BaseSearcher searcher = CustomDictionary.getSearcher(text);\n            int offset;\n            Map.Entry<String, CoreDictionary.Attribute> entry;\n            while ((entry = searcher.next()) != null)\n            {\n                offset = searcher.getOffset();\n                processor.hit(offset, offset + entry.getKey().length(), entry.getValue());\n            }\n        }\n        DoubleArrayTrie<CoreDictionary.Attribute>.Searcher searcher = dat.getSearcher(text, 0);\n        while (searcher.next())\n        {\n            processor.hit(searcher.begin, searcher.begin + searcher.length, searcher.value);\n        }\n    }",
    "reference_explanation": "\u89e3\u6790\u4e00\u6bb5\u6587\u672c\uff08\u76ee\u524d\u91c7\u7528\u4e86BinTrie+DAT\u7684\u6df7\u5408\u50a8\u5b58\u5f62\u5f0f\uff0c\u6b64\u65b9\u6cd5\u53ef\u4ee5\u7edf\u4e00\u4e24\u4e2a\u6570\u636e\u7ed3\u6784\uff09\n@param text         \u6587\u672c\n@param processor    \u5904\u7406\u5668",
    "generated_explanation": ""
  },
  {
    "index": 960,
    "code": "public static void parseLongestText(String text, AhoCorasickDoubleArrayTrie.IHit<CoreDictionary.Attribute> processor)\n    {\n        if (trie != null)\n        {\n            final int[] lengthArray = new int[text.length()];\n            final CoreDictionary.Attribute[] attributeArray = new CoreDictionary.Attribute[text.length()];\n            char[] charArray = text.toCharArray();\n            DoubleArrayTrie<CoreDictionary.Attribute>.Searcher searcher = dat.getSearcher(charArray, 0);\n            while (searcher.next())\n            {\n                lengthArray[searcher.begin] = searcher.length;\n                attributeArray[searcher.begin] = searcher.value;\n            }\n            trie.parseText(charArray, new AhoCorasickDoubleArrayTrie.IHit<CoreDictionary.Attribute>()\n            {\n                @Override\n                public void hit(int begin, int end, CoreDictionary.Attribute value)\n                {\n                    int length = end - begin;\n                    if (length > lengthArray[begin])\n                    {\n                        lengthArray[begin] = length;\n                        attributeArray[begin] = value;\n                    }\n                }\n            });\n            for (int i = 0; i < charArray.length;)\n            {\n                if (lengthArray[i] == 0)\n                {\n                    ++i;\n                }\n                else\n                {\n                    processor.hit(i, i + lengthArray[i], attributeArray[i]);\n                    i += lengthArray[i];\n                }\n            }\n        }\n        else\n            dat.parseLongestText(text, processor);\n    }",
    "reference_explanation": "\u6700\u957f\u5339\u914d\n\n@param text      \u6587\u672c\n@param processor \u5904\u7406\u5668",
    "generated_explanation": ""
  },
  {
    "index": 961,
    "code": "public static boolean reload()\n    {\n        String path[] = HanLP.Config.CustomDictionaryPath;\n        if (path == null || path.length == 0) return false;\n        IOUtil.deleteFile(path[0] + Predefine.BIN_EXT); // \u5220\u6389\u7f13\u5b58\n        return loadMainDictionary(path[0]);\n    }",
    "reference_explanation": "\u70ed\u66f4\u65b0\uff08\u91cd\u65b0\u52a0\u8f7d\uff09<br>\n\u96c6\u7fa4\u73af\u5883\uff08\u6216\u5176\u4ed6IOAdapter\uff09\u9700\u8981\u81ea\u884c\u5220\u9664\u7f13\u5b58\u6587\u4ef6\uff08\u8def\u5f84 = HanLP.Config.CustomDictionaryPath[0] + Predefine.BIN_EXT\uff09\n@return \u662f\u5426\u52a0\u8f7d\u6210\u529f",
    "generated_explanation": ""
  },
  {
    "index": 962,
    "code": "protected int[] extractFeature(String[] wordArray, String[] posArray, FeatureMap featureMap, int position)\n    {\n        List<Integer> featVec = new ArrayList<Integer>();\n\n        String pre2Word = position >= 2 ? wordArray[position - 2] : \"_B_\";\n        String preWord = position >= 1 ? wordArray[position - 1] : \"_B_\";\n        String curWord = wordArray[position];\n        String nextWord = position <= wordArray.length - 2 ? wordArray[position + 1] : \"_E_\";\n        String next2Word = position <= wordArray.length - 3 ? wordArray[position + 2] : \"_E_\";\n\n        String pre2Pos = position >= 2 ? posArray[position - 2] : \"_B_\";\n        String prePos = position >= 1 ? posArray[position - 1] : \"_B_\";\n        String curPos = posArray[position];\n        String nextPos = position <= posArray.length - 2 ? posArray[position + 1] : \"_E_\";\n        String next2Pos = position <= posArray.length - 3 ? posArray[position + 2] : \"_E_\";\n\n        StringBuilder sb = new StringBuilder();\n        addFeatureThenClear(sb.append(pre2Word).append('1'), featVec, featureMap);\n        addFeatureThenClear(sb.append(preWord).append('2'), featVec, featureMap);\n        addFeatureThenClear(sb.append(curWord).append('3'), featVec, featureMap);\n        addFeatureThenClear(sb.append(nextWord).append('4'), featVec, featureMap);\n        addFeatureThenClear(sb.append(next2Word).append('5'), featVec, featureMap);\n//        addFeatureThenClear(sb.append(pre2Word).append(preWord).append('6'), featVec, featureMap);\n//        addFeatureThenClear(sb.append(preWord).append(curWord).append('7'), featVec, featureMap);\n//        addFeatureThenClear(sb.append(curWord).append(nextWord).append('8'), featVec, featureMap);\n//        addFeatureThenClear(sb.append(nextWord).append(next2Word).append('9'), featVec, featureMap);\n\n        addFeatureThenClear(sb.append(pre2Pos).append('A'), featVec, featureMap);\n        addFeatureThenClear(sb.append(prePos).append('B'), featVec, featureMap);\n        addFeatureThenClear(sb.append(curPos).append('C'), featVec, featureMap);\n        addFeatureThenClear(sb.append(nextPos).append('D'), featVec, featureMap);\n        addFeatureThenClear(sb.append(next2Pos).append('E'), featVec, featureMap);\n        addFeatureThenClear(sb.append(pre2Pos).append(prePos).append('F'), featVec, featureMap);\n        addFeatureThenClear(sb.append(prePos).append(curPos).append('G'), featVec, featureMap);\n        addFeatureThenClear(sb.append(curPos).append(nextPos).append('H'), featVec, featureMap);\n        addFeatureThenClear(sb.append(nextPos).append(next2Pos).append('I'), featVec, featureMap);\n\n        return toFeatureArray(featVec);\n    }",
    "reference_explanation": "\u63d0\u53d6\u7279\u5f81\uff0coverride\u6b64\u65b9\u6cd5\u6765\u62d3\u5c55\u81ea\u5df1\u7684\u7279\u5f81\u6a21\u677f\n\n@param wordArray  \u8bcd\u8bed\n@param posArray   \u8bcd\u6027\n@param featureMap \u50a8\u5b58\u7279\u5f81\u7684\u7ed3\u6784\n@param position   \u5f53\u524d\u63d0\u53d6\u7684\u8bcd\u8bed\u6240\u5728\u7684\u4f4d\u7f6e\n@return \u7279\u5f81\u5411\u91cf",
    "generated_explanation": ""
  },
  {
    "index": 963,
    "code": "public static StringDictionary load(String path, String separator)\n    {\n        StringDictionary dictionary = new StringDictionary(separator);\n        if (dictionary.load(path)) return dictionary;\n        return null;\n    }",
    "reference_explanation": "\u52a0\u8f7d\u8bcd\u5178\n@param path\n@param separator\n@return",
    "generated_explanation": ""
  },
  {
    "index": 964,
    "code": "public static StringDictionary combine(StringDictionary... args)\n    {\n        StringDictionary[] dictionaries = args.clone();\n        StringDictionary mainDictionary = dictionaries[0];\n        for (int i = 1; i < dictionaries.length; ++i)\n        {\n            mainDictionary.combine(dictionaries[i]);\n        }\n\n        return mainDictionary;\n    }",
    "reference_explanation": "\u5408\u5e76\u8bcd\u5178\uff0c\u7b2c\u4e00\u4e2a\u4e3a\u4e3b\u8bcd\u5178\n@param args\n@return",
    "generated_explanation": ""
  },
  {
    "index": 965,
    "code": "protected BaseFeatureData selectFeatures(IDataSet dataSet)\n    {\n        ChiSquareFeatureExtractor chiSquareFeatureExtractor = new ChiSquareFeatureExtractor();\n\n        logger.start(\"\u4f7f\u7528\u5361\u65b9\u68c0\u6d4b\u9009\u62e9\u7279\u5f81\u4e2d...\");\n        //FeatureStats\u5bf9\u8c61\u5305\u542b\u6587\u6863\u4e2d\u6240\u6709\u7279\u5f81\u53ca\u5176\u7edf\u8ba1\u4fe1\u606f\n        BaseFeatureData featureData = chiSquareFeatureExtractor.extractBasicFeatureData(dataSet); //\u6267\u884c\u7edf\u8ba1\n\n        //\u6211\u4eec\u4f20\u5165\u8fd9\u4e9b\u7edf\u8ba1\u4fe1\u606f\u5230\u7279\u5f81\u9009\u62e9\u7b97\u6cd5\u4e2d\uff0c\u5f97\u5230\u7279\u5f81\u4e0e\u5176\u5206\u503c\n        Map<Integer, Double> selectedFeatures = chiSquareFeatureExtractor.chi_square(featureData);\n\n        //\u4ece\u7edf\u8ba1\u6570\u636e\u4e2d\u5220\u6389\u65e0\u7528\u7684\u7279\u5f81\u5e76\u91cd\u5efa\u7279\u5f81\u6620\u5c04\u8868\n        int[][] featureCategoryJointCount = new int[selectedFeatures.size()][];\n        featureData.wordIdTrie = new BinTrie<Integer>();\n        String[] wordIdArray = dataSet.getLexicon().getWordIdArray();\n        int p = -1;\n        for (Integer feature : selectedFeatures.keySet())\n        {\n            featureCategoryJointCount[++p] = featureData.featureCategoryJointCount[feature];\n            featureData.wordIdTrie.put(wordIdArray[feature], p);\n        }\n        logger.finish(\",\u9009\u4e2d\u7279\u5f81\u6570:%d / %d = %.2f%%\\n\", featureCategoryJointCount.length,\n                      featureData.featureCategoryJointCount.length,\n                      featureCategoryJointCount.length / (double)featureData.featureCategoryJointCount.length * 100.);\n        featureData.featureCategoryJointCount = featureCategoryJointCount;\n\n        return featureData;\n    }",
    "reference_explanation": "\u7edf\u8ba1\u7279\u5f81\u5e76\u4e14\u6267\u884c\u7279\u5f81\u9009\u62e9\uff0c\u8fd4\u56de\u4e00\u4e2aFeatureStats\u5bf9\u8c61\uff0c\u7528\u4e8e\u8ba1\u7b97\u6a21\u578b\u4e2d\u7684\u6982\u7387\n\n@param dataSet\n@return",
    "generated_explanation": ""
  },
  {
    "index": 966,
    "code": "byte getKeyByte(int keyId, int byteId)\n    {\n        if (byteId >= _keys[keyId].length)\n        {\n            return 0;\n        }\n        return _keys[keyId][byteId];\n    }",
    "reference_explanation": "\u83b7\u53d6\u67d0\u4e2akey\u7684\u67d0\u4e00\u4e2a\u5b57\u8282\n@param keyId key\u7684id\n@param byteId \u5b57\u8282\u7684\u4e0b\u6807\uff08\u7b2c\u51e0\u4e2a\u5b57\u8282\uff09\n@return \u5b57\u8282\uff0c\u8fd4\u56de0\u8868\u793a\u8d8a\u754c\u4e86",
    "generated_explanation": ""
  },
  {
    "index": 967,
    "code": "public static Matrix constructWithCopy(double[][] A)\n    {\n        int m = A.length;\n        int n = A[0].length;\n        Matrix X = new Matrix(m, n);\n        double[][] C = X.getArray();\n        for (int i = 0; i < m; i++)\n        {\n            if (A[i].length != n)\n            {\n                throw new IllegalArgumentException\n                        (\"All rows must have the same length.\");\n            }\n            for (int j = 0; j < n; j++)\n            {\n                C[i][j] = A[i][j];\n            }\n        }\n        return X;\n    }",
    "reference_explanation": "Construct a matrix from a copy of a 2-D array.\n\n@param A Two-dimensional array of doubles.\n@throws IllegalArgumentException All rows must have the same length",
    "generated_explanation": ""
  },
  {
    "index": 968,
    "code": "public Matrix copy()\n    {\n        Matrix X = new Matrix(m, n);\n        double[][] C = X.getArray();\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                C[i][j] = A[i][j];\n            }\n        }\n        return X;\n    }",
    "reference_explanation": "Make a deep copy of a matrix",
    "generated_explanation": ""
  },
  {
    "index": 969,
    "code": "public double[][] getArrayCopy()\n    {\n        double[][] C = new double[m][n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                C[i][j] = A[i][j];\n            }\n        }\n        return C;\n    }",
    "reference_explanation": "Copy the internal two-dimensional array.\n\n@return Two-dimensional array copy of matrix elements.",
    "generated_explanation": ""
  },
  {
    "index": 970,
    "code": "public double[] getColumnPackedCopy()\n    {\n        double[] vals = new double[m * n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                vals[i + j * m] = A[i][j];\n            }\n        }\n        return vals;\n    }",
    "reference_explanation": "Make a one-dimensional column packed copy of the internal array.\n\n@return Matrix elements packed in a one-dimensional array by columns.",
    "generated_explanation": ""
  },
  {
    "index": 971,
    "code": "public double[] getRowPackedCopy()\n    {\n        double[] vals = new double[m * n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                vals[i * n + j] = A[i][j];\n            }\n        }\n        return vals;\n    }",
    "reference_explanation": "Make a one-dimensional row packed copy of the internal array.\n\n@return Matrix elements packed in a one-dimensional array by rows.",
    "generated_explanation": ""
  },
  {
    "index": 972,
    "code": "public Matrix getMatrix(int i0, int i1, int j0, int j1)\n    {\n        Matrix X = new Matrix(i1 - i0 + 1, j1 - j0 + 1);\n        double[][] B = X.getArray();\n        try\n        {\n            for (int i = i0; i <= i1; i++)\n            {\n                for (int j = j0; j <= j1; j++)\n                {\n                    B[i - i0][j - j0] = A[i][j];\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n        }\n        return X;\n    }",
    "reference_explanation": "Get a submatrix.\n\n@param i0 Initial row index\n@param i1 Final row index\n@param j0 Initial column index\n@param j1 Final column index\n@return A(i0:i1, j0:j1)\n@throws ArrayIndexOutOfBoundsException Submatrix indices",
    "generated_explanation": ""
  },
  {
    "index": 973,
    "code": "public Matrix getMatrix(int[] r, int[] c)\n    {\n        Matrix X = new Matrix(r.length, c.length);\n        double[][] B = X.getArray();\n        try\n        {\n            for (int i = 0; i < r.length; i++)\n            {\n                for (int j = 0; j < c.length; j++)\n                {\n                    B[i][j] = A[r[i]][c[j]];\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n        }\n        return X;\n    }",
    "reference_explanation": "Get a submatrix.\n\n@param r Array of row indices.\n@param c Array of column indices.\n@return A(r(:), c(:))\n@throws ArrayIndexOutOfBoundsException Submatrix indices",
    "generated_explanation": ""
  },
  {
    "index": 974,
    "code": "public Matrix getMatrix(int i0, int i1, int[] c)\n    {\n        Matrix X = new Matrix(i1 - i0 + 1, c.length);\n        double[][] B = X.getArray();\n        try\n        {\n            for (int i = i0; i <= i1; i++)\n            {\n                for (int j = 0; j < c.length; j++)\n                {\n                    B[i - i0][j] = A[i][c[j]];\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n        }\n        return X;\n    }",
    "reference_explanation": "Get a submatrix.\n\n@param i0 Initial row index\n@param i1 Final row index\n@param c  Array of column indices.\n@return A(i0:i1, c(:))\n@throws ArrayIndexOutOfBoundsException Submatrix indices",
    "generated_explanation": ""
  },
  {
    "index": 975,
    "code": "public Matrix getMatrix(int[] r, int j0, int j1)\n    {\n        Matrix X = new Matrix(r.length, j1 - j0 + 1);\n        double[][] B = X.getArray();\n        try\n        {\n            for (int i = 0; i < r.length; i++)\n            {\n                for (int j = j0; j <= j1; j++)\n                {\n                    B[i][j - j0] = A[r[i]][j];\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n        }\n        return X;\n    }",
    "reference_explanation": "Get a submatrix.\n\n@param r  Array of row indices.\n@param j0 Initial column index\n@param j1 Final column index\n@return A(r(:), j0:j1)\n@throws ArrayIndexOutOfBoundsException Submatrix indices",
    "generated_explanation": ""
  },
  {
    "index": 976,
    "code": "public void setMatrix(int i0, int i1, int j0, int j1, Matrix X)\n    {\n        try\n        {\n            for (int i = i0; i <= i1; i++)\n            {\n                for (int j = j0; j <= j1; j++)\n                {\n                    A[i][j] = X.get(i - i0, j - j0);\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n        }\n    }",
    "reference_explanation": "Set a submatrix.\n\n@param i0 Initial row index\n@param i1 Final row index\n@param j0 Initial column index\n@param j1 Final column index\n@param X  A(i0:i1,j0:j1)\n@throws ArrayIndexOutOfBoundsException Submatrix indices",
    "generated_explanation": ""
  },
  {
    "index": 977,
    "code": "public void setMatrix(int[] r, int[] c, Matrix X)\n    {\n        try\n        {\n            for (int i = 0; i < r.length; i++)\n            {\n                for (int j = 0; j < c.length; j++)\n                {\n                    A[r[i]][c[j]] = X.get(i, j);\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n        }\n    }",
    "reference_explanation": "Set a submatrix.\n\n@param r Array of row indices.\n@param c Array of column indices.\n@param X A(r(:),c(:))\n@throws ArrayIndexOutOfBoundsException Submatrix indices",
    "generated_explanation": ""
  },
  {
    "index": 978,
    "code": "public void setMatrix(int[] r, int j0, int j1, Matrix X)\n    {\n        try\n        {\n            for (int i = 0; i < r.length; i++)\n            {\n                for (int j = j0; j <= j1; j++)\n                {\n                    A[r[i]][j] = X.get(i, j - j0);\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n        }\n    }",
    "reference_explanation": "Set a submatrix.\n\n@param r  Array of row indices.\n@param j0 Initial column index\n@param j1 Final column index\n@param X  A(r(:),j0:j1)\n@throws ArrayIndexOutOfBoundsException Submatrix indices",
    "generated_explanation": ""
  },
  {
    "index": 979,
    "code": "public void setMatrix(int i0, int i1, int[] c, Matrix X)\n    {\n        try\n        {\n            for (int i = i0; i <= i1; i++)\n            {\n                for (int j = 0; j < c.length; j++)\n                {\n                    A[i][c[j]] = X.get(i - i0, j);\n                }\n            }\n        }\n        catch (ArrayIndexOutOfBoundsException e)\n        {\n            throw new ArrayIndexOutOfBoundsException(\"Submatrix indices\");\n        }\n    }",
    "reference_explanation": "Set a submatrix.\n\n@param i0 Initial row index\n@param i1 Final row index\n@param c  Array of column indices.\n@param X  A(i0:i1,c(:))\n@throws ArrayIndexOutOfBoundsException Submatrix indices",
    "generated_explanation": ""
  },
  {
    "index": 980,
    "code": "public double norm1()\n    {\n        double f = 0;\n        for (int j = 0; j < n; j++)\n        {\n            double s = 0;\n            for (int i = 0; i < m; i++)\n            {\n                s += Math.abs(A[i][j]);\n            }\n            f = Math.max(f, s);\n        }\n        return f;\n    }",
    "reference_explanation": "One norm\n\n@return maximum column sum.",
    "generated_explanation": ""
  },
  {
    "index": 981,
    "code": "public Matrix plus(Matrix B)\n    {\n        checkMatrixDimensions(B);\n        Matrix X = new Matrix(m, n);\n        double[][] C = X.getArray();\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                C[i][j] = A[i][j] + B.A[i][j];\n            }\n        }\n        return X;\n    }",
    "reference_explanation": "C = A + B\n\n@param B another matrix\n@return A + B",
    "generated_explanation": ""
  },
  {
    "index": 982,
    "code": "public Matrix plusEquals(Matrix B)\n    {\n        checkMatrixDimensions(B);\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                A[i][j] = A[i][j] + B.A[i][j];\n            }\n        }\n        return this;\n    }",
    "reference_explanation": "A = A + B\n\n@param B another matrix\n@return A + B",
    "generated_explanation": ""
  },
  {
    "index": 983,
    "code": "public Matrix times(double s)\n    {\n        Matrix X = new Matrix(m, n);\n        double[][] C = X.getArray();\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                C[i][j] = s * A[i][j];\n            }\n        }\n        return X;\n    }",
    "reference_explanation": "Multiply a matrix by a scalar, C = s*A\n\n@param s scalar\n@return s*A",
    "generated_explanation": ""
  },
  {
    "index": 984,
    "code": "public Matrix timesEquals(double s)\n    {\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                A[i][j] = s * A[i][j];\n            }\n        }\n        return this;\n    }",
    "reference_explanation": "Multiply a matrix by a scalar in place, A = s*A\n\n@param s scalar\n@return replace A by s*A",
    "generated_explanation": ""
  },
  {
    "index": 985,
    "code": "public Matrix times(Matrix B)\n    {\n        if (B.m != n)\n        {\n            throw new IllegalArgumentException(\"Matrix inner dimensions must agree.\");\n        }\n        Matrix X = new Matrix(m, B.n);\n        double[][] C = X.getArray();\n        double[] Bcolj = new double[n];\n        for (int j = 0; j < B.n; j++)\n        {\n            for (int k = 0; k < n; k++)\n            {\n                Bcolj[k] = B.A[k][j];\n            }\n            for (int i = 0; i < m; i++)\n            {\n                double[] Arowi = A[i];\n                double s = 0;\n                for (int k = 0; k < n; k++)\n                {\n                    s += Arowi[k] * Bcolj[k];\n                }\n                C[i][j] = s;\n            }\n        }\n        return X;\n    }",
    "reference_explanation": "Linear algebraic matrix multiplication, A * B\n\n@param B another matrix\n@return Matrix product, A * B\n@throws IllegalArgumentException Matrix inner dimensions must agree.",
    "generated_explanation": ""
  },
  {
    "index": 986,
    "code": "public double trace()\n    {\n        double t = 0;\n        for (int i = 0; i < Math.min(m, n); i++)\n        {\n            t += A[i][i];\n        }\n        return t;\n    }",
    "reference_explanation": "Matrix trace.\n\n@return sum of the diagonal elements.",
    "generated_explanation": ""
  },
  {
    "index": 987,
    "code": "public static Matrix random(int m, int n)\n    {\n        Matrix A = new Matrix(m, n);\n        double[][] X = A.getArray();\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                X[i][j] = Math.random();\n            }\n        }\n        return A;\n    }",
    "reference_explanation": "Generate matrix with random elements\n\n@param m Number of rows.\n@param n Number of colums.\n@return An m-by-n matrix with uniformly distributed random elements.",
    "generated_explanation": ""
  },
  {
    "index": 988,
    "code": "public static Matrix identity(int m, int n)\n    {\n        Matrix A = new Matrix(m, n);\n        double[][] X = A.getArray();\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                X[i][j] = (i == j ? 1.0 : 0.0);\n            }\n        }\n        return A;\n    }",
    "reference_explanation": "Generate identity matrix\n\n@param m Number of rows.\n@param n Number of colums.\n@return An m-by-n matrix with ones on the diagonal and zeros elsewhere.",
    "generated_explanation": ""
  },
  {
    "index": 989,
    "code": "public void print(int w, int d)\n    {\n        print(new PrintWriter(System.out, true), w, d);\n    }",
    "reference_explanation": "Print the matrix to stdout.   Line the elements up in columns\nwith a Fortran-like 'Fw.d' style format.\n\n@param w Column width.\n@param d Number of digits after the decimal.",
    "generated_explanation": ""
  },
  {
    "index": 990,
    "code": "public void print(PrintWriter output, int w, int d)\n    {\n        DecimalFormat format = new DecimalFormat();\n        format.setDecimalFormatSymbols(new DecimalFormatSymbols(Locale.US));\n        format.setMinimumIntegerDigits(1);\n        format.setMaximumFractionDigits(d);\n        format.setMinimumFractionDigits(d);\n        format.setGroupingUsed(false);\n        print(output, format, w + 2);\n    }",
    "reference_explanation": "Print the matrix to the output stream.   Line the elements up in\ncolumns with a Fortran-like 'Fw.d' style format.\n\n@param output Output stream.\n@param w      Column width.\n@param d      Number of digits after the decimal.",
    "generated_explanation": ""
  },
  {
    "index": 991,
    "code": "public void print(NumberFormat format, int width)\n    {\n        print(new PrintWriter(System.out, true), format, width);\n    }",
    "reference_explanation": "Print the matrix to stdout.  Line the elements up in columns.\nUse the format object, and right justify within columns of width\ncharacters.\nNote that is the matrix is to be read back in, you probably will want\nto use a NumberFormat that is set to US Locale.\n\n@param format A  Formatting object for individual elements.\n@param width  Field width for each column.\n@see DecimalFormat#setDecimalFormatSymbols",
    "generated_explanation": ""
  },
  {
    "index": 992,
    "code": "public void print(PrintWriter output, NumberFormat format, int width)\n    {\n        output.println();  // start on new line.\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                String s = format.format(A[i][j]); // format the number\n                int padding = Math.max(1, width - s.length()); // At _least_ 1 space\n                for (int k = 0; k < padding; k++)\n                    output.print(' ');\n                output.print(s);\n            }\n            output.println();\n        }\n        output.println();   // end with blank line.\n    }\n\n    /**\n     * Read a matrix from a stream.  The format is the same the print method,\n     * so printed matrices can be read back in (provided they were printed using\n     * US Locale).  Elements are separated by\n     * whitespace, all the elements for each row appear on a single line,\n     * the last row is followed by a blank line.\n     *\n     * @param input the input stream.\n     */\n\n    public static Matrix read(BufferedReader input) throws java.io.IOException\n    {\n        StreamTokenizer tokenizer = new StreamTokenizer(input);\n\n        // Although StreamTokenizer will parse numbers, it doesn't recognize\n        // scientific notation (E or D); however, Double.valueOf does.\n        // The strategy here is to disable StreamTokenizer's number parsing.\n        // We'll only get whitespace delimited words, EOL's and EOF's.\n        // These words should all be numbers, for Double.valueOf to parse.\n\n        tokenizer.resetSyntax();\n        tokenizer.wordChars(0, 255);\n        tokenizer.whitespaceChars(0, ' ');\n        tokenizer.eolIsSignificant(true);\n        java.util.Vector<Double> vD = new java.util.Vector<Double>();\n\n        // Ignore initial empty lines\n        while (tokenizer.nextToken() == StreamTokenizer.TT_EOL) ;\n        if (tokenizer.ttype == StreamTokenizer.TT_EOF)\n            throw new java.io.IOException(\"Unexpected EOF on matrix read.\");\n        do\n        {\n            vD.addElement(Double.valueOf(tokenizer.sval)); // Read & store 1st row.\n        }\n        while (tokenizer.nextToken() == StreamTokenizer.TT_WORD);\n\n        int n = vD.size();  // Now we've got the number of columns!\n        double row[] = new double[n];\n        for (int j = 0; j < n; j++)  // extract the elements of the 1st row.\n            row[j] = vD.elementAt(j).doubleValue();\n        java.util.Vector<double[]> v = new java.util.Vector<double[]>();\n        v.addElement(row);  // Start storing rows instead of columns.\n        while (tokenizer.nextToken() == StreamTokenizer.TT_WORD)\n        {\n            // While non-empty lines\n            v.addElement(row = new double[n]);\n            int j = 0;\n            do\n            {\n                if (j >= n) throw new java.io.IOException\n                        (\"Row \" + v.size() + \" is too long.\");\n                row[j++] = Double.valueOf(tokenizer.sval).doubleValue();\n            }\n            while (tokenizer.nextToken() == StreamTokenizer.TT_WORD);\n            if (j < n) throw new java.io.IOException\n                    (\"Row \" + v.size() + \" is too short.\");\n        }\n        int m = v.size();  // Now we've got the number of rows.\n        double[][] A = new double[m][];\n        v.copyInto(A);  // copy the rows out of the vector\n        return new Matrix(A);\n    }\n\n\n/* ------------------------\n   Private Methods\n * ------------------------ */\n\n    /**\n     * Check if size(A) == size(B)\n     **/\n\n    private void checkMatrixDimensions(Matrix B)\n    {\n        if (B.m != m || B.n != n)\n        {\n            throw new IllegalArgumentException(\"Matrix dimensions must agree.\");\n        }\n    }\n\n    private static final long serialVersionUID = 1;\n\n    public static Matrix zero(int m, int n)\n    {\n        Matrix A = new Matrix(m, n);\n        double[][] X = A.getArray();\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                X[i][j] = 0.0;\n            }\n        }\n        return A;\n    }\n\n    public int rows()\n    {\n        return getRowDimension();\n    }\n\n    public int cols()\n    {\n        return getColumnDimension();\n    }\n\n    /**\n     * \u53d6\u51fa\u7b2cj\u5217\u4f5c\u4e3a\u4e00\u4e2a\u5217\u5411\u91cf\n     * @param j\n     * @return\n     */\n    public Matrix col(int j)\n    {\n        double[][] X = new double[m][1];\n        for (int i = 0; i < m; i++)\n        {\n            X[i][0] = A[i][j];\n        }\n        return new Matrix(X);\n    }\n\n    /**\n     * \u53d6\u51fa\u7b2ci\u884c\u4f5c\u4e3a\u4e00\u4e2a\u884c\u5411\u91cf\n     * @param i\n     * @return\n     */\n    public Matrix row(int i)\n    {\n        double[][] X = new double[1][n];\n        for (int j = 0; j < n; j++)\n        {\n            X[0][j] = A[i][j];\n        }\n        return new Matrix(X);\n    }\n\n    public Matrix block(int i, int j, int p, int q)\n    {\n        return getMatrix(i, i + p - 1, j, j + q - 1);\n    }\n\n    /**\n     * \u8fd4\u56de\u77e9\u9635\u7684\u7acb\u65b9\uff08\u4ee5\u6570\u7ec4\u5f62\u5f0f\uff09\n     * @return\n     */\n    public double[][] cube()\n    {\n        double[][] X = new double[m][n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                X[i][j] = Math.pow(A[i][j], 3.);\n            }\n        }\n\n        return X;\n    }\n\n    public void setZero()\n    {\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                A[i][j] = 0.;\n            }\n        }\n    }\n\n    public void save(DataOutputStream out) throws Exception\n    {\n        out.writeInt(m);\n        out.writeInt(n);\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                out.writeDouble(A[i][j]);\n            }\n        }\n    }\n\n    public boolean load(ByteArray byteArray)\n    {\n        m = byteArray.nextInt();\n        n = byteArray.nextInt();\n        A = new double[m][n];\n        for (int i = 0; i < m; i++)\n        {\n            for (int j = 0; j < n; j++)\n            {\n                A[i][j] = byteArray.nextDouble();\n            }\n        }\n        return true;\n    }\n}",
    "reference_explanation": "Print the matrix to the output stream.  Line the elements up in columns.\nUse the format object, and right justify within columns of width\ncharacters.\nNote that is the matrix is to be read back in, you probably will want\nto use a NumberFormat that is set to US Locale.\n\n@param output the output stream.\n@param format A formatting object to format the matrix elements\n@param width  Column width.\n@see DecimalFormat#setDecimalFormatSymbols",
    "generated_explanation": ""
  },
  {
    "index": 993,
    "code": "void copy(State source)\n    {\n        this.ref = source.ref;\n        this.score = source.score;\n        this.previous = source.previous;\n        this.buffer = source.buffer;\n        this.top0 = source.top0;\n        this.top1 = source.top1;\n        this.stack = source.stack;\n        this.last_action = source.last_action;\n        this.heads = source.heads;\n        this.deprels = source.deprels;\n        this.left_most_child = source.left_most_child;\n        this.right_most_child = source.right_most_child;\n        this.left_2nd_most_child = source.left_2nd_most_child;\n        this.right_2nd_most_child = source.right_2nd_most_child;\n        this.nr_left_children = source.nr_left_children;\n        this.nr_right_children = source.nr_right_children;\n    }",
    "reference_explanation": "\u514b\u9686\u4e00\u4e2a\u72b6\u6001\u5230\u81ea\u5df1\n@param source \u6e90\u72b6\u6001",
    "generated_explanation": ""
  },
  {
    "index": 994,
    "code": "void refresh_stack_information()\n    {\n        int sz = stack.size();\n        if (0 == sz)\n        {\n            top0 = -1;\n            top1 = -1;\n        }\n        else if (1 == sz)\n        {\n            top0 = stack.get(sz - 1);\n            top1 = -1;\n        }\n        else\n        {\n            top0 = stack.get(sz - 1);\n            top1 = stack.get(sz - 2);\n        }\n    }",
    "reference_explanation": "\u66f4\u65b0\u6808\u7684\u4fe1\u606f",
    "generated_explanation": ""
  },
  {
    "index": 995,
    "code": "boolean shift(State source)\n    {\n        if (!source.can_shift())\n        {\n            return false;\n        }\n\n        this.copy(source);\n        stack.add(this.buffer);\n        refresh_stack_information();\n        ++this.buffer;\n\n        this.last_action = ActionFactory.make_shift();\n        this.previous = source;\n        return true;\n    }",
    "reference_explanation": "\u4e0d\u5efa\u7acb\u4f9d\u5b58\u5173\u7cfb\uff0c\u53ea\u8f6c\u79fb\u53e5\u6cd5\u5206\u6790\u7684\u7126\u70b9\uff0c\u5373\u539f\u6765\u7684\u53f3\u7126\u70b9\u8bcd\u53d8\u4e3a\u65b0\u7684\u5de6\u7126\u70b9\u8bcd\uff08\u672c\u72b6\u6001\uff09\uff0c\u4f9d\u6b64\u7c7b\u63a8\u3002\n@param source \u53f3\u7126\u70b9\u8bcd\n@return \u662f\u5426shift\u6210\u529f",
    "generated_explanation": ""
  },
  {
    "index": 996,
    "code": "void get_possible_actions(State source,\n                              List<Action> actions)\n    {\n        if (0 == L || -1 == R)\n        {\n            System.err.println(\"decoder: not initialized, please check if the root dependency relation is correct set by --root.\");\n            return;\n        }\n        actions.clear();\n\n        if (!source.buffer_empty())\n        {\n            actions.add(ActionFactory.make_shift());\n        }\n\n        if (source.stack_size() == 2)\n        {\n            if (source.buffer_empty())\n            {\n                actions.add(ActionFactory.make_right_arc(R));\n            }\n        }\n        else if (source.stack_size() > 2)\n        {\n            for (int l = 0; l < L; ++l)\n            {\n                if (l == R)\n                {\n                    continue;\n                }\n                actions.add(ActionFactory.make_left_arc(l));\n                actions.add(ActionFactory.make_right_arc(l));\n            }\n        }\n    }",
    "reference_explanation": "\u83b7\u53d6\u5f53\u524d\u72b6\u6001\u53ef\u80fd\u7684\u52a8\u4f5c\uff08\u52a8\u4f5c=shift | left | right + \u4f9d\u5b58\u5173\u7cfb\uff0c\u4e5f\u5c31\u662f\u8bf4\u662f\u4e00\u6761\u65e2\u6709\u65b9\u5411\u53c8\u6709\u4f9d\u5b58\u5173\u7cfb\u540d\u79f0\u7684\u4f9d\u5b58\u8fb9\uff09\n@param source \u5f53\u524d\u72b6\u6001\n@param actions \u8f93\u51fa\u53ef\u80fd\u52a8\u4f5c",
    "generated_explanation": ""
  },
  {
    "index": 997,
    "code": "void transit(State source, Action act, State target)\n    {\n        int deprel = 0;\n        int[] deprel_inference = new int[]{deprel};\n        if (ActionUtils.is_shift(act))\n        {\n            target.shift(source);\n        }\n        else if (ActionUtils.is_left_arc(act, deprel_inference))\n        {\n            deprel = deprel_inference[0];\n            target.left_arc(source, deprel);\n        }\n        else if (ActionUtils.is_right_arc(act, deprel_inference))\n        {\n            deprel = deprel_inference[0];\n            target.right_arc(source, deprel);\n        }\n        else\n        {\n            System.err.printf(\"unknown transition in transit: %d-%d\", act.name(), act.rel());\n        }\n    }",
    "reference_explanation": "\u8f6c\u79fb\u72b6\u6001\n@param source \u6e90\u72b6\u6001\n@param act \u52a8\u4f5c\n@param target \u76ee\u6807\u72b6\u6001",
    "generated_explanation": ""
  },
  {
    "index": 998,
    "code": "int transform(Action act)\n    {\n        int deprel = 0;\n        int[] deprel_inference = new int[]{deprel};\n        if (ActionUtils.is_shift(act))\n        {\n            return 0;\n        }\n        else if (ActionUtils.is_left_arc(act, deprel_inference))\n        {\n            deprel = deprel_inference[0];\n            return 1 + deprel;\n        }\n        else if (ActionUtils.is_right_arc(act, deprel_inference))\n        {\n            deprel = deprel_inference[0];\n            return L + 1 + deprel;\n        }\n        else\n        {\n            System.err.printf(\"unknown transition in transform(Action): %d-%d\", act.name(), act.rel());\n        }\n        return -1;\n    }",
    "reference_explanation": "\u8f6c\u6362\u52a8\u4f5c\u4e3a\u52a8\u4f5cid\n@param act \u52a8\u4f5c\n@return \u52a8\u4f5c\u7c7b\u578b\u7684\u4f9d\u5b58\u5173\u7cfbid",
    "generated_explanation": ""
  },
  {
    "index": 999,
    "code": "Action transform(int act)\n    {\n        if (act == 0)\n        {\n            return ActionFactory.make_shift();\n        }\n        else if (act < 1 + L)\n        {\n            return ActionFactory.make_left_arc(act - 1);\n        }\n        else if (act < 1 + 2 * L)\n        {\n            return ActionFactory.make_right_arc(act - 1 - L);\n        }\n        else\n        {\n            System.err.printf(\"unknown transition in transform(int): %d\", act);\n        }\n        return new Action();\n    }",
    "reference_explanation": "\u8f6c\u6362\u52a8\u4f5cid\u4e3a\u52a8\u4f5c\n@param act \u52a8\u4f5c\u7c7b\u578b\u7684\u4f9d\u5b58\u5173\u7cfbid\n@return \u52a8\u4f5c",
    "generated_explanation": ""
  }
]